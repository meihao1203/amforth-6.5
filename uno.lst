
AVRASM ver. 2.2.6  uno.asm Thu Feb 08 14:31:26 2018

uno.asm(5): Including file 'amforth-6.5\avr8\preamble.inc'
amforth-6.5\avr8\preamble.inc(2): Including file 'amforth-6.5\avr8\macros.asm'
amforth-6.5\avr8\macros.asm(6): Including file 'amforth-6.5\avr8\user.inc'
amforth-6.5\avr8\preamble.inc(6): Including file 'device.asm'
device.asm(5): Including file 'm328Pdef.inc'
uno.asm(8): Including file 'amforth-6.5\avr8\drivers/usart_0.asm'
amforth-6.5\avr8\drivers/usart_0.asm(32): Including file 'amforth-6.5\avr8\drivers/usart_common.asm'
amforth-6.5\avr8\drivers/usart_common.asm(11): Including file 'amforth-6.5\avr8\drivers/usart-rx-buffer.asm'
amforth-6.5\avr8\drivers/usart_common.asm(24): Including file 'amforth-6.5\avr8\words/usart-tx-poll.asm'
amforth-6.5\avr8\drivers/usart_common.asm(29): Including file 'amforth-6.5\avr8\words/ubrr.asm'
amforth-6.5\avr8\drivers/usart_common.asm(30): Including file 'amforth-6.5\avr8\words/usart.asm'
uno.asm(13): Including file 'amforth-6.5\avr8\drivers/1wire.asm'
uno.asm(15): Including file 'amforth-6.5\avr8\amforth.asm'
amforth-6.5\avr8\amforth.asm(12): Including file 'amforth-6.5\avr8\drivers/generic-isr.asm'
amforth-6.5\avr8\amforth.asm(14): Including file 'amforth-6.5\avr8\dict/rww.inc'
amforth-6.5\avr8\dict/rww.inc(1): Including file 'amforth-6.5\avr8\words/mplus.asm'
amforth-6.5\avr8\dict/rww.inc(2): Including file 'amforth-6.5\common\words/ud-star.asm'
amforth-6.5\avr8\dict/rww.inc(3): Including file 'amforth-6.5\common\words/umax.asm'
amforth-6.5\avr8\dict/rww.inc(4): Including file 'amforth-6.5\common\words/umin.asm'
amforth-6.5\avr8\dict/rww.inc(5): Including file 'amforth-6.5\avr8\words/immediate-q.asm'
amforth-6.5\avr8\dict/rww.inc(6): Including file 'amforth-6.5\avr8\words/name2flags.asm'
amforth-6.5\avr8\dict/rww.inc(11): Including file 'amforth-6.5\avr8\dict/appl_4k.inc'
amforth-6.5\avr8\dict/appl_4k.inc(1): Including file 'amforth-6.5\common\words/ver.asm'
amforth-6.5\avr8\dict/appl_4k.inc(4): Including file 'amforth-6.5\common\words/noop.asm'
amforth-6.5\avr8\dict/appl_4k.inc(5): Including file 'amforth-6.5\avr8\words/unused.asm'
amforth-6.5\avr8\dict/appl_4k.inc(6): Including file 'amforth-6.5\common\words/to.asm'
amforth-6.5\avr8\dict/appl_4k.inc(7): Including file 'amforth-6.5\avr8\words/i-cellplus.asm'
amforth-6.5\avr8\dict/appl_4k.inc(8): Including file 'amforth-6.5\avr8\words/icompare.asm'
amforth-6.5\avr8\dict/appl_4k.inc(9): Including file 'amforth-6.5\common\words/star.asm'
amforth-6.5\avr8\dict/appl_4k.inc(10): Including file 'amforth-6.5\avr8\words/j.asm'
amforth-6.5\avr8\dict/appl_4k.inc(11): Including file 'amforth-6.5\avr8\words/dabs.asm'
amforth-6.5\avr8\dict/appl_4k.inc(12): Including file 'amforth-6.5\avr8\words/dnegate.asm'
amforth-6.5\avr8\dict/appl_4k.inc(13): Including file 'amforth-6.5\avr8\words/cmove.asm'
amforth-6.5\avr8\dict/appl_4k.inc(14): Including file 'amforth-6.5\common\words/2swap.asm'
amforth-6.5\avr8\dict/appl_4k.inc(15): Including file 'amforth-6.5\common\words/tib.asm'
amforth-6.5\avr8\dict/appl_4k.inc(16): Including file 'amforth-6.5\avr8\words/init-ram.asm'
amforth-6.5\avr8\dict/appl_4k.inc(20): Including file 'amforth-6.5\avr8\words/environment.asm'
amforth-6.5\avr8\dict/appl_4k.inc(21): Including file 'amforth-6.5\avr8\words/env-wordlists.asm'
amforth-6.5\avr8\dict/appl_4k.inc(22): Including file 'amforth-6.5\avr8\words/env-slashpad.asm'
amforth-6.5\avr8\dict/appl_4k.inc(23): Including file 'amforth-6.5\common\words/env-slashhold.asm'
amforth-6.5\avr8\dict/appl_4k.inc(24): Including file 'amforth-6.5\common\words/env-forthname.asm'
amforth-6.5\avr8\dict/appl_4k.inc(25): Including file 'amforth-6.5\common\words/env-forthversion.asm'
amforth-6.5\avr8\dict/appl_4k.inc(26): Including file 'amforth-6.5\common\words/env-cpu.asm'
amforth-6.5\avr8\dict/appl_4k.inc(27): Including file 'amforth-6.5\avr8\words/env-mcuinfo.asm'
amforth-6.5\avr8\dict/appl_4k.inc(28): Including file 'amforth-6.5\common\words/env-usersize.asm'
amforth-6.5\avr8\dict/appl_4k.inc(30): Including file 'amforth-6.5\avr8\words/hld.asm'
amforth-6.5\avr8\dict/appl_4k.inc(31): Including file 'amforth-6.5\common\words/hold.asm'
amforth-6.5\avr8\dict/appl_4k.inc(32): Including file 'amforth-6.5\common\words/less-sharp.asm'
amforth-6.5\avr8\dict/appl_4k.inc(33): Including file 'amforth-6.5\common\words/sharp.asm'
amforth-6.5\avr8\dict/appl_4k.inc(34): Including file 'amforth-6.5\common\words/sharp-s.asm'
amforth-6.5\avr8\dict/appl_4k.inc(35): Including file 'amforth-6.5\common\words/sharp-greater.asm'
amforth-6.5\avr8\dict/appl_4k.inc(36): Including file 'amforth-6.5\common\words/sign.asm'
amforth-6.5\avr8\dict/appl_4k.inc(37): Including file 'amforth-6.5\common\words/d-dot-r.asm'
amforth-6.5\avr8\dict/appl_4k.inc(38): Including file 'amforth-6.5\common\words/dot-r.asm'
amforth-6.5\avr8\dict/appl_4k.inc(39): Including file 'amforth-6.5\common\words/d-dot.asm'
amforth-6.5\avr8\dict/appl_4k.inc(40): Including file 'amforth-6.5\common\words/dot.asm'
amforth-6.5\avr8\dict/appl_4k.inc(41): Including file 'amforth-6.5\common\words/ud-dot.asm'
amforth-6.5\avr8\dict/appl_4k.inc(42): Including file 'amforth-6.5\common\words/ud-dot-r.asm'
amforth-6.5\avr8\dict/appl_4k.inc(43): Including file 'amforth-6.5\common\words/ud-slash-mod.asm'
amforth-6.5\avr8\dict/appl_4k.inc(44): Including file 'amforth-6.5\common\words/digit-q.asm'
amforth-6.5\avr8\dict/appl_4k.inc(46): Including file 'amforth-6.5\avr8\words/do-sliteral.asm'
amforth-6.5\avr8\dict/appl_4k.inc(47): Including file 'amforth-6.5\avr8\words/scomma.asm'
amforth-6.5\avr8\dict/appl_4k.inc(48): Including file 'amforth-6.5\avr8\words/itype.asm'
amforth-6.5\avr8\dict/appl_4k.inc(49): Including file 'amforth-6.5\avr8\words/icount.asm'
amforth-6.5\avr8\dict/appl_4k.inc(50): Including file 'amforth-6.5\common\words/type.asm'
amforth-6.5\avr8\dict/appl_4k.inc(51): Including file 'amforth-6.5\common\words/tick.asm'
amforth-6.5\avr8\dict/appl_4k.inc(53): Including file 'amforth-6.5\common\words/cskip.asm'
amforth-6.5\avr8\dict/appl_4k.inc(54): Including file 'amforth-6.5\common\words/cscan.asm'
amforth-6.5\avr8\dict/appl_4k.inc(55): Including file 'amforth-6.5\common\words/accept.asm'
amforth-6.5\avr8\dict/appl_4k.inc(56): Including file 'amforth-6.5\common\words/refill.asm'
amforth-6.5\avr8\dict/appl_4k.inc(57): Including file 'amforth-6.5\common\words/char.asm'
amforth-6.5\avr8\dict/appl_4k.inc(58): Including file 'amforth-6.5\common\words/number.asm'
amforth-6.5\avr8\dict/appl_4k.inc(59): Including file 'amforth-6.5\common\words/q-sign.asm'
amforth-6.5\avr8\dict/appl_4k.inc(60): Including file 'amforth-6.5\common\words/set-base.asm'
amforth-6.5\avr8\dict/appl_4k.inc(61): Including file 'amforth-6.5\common\words/to-number.asm'
amforth-6.5\avr8\dict/appl_4k.inc(62): Including file 'amforth-6.5\common\words/parse.asm'
amforth-6.5\avr8\dict/appl_4k.inc(63): Including file 'amforth-6.5\common\words/source.asm'
amforth-6.5\avr8\dict/appl_4k.inc(64): Including file 'amforth-6.5\common\words/slash-string.asm'
amforth-6.5\avr8\dict/appl_4k.inc(65): Including file 'amforth-6.5\common\words/parse-name.asm'
amforth-6.5\avr8\dict/appl_4k.inc(66): Including file 'amforth-6.5\avr8\words/sp0.asm'
amforth-6.5\avr8\dict/appl_4k.inc(67): Including file 'amforth-6.5\avr8\words/rp0.asm'
amforth-6.5\avr8\dict/appl_4k.inc(68): Including file 'amforth-6.5\common\words/depth.asm'
amforth-6.5\avr8\dict/appl_4k.inc(69): Including file 'amforth-6.5\avr8\words/forth-recognizer.asm'
amforth-6.5\avr8\dict/appl_4k.inc(70): Including file 'amforth-6.5\common\words/recognize.asm'
amforth-6.5\avr8\dict/appl_4k.inc(71): Including file 'amforth-6.5\common\words/interpret.asm'
amforth-6.5\avr8\dict/appl_4k.inc(72): Including file 'amforth-6.5\common\words/rec-intnum.asm'
amforth-6.5\avr8\dict/appl_4k.inc(73): Including file 'amforth-6.5\common\words/rec-find.asm'
amforth-6.5\avr8\dict/appl_4k.inc(74): Including file 'amforth-6.5\common\words/dt-null.asm'
amforth-6.5\avr8\dict/appl_4k.inc(75): Including file 'amforth-6.5\common\words/search-wordlist.asm'
amforth-6.5\avr8\dict/appl_4k.inc(76): Including file 'amforth-6.5\common\words/traverse-wordlist.asm'
amforth-6.5\avr8\dict/appl_4k.inc(77): Including file 'amforth-6.5\common\words/name2string.asm'
amforth-6.5\avr8\dict/appl_4k.inc(78): Including file 'amforth-6.5\avr8\words/nfa2cfa.asm'
amforth-6.5\avr8\dict/appl_4k.inc(79): Including file 'amforth-6.5\common\words/find-xt.asm'
amforth-6.5\avr8\dict/appl_4k.inc(81): Including file 'amforth-6.5\avr8\dict/compiler1.inc'
amforth-6.5\avr8\dict/compiler1.inc(2): Including file 'amforth-6.5\avr8\words/newest.asm'
amforth-6.5\avr8\dict/compiler1.inc(3): Including file 'amforth-6.5\avr8\words/latest.asm'
amforth-6.5\avr8\dict/compiler1.inc(4): Including file 'amforth-6.5\common\words/do-create.asm'
amforth-6.5\avr8\dict/compiler1.inc(5): Including file 'amforth-6.5\common\words/backslash.asm'
amforth-6.5\avr8\dict/compiler1.inc(6): Including file 'amforth-6.5\common\words/l-paren.asm'
amforth-6.5\avr8\dict/compiler1.inc(8): Including file 'amforth-6.5\common\words/compile.asm'
amforth-6.5\avr8\dict/compiler1.inc(9): Including file 'amforth-6.5\avr8\words/comma.asm'
amforth-6.5\avr8\dict/compiler1.inc(10): Including file 'amforth-6.5\common\words/brackettick.asm'
amforth-6.5\avr8\dict/compiler1.inc(13): Including file 'amforth-6.5\common\words/literal.asm'
amforth-6.5\avr8\dict/compiler1.inc(14): Including file 'amforth-6.5\common\words/sliteral.asm'
amforth-6.5\avr8\dict/compiler1.inc(15): Including file 'amforth-6.5\avr8\words/g-mark.asm'
amforth-6.5\avr8\dict/compiler1.inc(16): Including file 'amforth-6.5\avr8\words/g-resolve.asm'
amforth-6.5\avr8\dict/compiler1.inc(17): Including file 'amforth-6.5\avr8\words/l_mark.asm'
amforth-6.5\avr8\dict/compiler1.inc(18): Including file 'amforth-6.5\avr8\words/l_resolve.asm'
amforth-6.5\avr8\dict/compiler1.inc(20): Including file 'amforth-6.5\common\words/ahead.asm'
amforth-6.5\avr8\dict/compiler1.inc(21): Including file 'amforth-6.5\common\words/if.asm'
amforth-6.5\avr8\dict/compiler1.inc(22): Including file 'amforth-6.5\common\words/else.asm'
amforth-6.5\avr8\dict/compiler1.inc(23): Including file 'amforth-6.5\common\words/then.asm'
amforth-6.5\avr8\dict/compiler1.inc(24): Including file 'amforth-6.5\common\words/begin.asm'
amforth-6.5\avr8\dict/compiler1.inc(25): Including file 'amforth-6.5\common\words/while.asm'
amforth-6.5\avr8\dict/compiler1.inc(26): Including file 'amforth-6.5\common\words/repeat.asm'
amforth-6.5\avr8\dict/compiler1.inc(27): Including file 'amforth-6.5\common\words/until.asm'
amforth-6.5\avr8\dict/compiler1.inc(28): Including file 'amforth-6.5\common\words/again.asm'
amforth-6.5\avr8\dict/compiler1.inc(29): Including file 'amforth-6.5\common\words/do.asm'
amforth-6.5\avr8\dict/compiler1.inc(30): Including file 'amforth-6.5\common\words/loop.asm'
amforth-6.5\avr8\dict/compiler1.inc(31): Including file 'amforth-6.5\common\words/plusloop.asm'
amforth-6.5\avr8\dict/compiler1.inc(32): Including file 'amforth-6.5\common\words/leave.asm'
amforth-6.5\avr8\dict/compiler1.inc(33): Including file 'amforth-6.5\common\words/qdo.asm'
amforth-6.5\avr8\dict/compiler1.inc(34): Including file 'amforth-6.5\common\words/endloop.asm'
amforth-6.5\avr8\dict/compiler1.inc(36): Including file 'amforth-6.5\common\words/l-from.asm'
amforth-6.5\avr8\dict/compiler1.inc(37): Including file 'amforth-6.5\common\words/to-l.asm'
amforth-6.5\avr8\dict/compiler1.inc(38): Including file 'amforth-6.5\avr8\words/lp0.asm'
amforth-6.5\avr8\dict/compiler1.inc(39): Including file 'amforth-6.5\avr8\words/lp.asm'
amforth-6.5\avr8\dict/compiler1.inc(41): Including file 'amforth-6.5\common\words/create.asm'
amforth-6.5\avr8\dict/compiler1.inc(42): Including file 'amforth-6.5\avr8\words/header.asm'
amforth-6.5\avr8\dict/compiler1.inc(43): Including file 'amforth-6.5\avr8\words/wlscope.asm'
amforth-6.5\avr8\dict/compiler1.inc(44): Including file 'amforth-6.5\common\words/reveal.asm'
amforth-6.5\avr8\dict/compiler1.inc(45): Including file 'amforth-6.5\avr8\words/does.asm'
amforth-6.5\avr8\dict/compiler1.inc(46): Including file 'amforth-6.5\common\words/colon.asm'
amforth-6.5\avr8\dict/compiler1.inc(47): Including file 'amforth-6.5\avr8\words/colon-noname.asm'
amforth-6.5\avr8\dict/compiler1.inc(48): Including file 'amforth-6.5\common\words/semicolon.asm'
amforth-6.5\avr8\dict/compiler1.inc(49): Including file 'amforth-6.5\common\words/right-bracket.asm'
amforth-6.5\avr8\dict/compiler1.inc(50): Including file 'amforth-6.5\common\words/left-bracket.asm'
amforth-6.5\avr8\dict/compiler1.inc(51): Including file 'amforth-6.5\common\words/variable.asm'
amforth-6.5\avr8\dict/compiler1.inc(52): Including file 'amforth-6.5\common\words/constant.asm'
amforth-6.5\avr8\dict/compiler1.inc(53): Including file 'amforth-6.5\avr8\words/user.asm'
amforth-6.5\avr8\dict/compiler1.inc(55): Including file 'amforth-6.5\common\words/recurse.asm'
amforth-6.5\avr8\dict/compiler1.inc(56): Including file 'amforth-6.5\avr8\words/immediate.asm'
amforth-6.5\avr8\dict/compiler1.inc(58): Including file 'amforth-6.5\common\words/bracketchar.asm'
amforth-6.5\avr8\dict/compiler1.inc(59): Including file 'amforth-6.5\common\words/abort-string.asm'
amforth-6.5\avr8\dict/compiler1.inc(60): Including file 'amforth-6.5\common\words/abort.asm'
amforth-6.5\avr8\dict/compiler1.inc(61): Including file 'amforth-6.5\common\words/q-abort.asm'
amforth-6.5\avr8\dict/compiler1.inc(63): Including file 'amforth-6.5\common\words/get-stack.asm'
amforth-6.5\avr8\dict/compiler1.inc(64): Including file 'amforth-6.5\common\words/set-stack.asm'
amforth-6.5\avr8\dict/compiler1.inc(65): Including file 'amforth-6.5\common\words/map-stack.asm'
amforth-6.5\avr8\dict/compiler1.inc(66): Including file 'amforth-6.5\avr8\words/get-current.asm'
amforth-6.5\avr8\dict/compiler1.inc(67): Including file 'amforth-6.5\common\words/get-order.asm'
amforth-6.5\avr8\dict/compiler1.inc(68): Including file 'amforth-6.5\common\words/cfg-order.asm'
amforth-6.5\avr8\dict/compiler1.inc(69): Including file 'amforth-6.5\avr8\words/compare.asm'
amforth-6.5\avr8\dict/compiler1.inc(70): Including file 'amforth-6.5\avr8\words/nfa2lfa.asm'
amforth-6.5\avr8\amforth.asm(15): Including file 'dict_appl.inc'
dict_appl.inc(4): Including file 'amforth-6.5\avr8\dict/compiler2.inc'
amforth-6.5\avr8\dict/compiler2.inc(8): Including file 'amforth-6.5\avr8\words/set-current.asm'
amforth-6.5\avr8\dict/compiler2.inc(9): Including file 'amforth-6.5\avr8\words/wordlist.asm'
amforth-6.5\avr8\dict/compiler2.inc(11): Including file 'amforth-6.5\avr8\words/forth-wordlist.asm'
amforth-6.5\avr8\dict/compiler2.inc(12): Including file 'amforth-6.5\common\words/set-order.asm'
amforth-6.5\avr8\dict/compiler2.inc(13): Including file 'amforth-6.5\common\words/set-recognizer.asm'
amforth-6.5\avr8\dict/compiler2.inc(14): Including file 'amforth-6.5\common\words/get-recognizer.asm'
amforth-6.5\avr8\dict/compiler2.inc(15): Including file 'amforth-6.5\avr8\words/code.asm'
amforth-6.5\avr8\dict/compiler2.inc(16): Including file 'amforth-6.5\avr8\words/end-code.asm'
amforth-6.5\avr8\dict/compiler2.inc(17): Including file 'amforth-6.5\avr8\words/marker.asm'
amforth-6.5\avr8\dict/compiler2.inc(18): Including file 'amforth-6.5\common\words/postpone.asm'
dict_appl.inc(6): Including file 'words/applturnkey.asm'
amforth-6.5\avr8\amforth.asm(23): Including file 'amforth-6.5\avr8\amforth-interpreter.asm'
amforth-6.5\avr8\amforth.asm(24): Including file 'amforth-6.5\avr8\dict/nrww.inc'
amforth-6.5\avr8\dict/nrww.inc(4): Including file 'amforth-6.5\avr8\words/exit.asm'
amforth-6.5\avr8\dict/nrww.inc(5): Including file 'amforth-6.5\avr8\words/execute.asm'
amforth-6.5\avr8\dict/nrww.inc(6): Including file 'amforth-6.5\avr8\words/dobranch.asm'
amforth-6.5\avr8\dict/nrww.inc(7): Including file 'amforth-6.5\avr8\words/docondbranch.asm'
amforth-6.5\avr8\dict/nrww.inc(10): Including file 'amforth-6.5\avr8\words/doliteral.asm'
amforth-6.5\avr8\dict/nrww.inc(11): Including file 'amforth-6.5\avr8\words/dovariable.asm'
amforth-6.5\avr8\dict/nrww.inc(12): Including file 'amforth-6.5\avr8\words/doconstant.asm'
amforth-6.5\avr8\dict/nrww.inc(13): Including file 'amforth-6.5\avr8\words/douser.asm'
amforth-6.5\avr8\dict/nrww.inc(14): Including file 'amforth-6.5\avr8\words/do-value.asm'
amforth-6.5\avr8\dict/nrww.inc(15): Including file 'amforth-6.5\avr8\words/fetch.asm'
amforth-6.5\avr8\dict/nrww.inc(16): Including file 'amforth-6.5\avr8\words/store.asm'
amforth-6.5\avr8\dict/nrww.inc(17): Including file 'amforth-6.5\avr8\words/cstore.asm'
amforth-6.5\avr8\dict/nrww.inc(18): Including file 'amforth-6.5\avr8\words/cfetch.asm'
amforth-6.5\avr8\dict/nrww.inc(19): Including file 'amforth-6.5\avr8\words/fetch-u.asm'
amforth-6.5\avr8\dict/nrww.inc(20): Including file 'amforth-6.5\avr8\words/store-u.asm'
amforth-6.5\avr8\dict/nrww.inc(23): Including file 'amforth-6.5\avr8\words/dup.asm'
amforth-6.5\avr8\dict/nrww.inc(24): Including file 'amforth-6.5\avr8\words/qdup.asm'
amforth-6.5\avr8\dict/nrww.inc(25): Including file 'amforth-6.5\avr8\words/swap.asm'
amforth-6.5\avr8\dict/nrww.inc(26): Including file 'amforth-6.5\avr8\words/over.asm'
amforth-6.5\avr8\dict/nrww.inc(27): Including file 'amforth-6.5\avr8\words/drop.asm'
amforth-6.5\avr8\dict/nrww.inc(28): Including file 'amforth-6.5\avr8\words/rot.asm'
amforth-6.5\avr8\dict/nrww.inc(29): Including file 'amforth-6.5\avr8\words/nip.asm'
amforth-6.5\avr8\dict/nrww.inc(31): Including file 'amforth-6.5\avr8\words/r_from.asm'
amforth-6.5\avr8\dict/nrww.inc(32): Including file 'amforth-6.5\avr8\words/to_r.asm'
amforth-6.5\avr8\dict/nrww.inc(33): Including file 'amforth-6.5\avr8\words/r_fetch.asm'
amforth-6.5\avr8\dict/nrww.inc(36): Including file 'amforth-6.5\common\words/not-equal.asm'
amforth-6.5\avr8\dict/nrww.inc(37): Including file 'amforth-6.5\avr8\words/equalzero.asm'
amforth-6.5\avr8\dict/nrww.inc(38): Including file 'amforth-6.5\avr8\words/lesszero.asm'
amforth-6.5\avr8\dict/nrww.inc(39): Including file 'amforth-6.5\avr8\words/greaterzero.asm'
amforth-6.5\avr8\dict/nrww.inc(40): Including file 'amforth-6.5\avr8\words/d-greaterzero.asm'
amforth-6.5\avr8\dict/nrww.inc(41): Including file 'amforth-6.5\avr8\words/d-lesszero.asm'
amforth-6.5\avr8\dict/nrww.inc(43): Including file 'amforth-6.5\avr8\words/true.asm'
amforth-6.5\avr8\dict/nrww.inc(44): Including file 'amforth-6.5\avr8\words/zero.asm'
amforth-6.5\avr8\dict/nrww.inc(45): Including file 'amforth-6.5\avr8\words/uless.asm'
amforth-6.5\avr8\dict/nrww.inc(46): Including file 'amforth-6.5\common\words/u-greater.asm'
amforth-6.5\avr8\dict/nrww.inc(47): Including file 'amforth-6.5\avr8\words/less.asm'
amforth-6.5\avr8\dict/nrww.inc(48): Including file 'amforth-6.5\avr8\words/greater.asm'
amforth-6.5\avr8\dict/nrww.inc(50): Including file 'amforth-6.5\avr8\words/log2.asm'
amforth-6.5\avr8\dict/nrww.inc(51): Including file 'amforth-6.5\avr8\words/minus.asm'
amforth-6.5\avr8\dict/nrww.inc(52): Including file 'amforth-6.5\avr8\words/plus.asm'
amforth-6.5\avr8\dict/nrww.inc(53): Including file 'amforth-6.5\avr8\words/mstar.asm'
amforth-6.5\avr8\dict/nrww.inc(54): Including file 'amforth-6.5\avr8\words/umslashmod.asm'
amforth-6.5\avr8\dict/nrww.inc(55): Including file 'amforth-6.5\avr8\words/umstar.asm'
amforth-6.5\avr8\dict/nrww.inc(57): Including file 'amforth-6.5\avr8\words/invert.asm'
amforth-6.5\avr8\dict/nrww.inc(58): Including file 'amforth-6.5\avr8\words/2slash.asm'
amforth-6.5\avr8\dict/nrww.inc(59): Including file 'amforth-6.5\avr8\words/2star.asm'
amforth-6.5\avr8\dict/nrww.inc(60): Including file 'amforth-6.5\avr8\words/and.asm'
amforth-6.5\avr8\dict/nrww.inc(61): Including file 'amforth-6.5\avr8\words/or.asm'
amforth-6.5\avr8\dict/nrww.inc(62): Including file 'amforth-6.5\avr8\words/xor.asm'
amforth-6.5\avr8\dict/nrww.inc(64): Including file 'amforth-6.5\avr8\words/1plus.asm'
amforth-6.5\avr8\dict/nrww.inc(65): Including file 'amforth-6.5\avr8\words/1minus.asm'
amforth-6.5\avr8\dict/nrww.inc(66): Including file 'amforth-6.5\common\words/q-negate.asm'
amforth-6.5\avr8\dict/nrww.inc(67): Including file 'amforth-6.5\avr8\words/lshift.asm'
amforth-6.5\avr8\dict/nrww.inc(68): Including file 'amforth-6.5\avr8\words/rshift.asm'
amforth-6.5\avr8\dict/nrww.inc(69): Including file 'amforth-6.5\avr8\words/plusstore.asm'
amforth-6.5\avr8\dict/nrww.inc(71): Including file 'amforth-6.5\avr8\words/rpfetch.asm'
amforth-6.5\avr8\dict/nrww.inc(72): Including file 'amforth-6.5\avr8\words/rpstore.asm'
amforth-6.5\avr8\dict/nrww.inc(73): Including file 'amforth-6.5\avr8\words/spfetch.asm'
amforth-6.5\avr8\dict/nrww.inc(74): Including file 'amforth-6.5\avr8\words/spstore.asm'
amforth-6.5\avr8\dict/nrww.inc(76): Including file 'amforth-6.5\avr8\words/dodo.asm'
amforth-6.5\avr8\dict/nrww.inc(77): Including file 'amforth-6.5\avr8\words/i.asm'
amforth-6.5\avr8\dict/nrww.inc(78): Including file 'amforth-6.5\avr8\words/doplusloop.asm'
amforth-6.5\avr8\dict/nrww.inc(79): Including file 'amforth-6.5\avr8\words/doloop.asm'
amforth-6.5\avr8\dict/nrww.inc(80): Including file 'amforth-6.5\avr8\words/unloop.asm'
amforth-6.5\avr8\dict/nrww.inc(84): Including file 'amforth-6.5\avr8\words/cmove_g.asm'
amforth-6.5\avr8\dict/nrww.inc(85): Including file 'amforth-6.5\avr8\words/byteswap.asm'
amforth-6.5\avr8\dict/nrww.inc(86): Including file 'amforth-6.5\avr8\words/up.asm'
amforth-6.5\avr8\dict/nrww.inc(87): Including file 'amforth-6.5\avr8\words/1ms.asm'
amforth-6.5\avr8\dict/nrww.inc(88): Including file 'amforth-6.5\avr8\words/2to_r.asm'
amforth-6.5\avr8\dict/nrww.inc(89): Including file 'amforth-6.5\avr8\words/2r_from.asm'
amforth-6.5\avr8\dict/nrww.inc(91): Including file 'amforth-6.5\avr8\words/store-e.asm'
amforth-6.5\avr8\dict/nrww.inc(92): Including file 'amforth-6.5\avr8\words/fetch-e.asm'
amforth-6.5\avr8\dict/nrww.inc(93): Including file 'amforth-6.5\avr8\words/store-i.asm'
amforth-6.5\avr8\dict/nrww.inc(97): Including file 'amforth-6.5\avr8\words/store-i_nrww.asm'
amforth-6.5\avr8\dict/nrww.inc(99): Including file 'amforth-6.5\avr8\words/fetch-i.asm'
amforth-6.5\avr8\dict/nrww.inc(104): Including file 'amforth-6.5\avr8\dict/core_4k.inc'
amforth-6.5\avr8\dict/core_4k.inc(3): Including file 'amforth-6.5\avr8\words/n_to_r.asm'
amforth-6.5\avr8\dict/core_4k.inc(4): Including file 'amforth-6.5\avr8\words/n_r_from.asm'
amforth-6.5\avr8\dict/core_4k.inc(5): Including file 'amforth-6.5\avr8\words/d-2star.asm'
amforth-6.5\avr8\dict/core_4k.inc(6): Including file 'amforth-6.5\avr8\words/d-2slash.asm'
amforth-6.5\avr8\dict/core_4k.inc(7): Including file 'amforth-6.5\avr8\words/d-plus.asm'
amforth-6.5\avr8\dict/core_4k.inc(8): Including file 'amforth-6.5\avr8\words/d-minus.asm'
amforth-6.5\avr8\dict/core_4k.inc(9): Including file 'amforth-6.5\avr8\words/d-invert.asm'
amforth-6.5\avr8\dict/core_4k.inc(10): Including file 'amforth-6.5\avr8\words/slashmod.asm'
amforth-6.5\avr8\dict/core_4k.inc(11): Including file 'amforth-6.5\common\words/abs.asm'
amforth-6.5\avr8\dict/core_4k.inc(12): Including file 'amforth-6.5\common\words/pick.asm'
amforth-6.5\avr8\dict/core_4k.inc(13): Including file 'amforth-6.5\avr8\words/cellplus.asm'
amforth-6.5\avr8\dict/core_4k.inc(14): Including file 'amforth-6.5\avr8\dict/interrupt.inc'
amforth-6.5\avr8\dict/interrupt.inc(8): Including file 'amforth-6.5\avr8\words/int-on.asm'
amforth-6.5\avr8\dict/interrupt.inc(9): Including file 'amforth-6.5\avr8\words/int-off.asm'
amforth-6.5\avr8\dict/interrupt.inc(10): Including file 'amforth-6.5\avr8\words/int-store.asm'
amforth-6.5\avr8\dict/interrupt.inc(11): Including file 'amforth-6.5\avr8\words/int-fetch.asm'
amforth-6.5\avr8\dict/interrupt.inc(12): Including file 'amforth-6.5\avr8\words/int-trap.asm'
amforth-6.5\avr8\dict/interrupt.inc(14): Including file 'amforth-6.5\avr8\words/isr-exec.asm'
amforth-6.5\avr8\dict/interrupt.inc(15): Including file 'amforth-6.5\avr8\words/isr-end.asm'
amforth-6.5\avr8\dict/core_4k.inc(17): Including file 'amforth-6.5\common\words/prompt-ok.asm'
amforth-6.5\avr8\dict/core_4k.inc(18): Including file 'amforth-6.5\common\words/prompt-ready.asm'
amforth-6.5\avr8\dict/core_4k.inc(19): Including file 'amforth-6.5\common\words/prompt-error.asm'
amforth-6.5\avr8\dict/core_4k.inc(21): Including file 'amforth-6.5\common\words/quit.asm'
amforth-6.5\avr8\dict/core_4k.inc(22): Including file 'amforth-6.5\avr8\words/pause.asm'
amforth-6.5\avr8\dict/core_4k.inc(23): Including file 'amforth-6.5\avr8\words/cold.asm'
amforth-6.5\avr8\dict/core_4k.inc(24): Including file 'amforth-6.5\common\words/warm.asm'
amforth-6.5\avr8\dict/core_4k.inc(26): Including file 'amforth-6.5\common\words/handler.asm'
amforth-6.5\avr8\dict/core_4k.inc(27): Including file 'amforth-6.5\common\words/catch.asm'
amforth-6.5\avr8\dict/core_4k.inc(28): Including file 'amforth-6.5\common\words/throw.asm'
amforth-6.5\avr8\dict/core_4k.inc(31): Including file 'amforth-6.5\avr8\words/edefer-fetch.asm'
amforth-6.5\avr8\dict/core_4k.inc(32): Including file 'amforth-6.5\avr8\words/edefer-store.asm'
amforth-6.5\avr8\dict/core_4k.inc(33): Including file 'amforth-6.5\common\words/rdefer-fetch.asm'
amforth-6.5\avr8\dict/core_4k.inc(34): Including file 'amforth-6.5\common\words/rdefer-store.asm'
amforth-6.5\avr8\dict/core_4k.inc(35): Including file 'amforth-6.5\common\words/udefer-fetch.asm'
amforth-6.5\avr8\dict/core_4k.inc(36): Including file 'amforth-6.5\common\words/udefer-store.asm'
amforth-6.5\avr8\dict/core_4k.inc(37): Including file 'amforth-6.5\common\words/defer-store.asm'
amforth-6.5\avr8\dict/core_4k.inc(38): Including file 'amforth-6.5\common\words/defer-fetch.asm'
amforth-6.5\avr8\dict/core_4k.inc(39): Including file 'amforth-6.5\avr8\words/do-defer.asm'
amforth-6.5\avr8\dict/core_4k.inc(41): Including file 'amforth-6.5\common\words/u-dot.asm'
amforth-6.5\avr8\dict/core_4k.inc(42): Including file 'amforth-6.5\common\words/u-dot-r.asm'
amforth-6.5\avr8\dict/core_4k.inc(45): Including file 'amforth-6.5\avr8\words/uslashmod.asm'
amforth-6.5\avr8\dict/core_4k.inc(46): Including file 'amforth-6.5\avr8\words/negate.asm'
amforth-6.5\avr8\dict/core_4k.inc(47): Including file 'amforth-6.5\common\words/slash.asm'
amforth-6.5\avr8\dict/core_4k.inc(48): Including file 'amforth-6.5\common\words/mod.asm'
amforth-6.5\avr8\dict/core_4k.inc(50): Including file 'amforth-6.5\common\words/min.asm'
amforth-6.5\avr8\dict/core_4k.inc(51): Including file 'amforth-6.5\common\words/max.asm'
amforth-6.5\avr8\dict/core_4k.inc(52): Including file 'amforth-6.5\common\words/within.asm'
amforth-6.5\avr8\dict/core_4k.inc(54): Including file 'amforth-6.5\common\words/show-wordlist.asm'
amforth-6.5\avr8\dict/core_4k.inc(55): Including file 'amforth-6.5\common\words/words.asm'
amforth-6.5\avr8\dict/core_4k.inc(57): Including file 'amforth-6.5\common\words/dot-quote.asm'
amforth-6.5\avr8\dict/core_4k.inc(58): Including file 'amforth-6.5\common\words/squote.asm'
amforth-6.5\avr8\dict/core_4k.inc(59): Including file 'amforth-6.5\avr8\words/fill.asm'
amforth-6.5\avr8\dict/core_4k.inc(61): Including file 'amforth-6.5\common\words/f_cpu.asm'
amforth-6.5\avr8\dict/core_4k.inc(62): Including file 'amforth-6.5\avr8\words/state.asm'
amforth-6.5\avr8\dict/core_4k.inc(63): Including file 'amforth-6.5\common\words/base.asm'
amforth-6.5\avr8\dict/core_4k.inc(65): Including file 'amforth-6.5\avr8\words/cells.asm'
amforth-6.5\avr8\dict/core_4k.inc(67): Including file 'amforth-6.5\common\words/2dup.asm'
amforth-6.5\avr8\dict/core_4k.inc(68): Including file 'amforth-6.5\common\words/2drop.asm'
amforth-6.5\avr8\dict/core_4k.inc(69): Including file 'amforth-6.5\common\words/tuck.asm'
amforth-6.5\avr8\dict/core_4k.inc(71): Including file 'amforth-6.5\common\words/to-in.asm'
amforth-6.5\avr8\dict/core_4k.inc(72): Including file 'amforth-6.5\common\words/pad.asm'
amforth-6.5\avr8\dict/core_4k.inc(73): Including file 'amforth-6.5\common\words/emit.asm'
amforth-6.5\avr8\dict/core_4k.inc(74): Including file 'amforth-6.5\common\words/emitq.asm'
amforth-6.5\avr8\dict/core_4k.inc(75): Including file 'amforth-6.5\common\words/key.asm'
amforth-6.5\avr8\dict/core_4k.inc(76): Including file 'amforth-6.5\common\words/keyq.asm'
amforth-6.5\avr8\dict/core_4k.inc(78): Including file 'amforth-6.5\avr8\words/dp.asm'
amforth-6.5\avr8\dict/core_4k.inc(79): Including file 'amforth-6.5\avr8\words/ehere.asm'
amforth-6.5\avr8\dict/core_4k.inc(80): Including file 'amforth-6.5\avr8\words/here.asm'
amforth-6.5\avr8\dict/core_4k.inc(81): Including file 'amforth-6.5\avr8\words/allot.asm'
amforth-6.5\avr8\dict/core_4k.inc(83): Including file 'amforth-6.5\common\words/bin.asm'
amforth-6.5\avr8\dict/core_4k.inc(84): Including file 'amforth-6.5\common\words/decimal.asm'
amforth-6.5\avr8\dict/core_4k.inc(85): Including file 'amforth-6.5\common\words/hex.asm'
amforth-6.5\avr8\dict/core_4k.inc(86): Including file 'amforth-6.5\common\words/bl.asm'
amforth-6.5\avr8\dict/core_4k.inc(88): Including file 'amforth-6.5\avr8\words/turnkey.asm'
amforth-6.5\avr8\dict/core_4k.inc(89): Including file 'amforth-6.5\common\words/to-upper.asm'
amforth-6.5\avr8\dict/core_4k.inc(90): Including file 'amforth-6.5\common\words/to-lower.asm'
amforth-6.5\avr8\dict/core_4k.inc(92): Including file 'amforth-6.5\common\words/q-stack.asm'
amforth-6.5\avr8\dict/core_4k.inc(93): Including file 'amforth-6.5\common\words/bounds.asm'
amforth-6.5\avr8\dict/core_4k.inc(94): Including file 'amforth-6.5\common\words/cr.asm'
amforth-6.5\avr8\dict/core_4k.inc(95): Including file 'amforth-6.5\common\words/space.asm'
amforth-6.5\avr8\dict/core_4k.inc(96): Including file 'amforth-6.5\common\words/spaces.asm'
amforth-6.5\avr8\dict/core_4k.inc(97): Including file 'amforth-6.5\common\words/s-to-d.asm'
amforth-6.5\avr8\dict/core_4k.inc(98): Including file 'amforth-6.5\avr8\words/to-body.asm'
amforth-6.5\avr8\dict/nrww.inc(112): Including file 'amforth-6.5\common\words/2literal.asm'
amforth-6.5\avr8\dict/nrww.inc(113): Including file 'amforth-6.5\avr8\words/equal.asm'
amforth-6.5\avr8\dict/nrww.inc(114): Including file 'amforth-6.5\common\words/num-constants.asm'
amforth-6.5\avr8\amforth.asm(25): Including file 'dict_appl_core.inc'
amforth-6.5\avr8\amforth.asm(36): Including file 'amforth-6.5\avr8\amforth-eeprom.inc'
uno.asm(5): Including file 'amforth-6.5\avr8\preamble.inc'
amforth-6.5\avr8\preamble.inc(2): Including file 'amforth-6.5\avr8\macros.asm'
amforth-6.5\avr8\macros.asm(6): Including file 'amforth-6.5\avr8\user.inc'
amforth-6.5\avr8\preamble.inc(6): Including file 'device.asm'
device.asm(5): Including file 'm328Pdef.inc'
uno.asm(8): Including file 'amforth-6.5\avr8\drivers/usart_0.asm'
amforth-6.5\avr8\drivers/usart_0.asm(32): Including file 'amforth-6.5\avr8\drivers/usart_common.asm'
amforth-6.5\avr8\drivers/usart_common.asm(11): Including file 'amforth-6.5\avr8\drivers/usart-rx-buffer.asm'
amforth-6.5\avr8\drivers/usart_common.asm(24): Including file 'amforth-6.5\avr8\words/usart-tx-poll.asm'
amforth-6.5\avr8\drivers/usart_common.asm(29): Including file 'amforth-6.5\avr8\words/ubrr.asm'
amforth-6.5\avr8\drivers/usart_common.asm(30): Including file 'amforth-6.5\avr8\words/usart.asm'
uno.asm(13): Including file 'amforth-6.5\avr8\drivers/1wire.asm'
uno.asm(15): Including file 'amforth-6.5\avr8\amforth.asm'
amforth-6.5\avr8\amforth.asm(12): Including file 'amforth-6.5\avr8\drivers/generic-isr.asm'
amforth-6.5\avr8\amforth.asm(14): Including file 'amforth-6.5\avr8\dict/rww.inc'
amforth-6.5\avr8\dict/rww.inc(1): Including file 'amforth-6.5\avr8\words/mplus.asm'
amforth-6.5\avr8\dict/rww.inc(2): Including file 'amforth-6.5\common\words/ud-star.asm'
amforth-6.5\avr8\dict/rww.inc(3): Including file 'amforth-6.5\common\words/umax.asm'
amforth-6.5\avr8\dict/rww.inc(4): Including file 'amforth-6.5\common\words/umin.asm'
amforth-6.5\avr8\dict/rww.inc(5): Including file 'amforth-6.5\avr8\words/immediate-q.asm'
amforth-6.5\avr8\dict/rww.inc(6): Including file 'amforth-6.5\avr8\words/name2flags.asm'
amforth-6.5\avr8\dict/rww.inc(11): Including file 'amforth-6.5\avr8\dict/appl_4k.inc'
amforth-6.5\avr8\dict/appl_4k.inc(1): Including file 'amforth-6.5\common\words/ver.asm'
amforth-6.5\avr8\dict/appl_4k.inc(4): Including file 'amforth-6.5\common\words/noop.asm'
amforth-6.5\avr8\dict/appl_4k.inc(5): Including file 'amforth-6.5\avr8\words/unused.asm'
amforth-6.5\avr8\dict/appl_4k.inc(6): Including file 'amforth-6.5\common\words/to.asm'
amforth-6.5\avr8\dict/appl_4k.inc(7): Including file 'amforth-6.5\avr8\words/i-cellplus.asm'
amforth-6.5\avr8\dict/appl_4k.inc(8): Including file 'amforth-6.5\avr8\words/icompare.asm'
amforth-6.5\avr8\dict/appl_4k.inc(9): Including file 'amforth-6.5\common\words/star.asm'
amforth-6.5\avr8\dict/appl_4k.inc(10): Including file 'amforth-6.5\avr8\words/j.asm'
amforth-6.5\avr8\dict/appl_4k.inc(11): Including file 'amforth-6.5\avr8\words/dabs.asm'
amforth-6.5\avr8\dict/appl_4k.inc(12): Including file 'amforth-6.5\avr8\words/dnegate.asm'
amforth-6.5\avr8\dict/appl_4k.inc(13): Including file 'amforth-6.5\avr8\words/cmove.asm'
amforth-6.5\avr8\dict/appl_4k.inc(14): Including file 'amforth-6.5\common\words/2swap.asm'
amforth-6.5\avr8\dict/appl_4k.inc(15): Including file 'amforth-6.5\common\words/tib.asm'
amforth-6.5\avr8\dict/appl_4k.inc(16): Including file 'amforth-6.5\avr8\words/init-ram.asm'
amforth-6.5\avr8\dict/appl_4k.inc(20): Including file 'amforth-6.5\avr8\words/environment.asm'
amforth-6.5\avr8\dict/appl_4k.inc(21): Including file 'amforth-6.5\avr8\words/env-wordlists.asm'
amforth-6.5\avr8\dict/appl_4k.inc(22): Including file 'amforth-6.5\avr8\words/env-slashpad.asm'
amforth-6.5\avr8\dict/appl_4k.inc(23): Including file 'amforth-6.5\common\words/env-slashhold.asm'
amforth-6.5\avr8\dict/appl_4k.inc(24): Including file 'amforth-6.5\common\words/env-forthname.asm'
amforth-6.5\avr8\dict/appl_4k.inc(25): Including file 'amforth-6.5\common\words/env-forthversion.asm'
amforth-6.5\avr8\dict/appl_4k.inc(26): Including file 'amforth-6.5\common\words/env-cpu.asm'
amforth-6.5\avr8\dict/appl_4k.inc(27): Including file 'amforth-6.5\avr8\words/env-mcuinfo.asm'
amforth-6.5\avr8\dict/appl_4k.inc(28): Including file 'amforth-6.5\common\words/env-usersize.asm'
amforth-6.5\avr8\dict/appl_4k.inc(30): Including file 'amforth-6.5\avr8\words/hld.asm'
amforth-6.5\avr8\dict/appl_4k.inc(31): Including file 'amforth-6.5\common\words/hold.asm'
amforth-6.5\avr8\dict/appl_4k.inc(32): Including file 'amforth-6.5\common\words/less-sharp.asm'
amforth-6.5\avr8\dict/appl_4k.inc(33): Including file 'amforth-6.5\common\words/sharp.asm'
amforth-6.5\avr8\dict/appl_4k.inc(34): Including file 'amforth-6.5\common\words/sharp-s.asm'
amforth-6.5\avr8\dict/appl_4k.inc(35): Including file 'amforth-6.5\common\words/sharp-greater.asm'
amforth-6.5\avr8\dict/appl_4k.inc(36): Including file 'amforth-6.5\common\words/sign.asm'
amforth-6.5\avr8\dict/appl_4k.inc(37): Including file 'amforth-6.5\common\words/d-dot-r.asm'
amforth-6.5\avr8\dict/appl_4k.inc(38): Including file 'amforth-6.5\common\words/dot-r.asm'
amforth-6.5\avr8\dict/appl_4k.inc(39): Including file 'amforth-6.5\common\words/d-dot.asm'
amforth-6.5\avr8\dict/appl_4k.inc(40): Including file 'amforth-6.5\common\words/dot.asm'
amforth-6.5\avr8\dict/appl_4k.inc(41): Including file 'amforth-6.5\common\words/ud-dot.asm'
amforth-6.5\avr8\dict/appl_4k.inc(42): Including file 'amforth-6.5\common\words/ud-dot-r.asm'
amforth-6.5\avr8\dict/appl_4k.inc(43): Including file 'amforth-6.5\common\words/ud-slash-mod.asm'
amforth-6.5\avr8\dict/appl_4k.inc(44): Including file 'amforth-6.5\common\words/digit-q.asm'
amforth-6.5\avr8\dict/appl_4k.inc(46): Including file 'amforth-6.5\avr8\words/do-sliteral.asm'
amforth-6.5\avr8\dict/appl_4k.inc(47): Including file 'amforth-6.5\avr8\words/scomma.asm'
amforth-6.5\avr8\dict/appl_4k.inc(48): Including file 'amforth-6.5\avr8\words/itype.asm'
amforth-6.5\avr8\dict/appl_4k.inc(49): Including file 'amforth-6.5\avr8\words/icount.asm'
amforth-6.5\avr8\dict/appl_4k.inc(50): Including file 'amforth-6.5\common\words/type.asm'
amforth-6.5\avr8\dict/appl_4k.inc(51): Including file 'amforth-6.5\common\words/tick.asm'
amforth-6.5\avr8\dict/appl_4k.inc(53): Including file 'amforth-6.5\common\words/cskip.asm'
amforth-6.5\avr8\dict/appl_4k.inc(54): Including file 'amforth-6.5\common\words/cscan.asm'
amforth-6.5\avr8\dict/appl_4k.inc(55): Including file 'amforth-6.5\common\words/accept.asm'
amforth-6.5\avr8\dict/appl_4k.inc(56): Including file 'amforth-6.5\common\words/refill.asm'
amforth-6.5\avr8\dict/appl_4k.inc(57): Including file 'amforth-6.5\common\words/char.asm'
amforth-6.5\avr8\dict/appl_4k.inc(58): Including file 'amforth-6.5\common\words/number.asm'
amforth-6.5\avr8\dict/appl_4k.inc(59): Including file 'amforth-6.5\common\words/q-sign.asm'
amforth-6.5\avr8\dict/appl_4k.inc(60): Including file 'amforth-6.5\common\words/set-base.asm'
amforth-6.5\avr8\dict/appl_4k.inc(61): Including file 'amforth-6.5\common\words/to-number.asm'
amforth-6.5\avr8\dict/appl_4k.inc(62): Including file 'amforth-6.5\common\words/parse.asm'
amforth-6.5\avr8\dict/appl_4k.inc(63): Including file 'amforth-6.5\common\words/source.asm'
amforth-6.5\avr8\dict/appl_4k.inc(64): Including file 'amforth-6.5\common\words/slash-string.asm'
amforth-6.5\avr8\dict/appl_4k.inc(65): Including file 'amforth-6.5\common\words/parse-name.asm'
amforth-6.5\avr8\dict/appl_4k.inc(66): Including file 'amforth-6.5\avr8\words/sp0.asm'
amforth-6.5\avr8\dict/appl_4k.inc(67): Including file 'amforth-6.5\avr8\words/rp0.asm'
amforth-6.5\avr8\dict/appl_4k.inc(68): Including file 'amforth-6.5\common\words/depth.asm'
amforth-6.5\avr8\dict/appl_4k.inc(69): Including file 'amforth-6.5\avr8\words/forth-recognizer.asm'
amforth-6.5\avr8\dict/appl_4k.inc(70): Including file 'amforth-6.5\common\words/recognize.asm'
amforth-6.5\avr8\dict/appl_4k.inc(71): Including file 'amforth-6.5\common\words/interpret.asm'
amforth-6.5\avr8\dict/appl_4k.inc(72): Including file 'amforth-6.5\common\words/rec-intnum.asm'
amforth-6.5\avr8\dict/appl_4k.inc(73): Including file 'amforth-6.5\common\words/rec-find.asm'
amforth-6.5\avr8\dict/appl_4k.inc(74): Including file 'amforth-6.5\common\words/dt-null.asm'
amforth-6.5\avr8\dict/appl_4k.inc(75): Including file 'amforth-6.5\common\words/search-wordlist.asm'
amforth-6.5\avr8\dict/appl_4k.inc(76): Including file 'amforth-6.5\common\words/traverse-wordlist.asm'
amforth-6.5\avr8\dict/appl_4k.inc(77): Including file 'amforth-6.5\common\words/name2string.asm'
amforth-6.5\avr8\dict/appl_4k.inc(78): Including file 'amforth-6.5\avr8\words/nfa2cfa.asm'
amforth-6.5\avr8\dict/appl_4k.inc(79): Including file 'amforth-6.5\common\words/find-xt.asm'
amforth-6.5\avr8\dict/appl_4k.inc(81): Including file 'amforth-6.5\avr8\dict/compiler1.inc'
amforth-6.5\avr8\dict/compiler1.inc(2): Including file 'amforth-6.5\avr8\words/newest.asm'
amforth-6.5\avr8\dict/compiler1.inc(3): Including file 'amforth-6.5\avr8\words/latest.asm'
amforth-6.5\avr8\dict/compiler1.inc(4): Including file 'amforth-6.5\common\words/do-create.asm'
amforth-6.5\avr8\dict/compiler1.inc(5): Including file 'amforth-6.5\common\words/backslash.asm'
amforth-6.5\avr8\dict/compiler1.inc(6): Including file 'amforth-6.5\common\words/l-paren.asm'
amforth-6.5\avr8\dict/compiler1.inc(8): Including file 'amforth-6.5\common\words/compile.asm'
amforth-6.5\avr8\dict/compiler1.inc(9): Including file 'amforth-6.5\avr8\words/comma.asm'
amforth-6.5\avr8\dict/compiler1.inc(10): Including file 'amforth-6.5\common\words/brackettick.asm'
amforth-6.5\avr8\dict/compiler1.inc(13): Including file 'amforth-6.5\common\words/literal.asm'
amforth-6.5\avr8\dict/compiler1.inc(14): Including file 'amforth-6.5\common\words/sliteral.asm'
amforth-6.5\avr8\dict/compiler1.inc(15): Including file 'amforth-6.5\avr8\words/g-mark.asm'
amforth-6.5\avr8\dict/compiler1.inc(16): Including file 'amforth-6.5\avr8\words/g-resolve.asm'
amforth-6.5\avr8\dict/compiler1.inc(17): Including file 'amforth-6.5\avr8\words/l_mark.asm'
amforth-6.5\avr8\dict/compiler1.inc(18): Including file 'amforth-6.5\avr8\words/l_resolve.asm'
amforth-6.5\avr8\dict/compiler1.inc(20): Including file 'amforth-6.5\common\words/ahead.asm'
amforth-6.5\avr8\dict/compiler1.inc(21): Including file 'amforth-6.5\common\words/if.asm'
amforth-6.5\avr8\dict/compiler1.inc(22): Including file 'amforth-6.5\common\words/else.asm'
amforth-6.5\avr8\dict/compiler1.inc(23): Including file 'amforth-6.5\common\words/then.asm'
amforth-6.5\avr8\dict/compiler1.inc(24): Including file 'amforth-6.5\common\words/begin.asm'
amforth-6.5\avr8\dict/compiler1.inc(25): Including file 'amforth-6.5\common\words/while.asm'
amforth-6.5\avr8\dict/compiler1.inc(26): Including file 'amforth-6.5\common\words/repeat.asm'
amforth-6.5\avr8\dict/compiler1.inc(27): Including file 'amforth-6.5\common\words/until.asm'
amforth-6.5\avr8\dict/compiler1.inc(28): Including file 'amforth-6.5\common\words/again.asm'
amforth-6.5\avr8\dict/compiler1.inc(29): Including file 'amforth-6.5\common\words/do.asm'
amforth-6.5\avr8\dict/compiler1.inc(30): Including file 'amforth-6.5\common\words/loop.asm'
amforth-6.5\avr8\dict/compiler1.inc(31): Including file 'amforth-6.5\common\words/plusloop.asm'
amforth-6.5\avr8\dict/compiler1.inc(32): Including file 'amforth-6.5\common\words/leave.asm'
amforth-6.5\avr8\dict/compiler1.inc(33): Including file 'amforth-6.5\common\words/qdo.asm'
amforth-6.5\avr8\dict/compiler1.inc(34): Including file 'amforth-6.5\common\words/endloop.asm'
amforth-6.5\avr8\dict/compiler1.inc(36): Including file 'amforth-6.5\common\words/l-from.asm'
amforth-6.5\avr8\dict/compiler1.inc(37): Including file 'amforth-6.5\common\words/to-l.asm'
amforth-6.5\avr8\dict/compiler1.inc(38): Including file 'amforth-6.5\avr8\words/lp0.asm'
amforth-6.5\avr8\dict/compiler1.inc(39): Including file 'amforth-6.5\avr8\words/lp.asm'
amforth-6.5\avr8\dict/compiler1.inc(41): Including file 'amforth-6.5\common\words/create.asm'
amforth-6.5\avr8\dict/compiler1.inc(42): Including file 'amforth-6.5\avr8\words/header.asm'
amforth-6.5\avr8\dict/compiler1.inc(43): Including file 'amforth-6.5\avr8\words/wlscope.asm'
amforth-6.5\avr8\dict/compiler1.inc(44): Including file 'amforth-6.5\common\words/reveal.asm'
amforth-6.5\avr8\dict/compiler1.inc(45): Including file 'amforth-6.5\avr8\words/does.asm'
amforth-6.5\avr8\dict/compiler1.inc(46): Including file 'amforth-6.5\common\words/colon.asm'
amforth-6.5\avr8\dict/compiler1.inc(47): Including file 'amforth-6.5\avr8\words/colon-noname.asm'
amforth-6.5\avr8\dict/compiler1.inc(48): Including file 'amforth-6.5\common\words/semicolon.asm'
amforth-6.5\avr8\dict/compiler1.inc(49): Including file 'amforth-6.5\common\words/right-bracket.asm'
amforth-6.5\avr8\dict/compiler1.inc(50): Including file 'amforth-6.5\common\words/left-bracket.asm'
amforth-6.5\avr8\dict/compiler1.inc(51): Including file 'amforth-6.5\common\words/variable.asm'
amforth-6.5\avr8\dict/compiler1.inc(52): Including file 'amforth-6.5\common\words/constant.asm'
amforth-6.5\avr8\dict/compiler1.inc(53): Including file 'amforth-6.5\avr8\words/user.asm'
amforth-6.5\avr8\dict/compiler1.inc(55): Including file 'amforth-6.5\common\words/recurse.asm'
amforth-6.5\avr8\dict/compiler1.inc(56): Including file 'amforth-6.5\avr8\words/immediate.asm'
amforth-6.5\avr8\dict/compiler1.inc(58): Including file 'amforth-6.5\common\words/bracketchar.asm'
amforth-6.5\avr8\dict/compiler1.inc(59): Including file 'amforth-6.5\common\words/abort-string.asm'
amforth-6.5\avr8\dict/compiler1.inc(60): Including file 'amforth-6.5\common\words/abort.asm'
amforth-6.5\avr8\dict/compiler1.inc(61): Including file 'amforth-6.5\common\words/q-abort.asm'
amforth-6.5\avr8\dict/compiler1.inc(63): Including file 'amforth-6.5\common\words/get-stack.asm'
amforth-6.5\avr8\dict/compiler1.inc(64): Including file 'amforth-6.5\common\words/set-stack.asm'
amforth-6.5\avr8\dict/compiler1.inc(65): Including file 'amforth-6.5\common\words/map-stack.asm'
amforth-6.5\avr8\dict/compiler1.inc(66): Including file 'amforth-6.5\avr8\words/get-current.asm'
amforth-6.5\avr8\dict/compiler1.inc(67): Including file 'amforth-6.5\common\words/get-order.asm'
amforth-6.5\avr8\dict/compiler1.inc(68): Including file 'amforth-6.5\common\words/cfg-order.asm'
amforth-6.5\avr8\dict/compiler1.inc(69): Including file 'amforth-6.5\avr8\words/compare.asm'
amforth-6.5\avr8\dict/compiler1.inc(70): Including file 'amforth-6.5\avr8\words/nfa2lfa.asm'
amforth-6.5\avr8\amforth.asm(15): Including file 'dict_appl.inc'
dict_appl.inc(4): Including file 'amforth-6.5\avr8\dict/compiler2.inc'
amforth-6.5\avr8\dict/compiler2.inc(8): Including file 'amforth-6.5\avr8\words/set-current.asm'
amforth-6.5\avr8\dict/compiler2.inc(9): Including file 'amforth-6.5\avr8\words/wordlist.asm'
amforth-6.5\avr8\dict/compiler2.inc(11): Including file 'amforth-6.5\avr8\words/forth-wordlist.asm'
amforth-6.5\avr8\dict/compiler2.inc(12): Including file 'amforth-6.5\common\words/set-order.asm'
amforth-6.5\avr8\dict/compiler2.inc(13): Including file 'amforth-6.5\common\words/set-recognizer.asm'
amforth-6.5\avr8\dict/compiler2.inc(14): Including file 'amforth-6.5\common\words/get-recognizer.asm'
amforth-6.5\avr8\dict/compiler2.inc(15): Including file 'amforth-6.5\avr8\words/code.asm'
amforth-6.5\avr8\dict/compiler2.inc(16): Including file 'amforth-6.5\avr8\words/end-code.asm'
amforth-6.5\avr8\dict/compiler2.inc(17): Including file 'amforth-6.5\avr8\words/marker.asm'
amforth-6.5\avr8\dict/compiler2.inc(18): Including file 'amforth-6.5\common\words/postpone.asm'
dict_appl.inc(6): Including file 'words/applturnkey.asm'
amforth-6.5\avr8\amforth.asm(23): Including file 'amforth-6.5\avr8\amforth-interpreter.asm'
amforth-6.5\avr8\amforth.asm(24): Including file 'amforth-6.5\avr8\dict/nrww.inc'
amforth-6.5\avr8\dict/nrww.inc(4): Including file 'amforth-6.5\avr8\words/exit.asm'
amforth-6.5\avr8\dict/nrww.inc(5): Including file 'amforth-6.5\avr8\words/execute.asm'
amforth-6.5\avr8\dict/nrww.inc(6): Including file 'amforth-6.5\avr8\words/dobranch.asm'
amforth-6.5\avr8\dict/nrww.inc(7): Including file 'amforth-6.5\avr8\words/docondbranch.asm'
amforth-6.5\avr8\dict/nrww.inc(10): Including file 'amforth-6.5\avr8\words/doliteral.asm'
amforth-6.5\avr8\dict/nrww.inc(11): Including file 'amforth-6.5\avr8\words/dovariable.asm'
amforth-6.5\avr8\dict/nrww.inc(12): Including file 'amforth-6.5\avr8\words/doconstant.asm'
amforth-6.5\avr8\dict/nrww.inc(13): Including file 'amforth-6.5\avr8\words/douser.asm'
amforth-6.5\avr8\dict/nrww.inc(14): Including file 'amforth-6.5\avr8\words/do-value.asm'
amforth-6.5\avr8\dict/nrww.inc(15): Including file 'amforth-6.5\avr8\words/fetch.asm'
amforth-6.5\avr8\dict/nrww.inc(16): Including file 'amforth-6.5\avr8\words/store.asm'
amforth-6.5\avr8\dict/nrww.inc(17): Including file 'amforth-6.5\avr8\words/cstore.asm'
amforth-6.5\avr8\dict/nrww.inc(18): Including file 'amforth-6.5\avr8\words/cfetch.asm'
amforth-6.5\avr8\dict/nrww.inc(19): Including file 'amforth-6.5\avr8\words/fetch-u.asm'
amforth-6.5\avr8\dict/nrww.inc(20): Including file 'amforth-6.5\avr8\words/store-u.asm'
amforth-6.5\avr8\dict/nrww.inc(23): Including file 'amforth-6.5\avr8\words/dup.asm'
amforth-6.5\avr8\dict/nrww.inc(24): Including file 'amforth-6.5\avr8\words/qdup.asm'
amforth-6.5\avr8\dict/nrww.inc(25): Including file 'amforth-6.5\avr8\words/swap.asm'
amforth-6.5\avr8\dict/nrww.inc(26): Including file 'amforth-6.5\avr8\words/over.asm'
amforth-6.5\avr8\dict/nrww.inc(27): Including file 'amforth-6.5\avr8\words/drop.asm'
amforth-6.5\avr8\dict/nrww.inc(28): Including file 'amforth-6.5\avr8\words/rot.asm'
amforth-6.5\avr8\dict/nrww.inc(29): Including file 'amforth-6.5\avr8\words/nip.asm'
amforth-6.5\avr8\dict/nrww.inc(31): Including file 'amforth-6.5\avr8\words/r_from.asm'
amforth-6.5\avr8\dict/nrww.inc(32): Including file 'amforth-6.5\avr8\words/to_r.asm'
amforth-6.5\avr8\dict/nrww.inc(33): Including file 'amforth-6.5\avr8\words/r_fetch.asm'
amforth-6.5\avr8\dict/nrww.inc(36): Including file 'amforth-6.5\common\words/not-equal.asm'
amforth-6.5\avr8\dict/nrww.inc(37): Including file 'amforth-6.5\avr8\words/equalzero.asm'
amforth-6.5\avr8\dict/nrww.inc(38): Including file 'amforth-6.5\avr8\words/lesszero.asm'
amforth-6.5\avr8\dict/nrww.inc(39): Including file 'amforth-6.5\avr8\words/greaterzero.asm'
amforth-6.5\avr8\dict/nrww.inc(40): Including file 'amforth-6.5\avr8\words/d-greaterzero.asm'
amforth-6.5\avr8\dict/nrww.inc(41): Including file 'amforth-6.5\avr8\words/d-lesszero.asm'
amforth-6.5\avr8\dict/nrww.inc(43): Including file 'amforth-6.5\avr8\words/true.asm'
amforth-6.5\avr8\dict/nrww.inc(44): Including file 'amforth-6.5\avr8\words/zero.asm'
amforth-6.5\avr8\dict/nrww.inc(45): Including file 'amforth-6.5\avr8\words/uless.asm'
amforth-6.5\avr8\dict/nrww.inc(46): Including file 'amforth-6.5\common\words/u-greater.asm'
amforth-6.5\avr8\dict/nrww.inc(47): Including file 'amforth-6.5\avr8\words/less.asm'
amforth-6.5\avr8\dict/nrww.inc(48): Including file 'amforth-6.5\avr8\words/greater.asm'
amforth-6.5\avr8\dict/nrww.inc(50): Including file 'amforth-6.5\avr8\words/log2.asm'
amforth-6.5\avr8\dict/nrww.inc(51): Including file 'amforth-6.5\avr8\words/minus.asm'
amforth-6.5\avr8\dict/nrww.inc(52): Including file 'amforth-6.5\avr8\words/plus.asm'
amforth-6.5\avr8\dict/nrww.inc(53): Including file 'amforth-6.5\avr8\words/mstar.asm'
amforth-6.5\avr8\dict/nrww.inc(54): Including file 'amforth-6.5\avr8\words/umslashmod.asm'
amforth-6.5\avr8\dict/nrww.inc(55): Including file 'amforth-6.5\avr8\words/umstar.asm'
amforth-6.5\avr8\dict/nrww.inc(57): Including file 'amforth-6.5\avr8\words/invert.asm'
amforth-6.5\avr8\dict/nrww.inc(58): Including file 'amforth-6.5\avr8\words/2slash.asm'
amforth-6.5\avr8\dict/nrww.inc(59): Including file 'amforth-6.5\avr8\words/2star.asm'
amforth-6.5\avr8\dict/nrww.inc(60): Including file 'amforth-6.5\avr8\words/and.asm'
amforth-6.5\avr8\dict/nrww.inc(61): Including file 'amforth-6.5\avr8\words/or.asm'
amforth-6.5\avr8\dict/nrww.inc(62): Including file 'amforth-6.5\avr8\words/xor.asm'
amforth-6.5\avr8\dict/nrww.inc(64): Including file 'amforth-6.5\avr8\words/1plus.asm'
amforth-6.5\avr8\dict/nrww.inc(65): Including file 'amforth-6.5\avr8\words/1minus.asm'
amforth-6.5\avr8\dict/nrww.inc(66): Including file 'amforth-6.5\common\words/q-negate.asm'
amforth-6.5\avr8\dict/nrww.inc(67): Including file 'amforth-6.5\avr8\words/lshift.asm'
amforth-6.5\avr8\dict/nrww.inc(68): Including file 'amforth-6.5\avr8\words/rshift.asm'
amforth-6.5\avr8\dict/nrww.inc(69): Including file 'amforth-6.5\avr8\words/plusstore.asm'
amforth-6.5\avr8\dict/nrww.inc(71): Including file 'amforth-6.5\avr8\words/rpfetch.asm'
amforth-6.5\avr8\dict/nrww.inc(72): Including file 'amforth-6.5\avr8\words/rpstore.asm'
amforth-6.5\avr8\dict/nrww.inc(73): Including file 'amforth-6.5\avr8\words/spfetch.asm'
amforth-6.5\avr8\dict/nrww.inc(74): Including file 'amforth-6.5\avr8\words/spstore.asm'
amforth-6.5\avr8\dict/nrww.inc(76): Including file 'amforth-6.5\avr8\words/dodo.asm'
amforth-6.5\avr8\dict/nrww.inc(77): Including file 'amforth-6.5\avr8\words/i.asm'
amforth-6.5\avr8\dict/nrww.inc(78): Including file 'amforth-6.5\avr8\words/doplusloop.asm'
amforth-6.5\avr8\dict/nrww.inc(79): Including file 'amforth-6.5\avr8\words/doloop.asm'
amforth-6.5\avr8\dict/nrww.inc(80): Including file 'amforth-6.5\avr8\words/unloop.asm'
amforth-6.5\avr8\dict/nrww.inc(84): Including file 'amforth-6.5\avr8\words/cmove_g.asm'
amforth-6.5\avr8\dict/nrww.inc(85): Including file 'amforth-6.5\avr8\words/byteswap.asm'
amforth-6.5\avr8\dict/nrww.inc(86): Including file 'amforth-6.5\avr8\words/up.asm'
amforth-6.5\avr8\dict/nrww.inc(87): Including file 'amforth-6.5\avr8\words/1ms.asm'
amforth-6.5\avr8\dict/nrww.inc(88): Including file 'amforth-6.5\avr8\words/2to_r.asm'
amforth-6.5\avr8\dict/nrww.inc(89): Including file 'amforth-6.5\avr8\words/2r_from.asm'
amforth-6.5\avr8\dict/nrww.inc(91): Including file 'amforth-6.5\avr8\words/store-e.asm'
amforth-6.5\avr8\dict/nrww.inc(92): Including file 'amforth-6.5\avr8\words/fetch-e.asm'
amforth-6.5\avr8\dict/nrww.inc(93): Including file 'amforth-6.5\avr8\words/store-i.asm'
amforth-6.5\avr8\dict/nrww.inc(97): Including file 'amforth-6.5\avr8\words/store-i_nrww.asm'
amforth-6.5\avr8\dict/nrww.inc(99): Including file 'amforth-6.5\avr8\words/fetch-i.asm'
amforth-6.5\avr8\dict/nrww.inc(104): Including file 'amforth-6.5\avr8\dict/core_4k.inc'
amforth-6.5\avr8\dict/core_4k.inc(3): Including file 'amforth-6.5\avr8\words/n_to_r.asm'
amforth-6.5\avr8\dict/core_4k.inc(4): Including file 'amforth-6.5\avr8\words/n_r_from.asm'
amforth-6.5\avr8\dict/core_4k.inc(5): Including file 'amforth-6.5\avr8\words/d-2star.asm'
amforth-6.5\avr8\dict/core_4k.inc(6): Including file 'amforth-6.5\avr8\words/d-2slash.asm'
amforth-6.5\avr8\dict/core_4k.inc(7): Including file 'amforth-6.5\avr8\words/d-plus.asm'
amforth-6.5\avr8\dict/core_4k.inc(8): Including file 'amforth-6.5\avr8\words/d-minus.asm'
amforth-6.5\avr8\dict/core_4k.inc(9): Including file 'amforth-6.5\avr8\words/d-invert.asm'
amforth-6.5\avr8\dict/core_4k.inc(10): Including file 'amforth-6.5\avr8\words/slashmod.asm'
amforth-6.5\avr8\dict/core_4k.inc(11): Including file 'amforth-6.5\common\words/abs.asm'
amforth-6.5\avr8\dict/core_4k.inc(12): Including file 'amforth-6.5\common\words/pick.asm'
amforth-6.5\avr8\dict/core_4k.inc(13): Including file 'amforth-6.5\avr8\words/cellplus.asm'
amforth-6.5\avr8\dict/core_4k.inc(14): Including file 'amforth-6.5\avr8\dict/interrupt.inc'
amforth-6.5\avr8\dict/interrupt.inc(8): Including file 'amforth-6.5\avr8\words/int-on.asm'
amforth-6.5\avr8\dict/interrupt.inc(9): Including file 'amforth-6.5\avr8\words/int-off.asm'
amforth-6.5\avr8\dict/interrupt.inc(10): Including file 'amforth-6.5\avr8\words/int-store.asm'
amforth-6.5\avr8\dict/interrupt.inc(11): Including file 'amforth-6.5\avr8\words/int-fetch.asm'
amforth-6.5\avr8\dict/interrupt.inc(12): Including file 'amforth-6.5\avr8\words/int-trap.asm'
amforth-6.5\avr8\dict/interrupt.inc(14): Including file 'amforth-6.5\avr8\words/isr-exec.asm'
amforth-6.5\avr8\dict/interrupt.inc(15): Including file 'amforth-6.5\avr8\words/isr-end.asm'
amforth-6.5\avr8\dict/core_4k.inc(17): Including file 'amforth-6.5\common\words/prompt-ok.asm'
amforth-6.5\avr8\dict/core_4k.inc(18): Including file 'amforth-6.5\common\words/prompt-ready.asm'
amforth-6.5\avr8\dict/core_4k.inc(19): Including file 'amforth-6.5\common\words/prompt-error.asm'
amforth-6.5\avr8\dict/core_4k.inc(21): Including file 'amforth-6.5\common\words/quit.asm'
amforth-6.5\avr8\dict/core_4k.inc(22): Including file 'amforth-6.5\avr8\words/pause.asm'
amforth-6.5\avr8\dict/core_4k.inc(23): Including file 'amforth-6.5\avr8\words/cold.asm'
amforth-6.5\avr8\dict/core_4k.inc(24): Including file 'amforth-6.5\common\words/warm.asm'
amforth-6.5\avr8\dict/core_4k.inc(26): Including file 'amforth-6.5\common\words/handler.asm'
amforth-6.5\avr8\dict/core_4k.inc(27): Including file 'amforth-6.5\common\words/catch.asm'
amforth-6.5\avr8\dict/core_4k.inc(28): Including file 'amforth-6.5\common\words/throw.asm'
amforth-6.5\avr8\dict/core_4k.inc(31): Including file 'amforth-6.5\avr8\words/edefer-fetch.asm'
amforth-6.5\avr8\dict/core_4k.inc(32): Including file 'amforth-6.5\avr8\words/edefer-store.asm'
amforth-6.5\avr8\dict/core_4k.inc(33): Including file 'amforth-6.5\common\words/rdefer-fetch.asm'
amforth-6.5\avr8\dict/core_4k.inc(34): Including file 'amforth-6.5\common\words/rdefer-store.asm'
amforth-6.5\avr8\dict/core_4k.inc(35): Including file 'amforth-6.5\common\words/udefer-fetch.asm'
amforth-6.5\avr8\dict/core_4k.inc(36): Including file 'amforth-6.5\common\words/udefer-store.asm'
amforth-6.5\avr8\dict/core_4k.inc(37): Including file 'amforth-6.5\common\words/defer-store.asm'
amforth-6.5\avr8\dict/core_4k.inc(38): Including file 'amforth-6.5\common\words/defer-fetch.asm'
amforth-6.5\avr8\dict/core_4k.inc(39): Including file 'amforth-6.5\avr8\words/do-defer.asm'
amforth-6.5\avr8\dict/core_4k.inc(41): Including file 'amforth-6.5\common\words/u-dot.asm'
amforth-6.5\avr8\dict/core_4k.inc(42): Including file 'amforth-6.5\common\words/u-dot-r.asm'
amforth-6.5\avr8\dict/core_4k.inc(45): Including file 'amforth-6.5\avr8\words/uslashmod.asm'
amforth-6.5\avr8\dict/core_4k.inc(46): Including file 'amforth-6.5\avr8\words/negate.asm'
amforth-6.5\avr8\dict/core_4k.inc(47): Including file 'amforth-6.5\common\words/slash.asm'
amforth-6.5\avr8\dict/core_4k.inc(48): Including file 'amforth-6.5\common\words/mod.asm'
amforth-6.5\avr8\dict/core_4k.inc(50): Including file 'amforth-6.5\common\words/min.asm'
amforth-6.5\avr8\dict/core_4k.inc(51): Including file 'amforth-6.5\common\words/max.asm'
amforth-6.5\avr8\dict/core_4k.inc(52): Including file 'amforth-6.5\common\words/within.asm'
amforth-6.5\avr8\dict/core_4k.inc(54): Including file 'amforth-6.5\common\words/show-wordlist.asm'
amforth-6.5\avr8\dict/core_4k.inc(55): Including file 'amforth-6.5\common\words/words.asm'
amforth-6.5\avr8\dict/core_4k.inc(57): Including file 'amforth-6.5\common\words/dot-quote.asm'
amforth-6.5\avr8\dict/core_4k.inc(58): Including file 'amforth-6.5\common\words/squote.asm'
amforth-6.5\avr8\dict/core_4k.inc(59): Including file 'amforth-6.5\avr8\words/fill.asm'
amforth-6.5\avr8\dict/core_4k.inc(61): Including file 'amforth-6.5\common\words/f_cpu.asm'
amforth-6.5\avr8\dict/core_4k.inc(62): Including file 'amforth-6.5\avr8\words/state.asm'
amforth-6.5\avr8\dict/core_4k.inc(63): Including file 'amforth-6.5\common\words/base.asm'
amforth-6.5\avr8\dict/core_4k.inc(65): Including file 'amforth-6.5\avr8\words/cells.asm'
amforth-6.5\avr8\dict/core_4k.inc(67): Including file 'amforth-6.5\common\words/2dup.asm'
amforth-6.5\avr8\dict/core_4k.inc(68): Including file 'amforth-6.5\common\words/2drop.asm'
amforth-6.5\avr8\dict/core_4k.inc(69): Including file 'amforth-6.5\common\words/tuck.asm'
amforth-6.5\avr8\dict/core_4k.inc(71): Including file 'amforth-6.5\common\words/to-in.asm'
amforth-6.5\avr8\dict/core_4k.inc(72): Including file 'amforth-6.5\common\words/pad.asm'
amforth-6.5\avr8\dict/core_4k.inc(73): Including file 'amforth-6.5\common\words/emit.asm'
amforth-6.5\avr8\dict/core_4k.inc(74): Including file 'amforth-6.5\common\words/emitq.asm'
amforth-6.5\avr8\dict/core_4k.inc(75): Including file 'amforth-6.5\common\words/key.asm'
amforth-6.5\avr8\dict/core_4k.inc(76): Including file 'amforth-6.5\common\words/keyq.asm'
amforth-6.5\avr8\dict/core_4k.inc(78): Including file 'amforth-6.5\avr8\words/dp.asm'
amforth-6.5\avr8\dict/core_4k.inc(79): Including file 'amforth-6.5\avr8\words/ehere.asm'
amforth-6.5\avr8\dict/core_4k.inc(80): Including file 'amforth-6.5\avr8\words/here.asm'
amforth-6.5\avr8\dict/core_4k.inc(81): Including file 'amforth-6.5\avr8\words/allot.asm'
amforth-6.5\avr8\dict/core_4k.inc(83): Including file 'amforth-6.5\common\words/bin.asm'
amforth-6.5\avr8\dict/core_4k.inc(84): Including file 'amforth-6.5\common\words/decimal.asm'
amforth-6.5\avr8\dict/core_4k.inc(85): Including file 'amforth-6.5\common\words/hex.asm'
amforth-6.5\avr8\dict/core_4k.inc(86): Including file 'amforth-6.5\common\words/bl.asm'
amforth-6.5\avr8\dict/core_4k.inc(88): Including file 'amforth-6.5\avr8\words/turnkey.asm'
amforth-6.5\avr8\dict/core_4k.inc(89): Including file 'amforth-6.5\common\words/to-upper.asm'
amforth-6.5\avr8\dict/core_4k.inc(90): Including file 'amforth-6.5\common\words/to-lower.asm'
amforth-6.5\avr8\dict/core_4k.inc(92): Including file 'amforth-6.5\common\words/q-stack.asm'
amforth-6.5\avr8\dict/core_4k.inc(93): Including file 'amforth-6.5\common\words/bounds.asm'
amforth-6.5\avr8\dict/core_4k.inc(94): Including file 'amforth-6.5\common\words/cr.asm'
amforth-6.5\avr8\dict/core_4k.inc(95): Including file 'amforth-6.5\common\words/space.asm'
amforth-6.5\avr8\dict/core_4k.inc(96): Including file 'amforth-6.5\common\words/spaces.asm'
amforth-6.5\avr8\dict/core_4k.inc(97): Including file 'amforth-6.5\common\words/s-to-d.asm'
amforth-6.5\avr8\dict/core_4k.inc(98): Including file 'amforth-6.5\avr8\words/to-body.asm'
amforth-6.5\avr8\dict/nrww.inc(112): Including file 'amforth-6.5\common\words/2literal.asm'
amforth-6.5\avr8\dict/nrww.inc(113): Including file 'amforth-6.5\avr8\words/equal.asm'
amforth-6.5\avr8\dict/nrww.inc(114): Including file 'amforth-6.5\common\words/num-constants.asm'
amforth-6.5\avr8\amforth.asm(25): Including file 'dict_appl_core.inc'
amforth-6.5\avr8\amforth.asm(36): Including file 'amforth-6.5\avr8\amforth-eeprom.inc'
                                 
                                 
                                 ; file see ../template/template.asm. You may want to
                                 ; copy that file to this one and edit it afterwards.
                                 
                                 .include "preamble.inc"
                                 
                                 .include "macros.asm"
                                 
                                 .set DICT_COMPILER2 = 0 ;
                                 .set cpu_msp430 = 0
                                 .set cpu_avr8   = 1
                                 
                                 .include "user.inc"
                                 
                                 ; 
                                 
                                 ; used by the multitasker
                                 .set USER_STATE    = 0
                                 .set USER_FOLLOWER = 2
                                 
                                 ; stackpointer, used by mulitasker
                                 .set USER_RP      = 4
                                 .set USER_SP0     = 6
                                 .set USER_SP      = 8
                                 
                                 ; excpection handling
                                 .set USER_HANDLER = 10
                                 
                                 ; numeric IO
                                 .set USER_BASE  = 12
                                 
                                 ; character IO 
                                 .set USER_EMIT  = 14
                                 .set USER_EMITQ = 16
                                 .set USER_KEY   = 18
                                 .set USER_KEYQ  = 20
                                 
                                 .set USER_SOURCE  = 22
                                 .set USER_TO_IN   = 24
                                 .set USER_REFILL  = 26
                                 
                                 .set USER_P_OK    = 28
                                 .set USER_P_ERR   = 30
                                 .set USER_P_RDY   = 32
                                 
                                 .set SYSUSERSIZE = 34
                                 ; 
                                 
                                   .def zerol = r2
                                   .def zeroh = r3
                                   .def upl = r4
                                   .def uph = r5
                                 
                                   .def al  = r6
                                   .def ah  = r7
                                   .def bl  = r8
                                   .def bh  = r9
                                 
                                 ; internal
                                   .def mcu_boot = r10
                                   .def isrflag  = r11
                                 
                                   .def temp4 = r14
                                   .def temp5 = r15
                                 
                                   .def temp0 = r16
                                   .def temp1 = r17
                                   .def temp2 = r18
                                   .def temp3 = r19
                                 
                                   .def temp6 = r20
                                   .def temp7 = r21
                                 
                                   .def tosl = r24
                                   .def tosh = r25
                                 
                                   .def wl = r22
                                   .def wh = r23
                                 
                                 .macro loadtos
                                     ld tosl, Y+
                                     ld tosh, Y+
                                 .endmacro
                                 
                                 .macro savetos
                                     st -Y, tosh
                                     st -Y, tosl
                                 .endmacro
                                 
                                 .macro in_
                                 .if (@1 < $40)
                                   in @0,@1
                                 .else
                                   lds @0,@1
                                 .endif
                                 .endmacro
                                 
                                 .macro out_
                                 .if (@0 < $40)
                                   out @0,@1
                                 .else
                                   sts @0,@1
                                 .endif
                                 .endmacro
                                 
                                 .macro sbi_
                                 .if (@0 < $40)
                                   sbi @0,@1
                                 .else
                                   in_ @2,@0
                                   ori @2,exp2(@1)
                                   out_ @0,@2
                                 .endif
                                 .endmacro
                                 
                                 .macro cbi_
                                 .if (@0 < $40)
                                   cbi @0,@1
                                 .else
                                   in_ @2,@0
                                   andi @2,~(exp2(@1))
                                   out_ @0,@2
                                 .endif
                                 .endmacro
                                 
                                 .macro jmp_
                                 	; a more flexible macro
                                     .ifdef @0
                                     .if (@0-pc > 2040) || (pc-@0>2040)
                                 	jmp @0
                                 	.else
                                 	rjmp @0
                                 	.endif
                                 	.else
                                 	jmp @0
                                 	.endif
                                 .endmacro
                                 .macro call_
                                 	; a more flexible macro
                                     .ifdef @0
                                     .if (@0-pc > 2040) || (pc-@0>2040)
                                 	call @0
                                 	.else
                                 	rcall @0
                                 	.endif
                                 	.else
                                 	call @0
                                 	.endif
                                 .endmacro
                                 
                                 ;               F_CPU
                                 ;    µsec   16000000   14745600    8000000  1000000
                                 ;    1            16      14,74          8        1
                                 ;    10          160     147,45         80       10
                                 ;    100        1600    1474,56        800      100
                                 ;    1000      16000   14745,6        8000     1000
                                 ;
                                 ; cycles = µsec * f_cpu / 1e6
                                 ; n_loops=cycles/5
                                 ;
                                 ;     cycles already used will be subtracted from the delay
                                 ;     the waittime resolution is 1 cycle (delay from exact to +1 cycle)
                                 ;     the maximum delay at 20MHz (50ns/clock) is 38350ns
                                 ;     waitcount register must specify an immediate register
                                 ;
                                 ; busy waits a specfied amount of microseconds
                                 .macro   delay
                                       .set cycles = ( ( @0 * F_CPU ) / 1000000 )
                                       .if (cycles > ( 256 * 255 * 4 + 2))
                                         .error "MACRO delay - too many cycles to burn"
                                       .else
                                         .if (cycles > 6)
                                           .set  loop_cycles = (cycles / 4)      
                                           ldi   zl,low(loop_cycles)
                                           ldi   zh,high(loop_cycles)
                                           sbiw  Z, 1
                                           brne  pc-1
                                           .set  cycles = (cycles - (loop_cycles * 4))
                                         .endif
                                         .if (cycles > 0)
                                           .if   (cycles & 4)
                                             rjmp  pc+1
                                             rjmp  pc+1
                                           .endif
                                           .if   (cycles & 2)
                                             rjmp  pc+1
                                           .endif
                                           .if   (cycles & 1)
                                             nop
                                           .endif
                                         .endif
                                       .endif
                                 .endmacro
                                 
                                 ; portability macros, they come from the msp430 branches
                                 
                                 .macro DEST
                                     .dw @0
                                 .endm
                                 
                                 ; controller specific file selected via include
                                 ; directory definition when calling the assembler (-I)
                                 .include "device.asm"
                                 
                                 ; generated automatically, do not edit
                                 
                                 .list
                                 
                                 .equ ramstart =  256
                                 .equ CELLSIZE = 2
                                 .macro readflashcell
                                 	lsl zl
                                 	rol zh
                                 	lpm @0, Z+
                                 	lpm @1, Z+
                                 .endmacro
                                 .macro writeflashcell
                                 	lsl zl
                                 	rol zh
                                 .endmacro
                                 .set WANT_USART0 = 0
                                 .set WANT_TWI = 0
                                 .set WANT_TIMER_COUNTER_1 = 0
                                 .set WANT_TIMER_COUNTER_2 = 0
                                 .set WANT_AD_CONVERTER = 0
                                 .set WANT_ANALOG_COMPARATOR = 0
                                 .set WANT_PORTB = 0
                                 .set WANT_PORTC = 0
                                 .set WANT_PORTD = 0
                                 .set WANT_TIMER_COUNTER_0 = 0
                                 .set WANT_EXTERNAL_INTERRUPT = 0
                                 .set WANT_SPI = 0
                                 .set WANT_WATCHDOG = 0
                                 .set WANT_CPU = 0
                                 .set WANT_EEPROM = 0
                                 .equ intvecsize = 2 ; please verify; flash size: 32768 bytes
                                 .equ pclen = 2 ; please verify
                                 .overlap
                                 .org 2
000002 d126                      	 rcall isr ; External Interrupt Request 0
                                 .org 4
000004 d124                      	 rcall isr ; External Interrupt Request 1
                                 .org 6
000006 d122                      	 rcall isr ; Pin Change Interrupt Request 0
                                 .org 8
000008 d120                      	 rcall isr ; Pin Change Interrupt Request 0
                                 .org 10
00000a d11e                      	 rcall isr ; Pin Change Interrupt Request 1
                                 .org 12
00000c d11c                      	 rcall isr ; Watchdog Time-out Interrupt
                                 .org 14
00000e d11a                      	 rcall isr ; Timer/Counter2 Compare Match A
                                 .org 16
000010 d118                      	 rcall isr ; Timer/Counter2 Compare Match A
                                 .org 18
000012 d116                      	 rcall isr ; Timer/Counter2 Overflow
                                 .org 20
000014 d114                      	 rcall isr ; Timer/Counter1 Capture Event
                                 .org 22
000016 d112                      	 rcall isr ; Timer/Counter1 Compare Match A
                                 .org 24
000018 d110                      	 rcall isr ; Timer/Counter1 Compare Match B
                                 .org 26
00001a d10e                      	 rcall isr ; Timer/Counter1 Overflow
                                 .org 28
00001c d10c                      	 rcall isr ; TimerCounter0 Compare Match A
                                 .org 30
00001e d10a                      	 rcall isr ; TimerCounter0 Compare Match B
                                 .org 32
000020 d108                      	 rcall isr ; Timer/Couner0 Overflow
                                 .org 34
000022 d106                      	 rcall isr ; SPI Serial Transfer Complete
                                 .org 36
000024 d104                      	 rcall isr ; USART Rx Complete
                                 .org 38
000026 d102                      	 rcall isr ; USART, Data Register Empty
                                 .org 40
000028 d100                      	 rcall isr ; USART Tx Complete
                                 .org 42
00002a d0fe                      	 rcall isr ; ADC Conversion Complete
                                 .org 44
00002c d0fc                      	 rcall isr ; EEPROM Ready
                                 .org 46
00002e d0fa                      	 rcall isr ; Analog Comparator
                                 .org 48
000030 d0f8                      	 rcall isr ; Two-wire Serial Interface
                                 .org 50
000032 d0f6                      	 rcall isr ; Store Program Memory Read
                                 .equ INTVECTORS = 26
                                 .nooverlap
                                 
                                 ; compatability layer (maybe empty)
                                 ;.equ SPMEN = SELFPRGEN
                                 
                                 ; controller data area, environment query mcu-info
                                 mcu_info:
                                 mcu_ramsize:
000033 0800                      	.dw 2048
                                 mcu_eepromsize:
000034 0400                      	.dw 1024
                                 mcu_maxdp:
000035 7000                      	.dw 28672 
                                 mcu_numints:
000036 001a                      	.dw 26
                                 mcu_name:
000037 000a                      	.dw 10
000038 5441
000039 656d
00003a 6167
00003b 3233
00003c 5038                      	.db "ATmega328P"
                                 .set codestart=pc
                                 
                                 ; some defaults, change them in your application master file
                                 ; see template.asm for an example
                                 
                                 ; enabling Interrupts, disabling them affects
                                 ; other settings as well. 
                                 .set WANT_INTERRUPTS = 1
                                 
                                 ; count the number of interrupts individually.
                                 ; requires a lot of RAM (one byte per interrupt)
                                 ; disabled by default.
                                 .set WANT_INTERRUPT_COUNTERS = 0
                                 
                                 ; receiving is asynchronously, so an interrupt queue is useful.
                                 .set WANT_ISR_RX = 1
                                 
                                 ; case insensitve dictionary lookup.
                                 .set WANT_IGNORECASE = 0
                                 
                                 ; map all memories to one address space. Details in the
                                 ; technical guide
                                 .set WANT_UNIFIED = 0
                                 
                                 ; terminal input buffer
                                 .set TIB_SIZE  = 90    ; ANS94 needs at least 80 characters per line
                                 
                                 ; USER variables *in addition* to system ones
                                 .set APPUSERSIZE = 10  ; size of application specific user area in bytes
                                 
                                 ; addresses of various data segments
                                 .set rstackstart = RAMEND      ; start address of return stack, grows downward
                                 .set stackstart  = RAMEND - 80 ; start address of data stack, grows downward
                                 ; change only if you know what to you do
                                 .set NUMWORDLISTS = 8 ; number of word lists in the searh order, at least 8
                                 .set NUMRECOGNIZERS = 4 ; total number of recognizers, two are always used.
                                 
                                 ; 10 per mille (1 per cent) is ok.
                                 .set BAUD = 38400
                                 .set BAUD_MAXERROR = 10
                                 
                                 ; Dictionary setup
                                 .set VE_HEAD = $0000
                                 .set VE_ENVHEAD = $0000
                                 
                                 .equ F_CPU = 16000000
                                 .include "drivers/usart_0.asm"
                                 
                                   .equ BAUDRATE_HIGH = UBRR0H
                                   .equ USART_C = UCSR0C
                                   .equ USART_B = UCSR0B
                                   .equ USART_A = UCSR0A
                                   .equ USART_DATA = UDR0
                                   .ifndef URXCaddr
                                   .endif
                                 
                                 .equ bm_USART_RXRD = 1 << RXC0
                                 .equ bm_USART_TXRD = 1 << UDRE0
                                 .equ bm_ENABLE_TX  = 1 << TXEN0
                                 .equ bm_ENABLE_RX  = 1 << RXEN0
                                 .equ bm_ENABLE_INT_RX = 1<<RXCIE0
                                 .equ bm_ENABLE_INT_TX = 1<<UDRIE0
                                 
                                 .equ bm_USARTC_en   = 0
                                 .equ bm_ASYNC       = 0 << 6
                                 .equ bm_SYNC        = 1 << 6
                                 .equ bm_NO_PARITY   = 0 << 4
                                 .equ bm_EVEN_PARITY = 2 << 4
                                 .equ bm_ODD_PARITY  = 3 << 4
                                 .equ bm_1STOPBIT    = 0 << 3
                                 .equ bm_2STOPBIT    = 1 << 3
                                 .equ bm_5BIT        = 0 << 1
                                 .equ bm_6BIT        = 1 << 1
                                 .equ bm_7BIT        = 2 << 1
                                 .equ bm_8BIT        = 3 << 1
                                 
                                 .include "drivers/usart_common.asm"
                                 
                                 .set USART_C_VALUE = bm_ASYNC | bm_NO_PARITY | bm_1STOPBIT | bm_8BIT
                                 .if WANT_INTERRUPTS == 0
                                   .if WANT_ISR_RX == 1
                                   .endif
                                 .endif
                                 
                                 .if WANT_ISR_RX == 1
                                   .set USART_B_VALUE = bm_ENABLE_TX | bm_ENABLE_RX | bm_ENABLE_INT_RX
                                   .include "drivers/usart-rx-buffer.asm"
                                 
                                 
                                 ; sizes have to be powers of 2!
                                 .equ usart_rx_size = $10
                                 .equ usart_rx_mask = usart_rx_size - 1
                                 .dseg
000100                            usart_rx_data: .byte usart_rx_size
000110                            usart_rx_in:   .byte 1
000111                            usart_rx_out:  .byte 1
                                 .cseg
                                 
                                 VE_TO_RXBUF:
00003d ff07                          .dw $ff07
00003e 723e
00003f 2d78
000040 7562
000041 0066                          .db ">rx-buf",0
000042 0000                          .dw VE_HEAD
                                     .set VE_HEAD = VE_TO_RXBUF
                                 XT_TO_RXBUF:
000043 0044                          .dw PFA_rx_tobuf
                                 PFA_rx_tobuf:
000044 2f08                          mov temp0, tosl
000045 9110 0110                     lds temp1, usart_rx_in
000047 e0e0                          ldi zl, low(usart_rx_data)
000048 e0f1                          ldi zh, high(usart_rx_data)
000049 0fe1                          add zl, temp1
00004a 1df3                          adc zh, zeroh
00004b 8300                          st Z, temp0
00004c 9513                          inc temp1
00004d 701f                          andi temp1,usart_rx_mask
00004e 9310 0110                     sts usart_rx_in, temp1
000050 9189
000051 9199                          loadtos
000052 940c 3804                     jmp_ DO_NEXT
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; setup with
                                 ; ' isr-rx URXCaddr int!
                                 VE_ISR_RX:
000054 ff06                          .dw $ff06
000055 7369
000056 2d72
000057 7872                          .db "isr-rx"
000058 003d                          .dw VE_HEAD
                                     .set VE_HEAD = VE_ISR_RX
                                 XT_ISR_RX:
000059 3800                          .dw DO_COLON
                                 usart_rx_isr:
00005a 383c                        .dw XT_DOLITERAL
00005b 00c6                        .dw usart_data
00005c 3897                        .dw XT_CFETCH
00005d 38b0                        .dw XT_DUP
00005e 383c                        .dw XT_DOLITERAL
00005f 0003                        .dw 3
000060 3fde                        .dw XT_EQUAL
000061 3835                        .dw XT_DOCONDBRANCH
000062 0064                        .dw usart_rx_isr1
000063 3d37                        .dw XT_COLD
                                 usart_rx_isr1:
000064 0043                        .dw XT_TO_RXBUF
000065 381f                        .dw XT_EXIT
                                 
                                 ; ( -- ) Hardware Access
                                 ; R( --)
                                 ; initialize usart
                                 ;VE_USART_INIT_RXBUFFER:
                                 ;  .dw $ff0x
                                 ;  .db "+usart-buffer"
                                 ;  .dw VE_HEAD
                                 ;  .set VE_HEAD = VE_USART_INIT_RXBUFFER
                                 XT_USART_INIT_RX_BUFFER:
000066 3800                        .dw DO_COLON
                                 PFA_USART_INIT_RX_BUFFER:          ; ( -- )
000067 383c
000068 0059                        .dw XT_DOLITERAL, XT_ISR_RX
000069 383c
00006a 0024                        .dw XT_DOLITERAL, URXCaddr
00006b 3ca4                        .dw XT_INTSTORE
                                 
00006c 383c                        .dw XT_DOLITERAL
00006d 0100                        .dw usart_rx_data
00006e 383c                        .dw XT_DOLITERAL
00006f 0016                        .dw usart_rx_size + 6
000070 3953                        .dw XT_ZERO
000071 3e97                        .dw XT_FILL
000072 381f                        .dw XT_EXIT
                                 
                                 ; ( -- c)
                                 ; MCU
                                 ; get 1 character from input queue, wait if needed using interrupt driver
                                 VE_RX_BUFFER:
000073 ff06                          .dw $ff06
000074 7872
000075 622d
000076 6675                          .db "rx-buf"
000077 0054                          .dw VE_HEAD
                                     .set VE_HEAD = VE_RX_BUFFER
                                 XT_RX_BUFFER:
000078 3800                          .dw DO_COLON
                                 PFA_RX_BUFFER:
000079 0093                        .dw XT_RXQ_BUFFER
00007a 3835                        .dw XT_DOCONDBRANCH
00007b 0079                        .dw PFA_RX_BUFFER
00007c 383c                        .dw XT_DOLITERAL
00007d 0111                        .dw usart_rx_out
00007e 3897                        .dw XT_CFETCH
00007f 38b0                        .dw XT_DUP
000080 383c                        .dw XT_DOLITERAL
000081 0100                        .dw usart_rx_data
000082 399c                        .dw XT_PLUS
000083 3897                        .dw XT_CFETCH
000084 38c3                        .dw XT_SWAP
000085 3a2e                        .dw XT_1PLUS
000086 383c                        .dw XT_DOLITERAL
000087 000f                        .dw usart_rx_mask
000088 3a12                        .dw XT_AND
000089 383c                        .dw XT_DOLITERAL
00008a 0111                        .dw usart_rx_out
00008b 388c                        .dw XT_CSTORE
00008c 381f                        .dw XT_EXIT
                                 
                                 ; ( -- f)  
                                 ; MCU
                                 ; check if unread characters are in the input queue
                                 VE_RXQ_BUFFER:
00008d ff07                          .dw $ff07
00008e 7872
00008f 2d3f
000090 7562
000091 0066                          .db "rx?-buf",0
000092 0073                          .dw VE_HEAD
                                     .set VE_HEAD = VE_RXQ_BUFFER
                                 XT_RXQ_BUFFER:
000093 3800                          .dw DO_COLON
                                 PFA_RXQ_BUFFER:
000094 3d2f                        .dw XT_PAUSE
000095 383c                        .dw XT_DOLITERAL
000096 0111                        .dw usart_rx_out
000097 3897                        .dw XT_CFETCH
000098 383c                        .dw XT_DOLITERAL
000099 0110                        .dw usart_rx_in
00009a 3897                        .dw XT_CFETCH
00009b 3912                        .dw XT_NOTEQUAL
00009c 381f                        .dw XT_EXIT
                                 ;  .include "drivers/timer-usart-isr.asm"
                                   .set XT_RX  = XT_RX_BUFFER
                                   .set XT_RXQ = XT_RXQ_BUFFER
                                   .set XT_USART_INIT_RX = XT_USART_INIT_RX_BUFFER
                                 .else
                                 .endif
                                 
                                 .include "words/usart-tx-poll.asm"
                                 
                                 ; MCU
                                 ; check availability and send one character to the terminal using register poll
                                 VE_TX_POLL:
00009d ff07                          .dw $ff07
00009e 7874
00009f 702d
0000a0 6c6f
0000a1 006c                          .db "tx-poll",0
0000a2 008d                          .dw VE_HEAD
                                     .set VE_HEAD = VE_TX_POLL
                                 XT_TX_POLL:
0000a3 3800                          .dw DO_COLON
                                 PFA_TX_POLL:
                                   ; wait for data ready
0000a4 00b1                        .dw XT_TXQ_POLL
0000a5 3835                        .dw XT_DOCONDBRANCH
0000a6 00a4                        .dw PFA_TX_POLL
                                   ; send to usart
0000a7 383c                        .dw XT_DOLITERAL
0000a8 00c6                        .dw USART_DATA
0000a9 388c                        .dw XT_CSTORE
0000aa 381f                        .dw XT_EXIT
                                 
                                 ; ( -- f) MCU
                                 ; MCU
                                 ; check if a character can be send using register poll
                                 VE_TXQ_POLL:
0000ab ff08                          .dw $ff08
0000ac 7874
0000ad 2d3f
0000ae 6f70
0000af 6c6c                          .db "tx?-poll"
0000b0 009d                          .dw VE_HEAD
                                     .set VE_HEAD = VE_TXQ_POLL
                                 XT_TXQ_POLL:
0000b1 3800                          .dw DO_COLON
                                 PFA_TXQ_POLL:
0000b2 3d2f                        .dw XT_PAUSE
0000b3 383c                        .dw XT_DOLITERAL
0000b4 00c0                        .dw USART_A
0000b5 3897                        .dw XT_CFETCH
0000b6 383c                        .dw XT_DOLITERAL
0000b7 0020                        .dw bm_USART_TXRD
0000b8 3a12                        .dw XT_AND
0000b9 381f                        .dw XT_EXIT
                                 .set XT_TX  = XT_TX_POLL
                                 .set XT_TXQ = XT_TXQ_POLL
                                 .set XT_USART_INIT_TX = 0
                                 
                                 .include "words/ubrr.asm"
                                 
                                 ; MCU
                                 ; returns usart UBRR settings
                                 VE_UBRR:
0000ba ff04                        .dw $ff04
0000bb 6275
0000bc 7272                        .db "ubrr"
0000bd 00ab                        .dw VE_HEAD
                                   .set VE_HEAD = VE_UBRR
                                 XT_UBRR:
0000be 386e                        .dw PFA_DOVALUE1
                                 PFA_UBRR:          ; ( -- )
0000bf 008c                        .dw EE_UBRRVAL
0000c0 3d9f                        .dw XT_EDEFERFETCH
0000c1 3da9                        .dw XT_EDEFERSTORE
                                 .include "words/usart.asm"
                                 
                                 ; MCU
                                 ; initialize usart
                                 VE_USART:
0000c2 ff06                        .dw $ff06
0000c3 752b
0000c4 6173
0000c5 7472                        .db "+usart"
0000c6 00ba                        .dw VE_HEAD
                                   .set VE_HEAD = VE_USART
                                 XT_USART:
0000c7 3800                        .dw DO_COLON
                                 PFA_USART:          ; ( -- )
                                 
0000c8 383c                        .dw XT_DOLITERAL
0000c9 0098                        .dw USART_B_VALUE
0000ca 383c                        .dw XT_DOLITERAL
0000cb 00c1                        .dw USART_B
0000cc 388c                        .dw XT_CSTORE
                                 
0000cd 383c                        .dw XT_DOLITERAL
0000ce 0006                        .dw USART_C_VALUE
0000cf 383c                        .dw XT_DOLITERAL
0000d0 00c2                        .dw USART_C | bm_USARTC_en
0000d1 388c                        .dw XT_CSTORE
                                 
0000d2 00be                        .dw XT_UBRR
0000d3 38b0                        .dw XT_DUP
0000d4 3af8                        .dw XT_BYTESWAP
0000d5 383c                        .dw XT_DOLITERAL
0000d6 00c5                        .dw BAUDRATE_HIGH
0000d7 388c                        .dw XT_CSTORE
0000d8 383c                        .dw XT_DOLITERAL
0000d9 00c4                        .dw BAUDRATE_LOW
0000da 388c                        .dw XT_CSTORE
                                 .if XT_USART_INIT_RX!=0
0000db 0066                        .dw XT_USART_INIT_RX
                                 .endif
                                 .if XT_USART_INIT_TX!=0
                                 .endif
                                 
0000dc 381f                        .dw XT_EXIT
                                 
                                 ; settings for 1wire interface, if desired
                                 .equ OW_PORT=PORTB
                                 .EQU OW_BIT=4
                                 .include "drivers/1wire.asm"
                                 
                                 ;   B. J. Rodriguez (MSP 430)
                                 ;   Matthias Trute (AVR Atmega)
                                 ; COPYRIGHT
                                 ;   (c) 2012 Bradford J. Rodriguez for the 430 code and API
                                 
                                 ;  adapted 430 assembly code to AVR
                                 ;  wishlist: 
                                 ;     use a configurable pin at runtime, compatible with bitnames.frt
                                 ;     no external pull up, no external power supply for devices
                                 ;     ???
                                 ;
                                 ;.EQU OW_BIT=4
                                 ;.equ OW_PORT=PORTE
                                 .set OW_DDR=(OW_PORT-1)
                                 .set OW_PIN=(OW_DDR-1)
                                 
                                 ;****f* 1W.RESET
                                 ; NAME
                                 ;   1W.RESET
                                 ; SYNOPSIS
                                 ;   1W.RESET ( -- f )  Initialize 1-wire devices; return true if present
                                 ; DESCRIPTION
                                 ;   This configures the port pin used by the 1-wire interface, and then
                                 ;   sends an "initialize" sequence to the 1-wire devices.  If any device
                                 ;   is present, it will be detected.
                                 ;
                                 ;   Timing, per DS18B20 data sheet:
                                 ;   a) Output "0" (drive output low) for >480 usec.
                                 ;   b) Output "1" (let output float).
                                 ;   c) After 15 to 60 usec, device will drive pin low for 60 to 240 usec.
                                 ;      So, wait 75 usec and sample input.
                                 ;   d) Leave output high (floating) for at least 480 usec.
                                 ;******
                                 ; ( -- f )
                                 ; Hardware
                                 ; Initialize 1-wire devices; return true if present
                                 VE_OW_RESET:
0000dd ff08                          .dw $ff08
0000de 7731
0000df 722e
0000e0 7365
0000e1 7465                          .db "1w.reset"
0000e2 00c2                          .dw VE_HEAD
                                     .set VE_HEAD = VE_OW_RESET
                                 XT_OW_RESET:
0000e3 00e4                          .dw PFA_OW_RESET
                                 PFA_OW_RESET:
0000e4 939a
0000e5 938a                          savetos
                                     ; setup to output
0000e6 9a24                          sbi OW_DDR, OW_BIT
                                     ; Pull output low
0000e7 982c                          cbi OW_PORT, OW_BIT
                                     ; Delay >480 usec        
0000e8 e8e0
0000e9 e0f7
0000ea 9731
0000eb f7f1                          DELAY   480
                                     ; Critical timing period, disable interrupts.
0000ec b71f                          in temp1, SREG
0000ed 94f8                          cli
                                     ; Pull output high
0000ee 9a2c                          sbi OW_PORT, OW_BIT
                                     ; make pin input, sends "1"
0000ef 9824                          cbi OW_DDR, OW_BIT 
0000f0 e0e0
0000f1 e0f1
0000f2 9731
0000f3 f7f1                          DELAY   64 ; delayB
                                     ; Sample input pin, set TOS if input is zero
0000f4 b183                          in tosl, OW_PIN
0000f5 ff84                          sbrs tosl, OW_BIT
0000f6 ef9f                          ser  tosh
                                     ; End critical timing period, enable interrupts
0000f7 bf1f                          out SREG, temp1
                                     ; release bus
0000f8 9824                          cbi OW_DDR, OW_BIT
0000f9 982c                          cbi OW_PORT, OW_BIT
                                 
                                     ; Delay rest of 480 usec 
0000fa e8e0
0000fb e0f6
0000fc 9731
0000fd f7f1                          DELAY   416
                                     ; we now have the result flag in TOS        
0000fe 2f89                          mov tosl, tosh
0000ff 940c 3804                     jmp_ DO_NEXT
                                     
                                 ;****f* 1W.SLOT
                                 ; NAME
                                 ;   1W.SLOT
                                 ; SYNOPSIS
                                 ;   1W.SLOT ( c -- c' ) Write and read one bit to/from 1-wire.
                                 ; DESCRIPTION
                                 ;   The "touch byte" function is described in Dallas App Note 74.
                                 ;   It outputs a byte to the 1-wire pin, LSB first, and reads back
                                 ;   the state of the 1-wire pin after a suitable delay.
                                 ;   To read a byte, output $FF and read the reply data.
                                 ;   To write a byte, output that byte and discard the reply.
                                 ;
                                 ;   This function performs one bit of the "touch" operation --
                                 ;   one read/write "slot" in Dallas jargon.  Perform this eight
                                 ;   times in a row to get the "touch byte" function.
                                 ;
                                 ; PARAMETERS
                                 ;   The input parameter is xxxxxxxxbbbbbbbo where
                                 ;   'xxxxxxxx' are don't cares,
                                 ;   'bbbbbbb' are bits to be shifted down, and
                                 ;   'o' is the bit to be output in the slot.  This must be 1
                                 ;   to create a read slot.
                                 ;
                                 ;   The returned value is xxxxxxxxibbbbbbb where
                                 ;   'xxxxxxxx' are not known (the input shifted down 1 position),
                                 ;   'i' is the bit read during the slot.  This has no meaning
                                 ;   if it was a write slot.
                                 ;   'bbbbbbb' are the 7 input bits, shifted down one position.
                                 ;
                                 ;   This peculiar parameter usage allows OWTOUCH to be written as
                                 ;     OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT 
                                 ;
                                 ; NOTES 
                                 ;   Interrupts are disabled during each bit.
                                 
                                 ;   Timing, per DS18B20 data sheet:
                                 ;   a) Output "0" for start period.  (> 1 us, < 15 us, typ. 6 us*)
                                 ;   b) Output data bit (0 or 1), open drain 
                                 ;   c) After MS from start of cycle, sample input (15 to 60 us, typ. 25 us*)
                                 ;   d) After write-0 period from start of cycle, output "1" (>60 us)
                                 ;   e) After recovery period, loop or return. (> 1 us)
                                 ;   For writes, DS18B20 samples input 15 to 60 usec from start of cycle.
                                 ;   * "Typical" values are per App Note 132 for a 300m cable length.
                                 
                                 ;   ---------        -------------------------------
                                 ;            \      /                        /
                                 ;             ------------------------------- 
                                 ;            a      b          c             d     e
                                 ;            |  6us |   19us   |    35us     | 2us |
                                 ;******
                                 ; ( c -- c' )
                                 ; Hardware
                                 ; Write and read one bit to/from 1-wire.
                                 VE_OW_SLOT:
000101 ff07                          .dw $ff07
000102 7731
000103 732e
000104 6f6c
000105 0074                          .db "1w.slot",0
000106 00dd                          .dw VE_HEAD
                                     .set VE_HEAD = VE_OW_SLOT
                                 XT_OW_SLOT:
000107 0108                          .dw PFA_OW_SLOT
                                 PFA_OW_SLOT:
                                     ; pull low
000108 982c                          cbi OW_PORT, OW_BIT
000109 9a24                          sbi OW_DDR, OW_BIT
                                     ; disable interrupts
00010a b71f                          in temp1, SREG
00010b 94f8                          cli
00010c e1e8
00010d e0f0
00010e 9731
00010f f7f1                          DELAY   6 ; DELAY A
                                     ; check bit
000110 9488                          clc
000111 9587                          ror tosl
000112 f410                          brcc PFA_OW_SLOT0 ; a 0 keeps the bus low
                                       ; release bus, a 1 is written
000113 9a2c                            sbi OW_PORT, OW_BIT
000114 9824                            cbi OW_DDR, OW_BIT
                                 PFA_OW_SLOT0:
                                     ; sample the input (no action required if zero)
000115 e2e4
000116 e0f0
000117 9731
000118 f7f1                          DELAY 9   ; wait DELAY E to sample
000119 b103                          in temp0, OW_PIN
00011a fd04                          sbrc temp0, OW_BIT
00011b 6880                          ori tosl, $80
                                 
00011c ecec
00011d e0f0
00011e 9731
00011f f7f1                          DELAY   51 ; DELAY B
000120 9a2c                          sbi OW_PORT, OW_BIT ; release bus
000121 9824                          cbi OW_DDR, OW_BIT
000122 e0e8
000123 e0f0
000124 9731
000125 f7f1                          delay 2
                                     ; re-enable interrupts
000126 bf1f                          out SREG, temp1
000127 940c 3804                     jmp_ DO_NEXT
                                 
                                 .include "amforth.asm"
                                 
                                 ;;;;
                                 ;;;; GPL V2 (only)
                                 
                                 .set AMFORTH_NRWW_SIZE=(FLASHEND-AMFORTH_RO_SEG)*2
                                 
                                 .set corepc = pc
                                 .org $0000
000000 940c 3d38                   jmp_ PFA_COLD
                                 
                                 .org corepc
                                 .include "drivers/generic-isr.asm"
                                 
                                 .eseg
000000                           intvec: .byte INTVECTORS * CELLSIZE
                                 .dseg
000112                           intcnt: .byte INTVECTORS
                                 .cseg
                                 
                                 ; interrupt routine gets called (again) by rcall! This gives the
                                 ; address of the int-vector on the stack.
                                 isr:
000129 920a                          st -Y, r0
00012a b60f                          in r0, SREG
00012b 920a                          st -Y, r0
                                 .if (pclen==3)
                                 .endif
00012c 900f                          pop r0
00012d 900f                          pop r0          ; = intnum * intvectorsize + 1 (address following the rcall)
00012e 940a                          dec r0
                                 .if intvecsize == 1 ;
                                 .endif
00012f 2cb0                          mov isrflag, r0
000130 93ff                          push zh
000131 93ef                          push zl
000132 e1e2                          ldi zl, low(intcnt)
000133 e0f1                          ldi zh, high(intcnt)
000134 9406                          lsr r0 ; we use byte addresses in the counter array, not words
000135 0de0                          add zl, r0
000136 1df3                          adc zh, zeroh
000137 8000                          ld r0, Z
000138 9403                          inc r0
000139 8200                          st Z, r0
00013a 91ef                          pop zl
00013b 91ff                          pop zh
                                 
00013c 9009                          ld r0, Y+
00013d be0f                          out SREG, r0
00013e 9009                          ld r0, Y+
00013f 9508                          ret ; returns the interrupt, the rcall stack frame is removed!
                                     ; no reti here, see words/isr-end.asm
                                 ; lower part of the dictionary
                                 .include "dict/rww.inc"
                                 
                                 
                                 ; Arithmetics
                                 ; add a number to a double cell
                                 VE_MPLUS:
000140 ff02                          .dw $ff02
000141 2b6d                          .db "m+"
000142 0101                          .dw VE_HEAD
                                     .set VE_HEAD = VE_MPLUS
                                 XT_MPLUS:
000143 3800                          .dw DO_COLON
                                 PFA_MPLUS:
000144 3fc6                          .dw XT_S2D
000145 3c14                          .dw XT_DPLUS
000146 381f                          .dw XT_EXIT
                                 .include "words/ud-star.asm"
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_UDSTAR:
000147 ff03                          .dw $ff03
000148 6475
amforth-6.5\common\words/ud-star.asm(9): warning: .cseg .db misalignment - padding zero byte
000149 002a                          .db "ud*"
00014a 0140                          .dw VE_HEAD
                                     .set VE_HEAD = VE_UDSTAR
                                 XT_UDSTAR:
00014b 3800                          .dw DO_COLON
                                 PFA_UDSTAR:
                                 
                                 .endif
                                 ;Z UD*      ud1 d2 -- ud3      32*16->32 multiply
                                 ;   XT_DUP >R UM* DROP  XT_SWAP R> UM* ROT + ;
                                 
00014c 38b0
00014d 38fe
00014e 39df
00014f 38d8                              .DW XT_DUP,XT_TO_R,XT_UMSTAR,XT_DROP
000150 38c3
000151 38f5
000152 39df
000153 38e0
000154 399c
000155 381f                              .DW XT_SWAP,XT_R_FROM,XT_UMSTAR,XT_ROT,XT_PLUS,XT_EXIT
                                 .include "words/umax.asm"
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_UMAX:
000156 ff04                          .dw $ff04
000157 6d75
000158 7861                          .db "umax"
000159 0147                          .dw VE_HEAD
                                     .set VE_HEAD = VE_UMAX
                                 XT_UMAX:
00015a 3800                          .dw DO_COLON
                                 PFA_UMAX:
                                 .endif
                                 
00015b 3ec8
00015c 395b                              .DW XT_2DUP,XT_ULESS
00015d 3835                      	.dw XT_DOCONDBRANCH
00015e 0160                      	 DEST(UMAX1)
00015f 38c3                              .DW XT_SWAP
000160 38d8                      UMAX1:  .DW XT_DROP
000161 381f                      	.dw XT_EXIT
                                 .include "words/umin.asm"
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_UMIN:
000162 ff04                          .dw $ff04
000163 6d75
000164 6e69                          .db "umin"
000165 0156                          .dw VE_HEAD
                                     .set VE_HEAD = VE_UMIN
                                 XT_UMIN:
000166 3800                          .dw DO_COLON
                                 PFA_UMIN:
                                 .endif
000167 3ec8
000168 3966                              .DW XT_2DUP,XT_UGREATER
000169 3835                      	.dw XT_DOCONDBRANCH
00016a 016c                      	DEST(UMIN1)
00016b 38c3                              .DW XT_SWAP
00016c 38d8                      UMIN1:  .DW XT_DROP
00016d 381f                      	.dw XT_EXIT
                                 .include "words/immediate-q.asm"
                                 
                                 ; Tools
                                 ; return +1 if immediate, -1 otherwise, flag from name>flags
                                 ;VE_IMMEDIATEQ:
                                 ;    .dw $ff06
                                 ;    .db "immediate?"
                                 ;    .dw VE_HEAD
                                 ;    .set VE_HEAD = VE_IMMEDIATEQ
                                 XT_IMMEDIATEQ:
00016e 3800                          .dw DO_COLON
                                 PFA_IMMEDIATEQ:
00016f 383c                          .dw XT_DOLITERAL
000170 8000                          .dw $8000
000171 3a12                          .dw XT_AND
000172 3919                          .dw XT_ZEROEQUAL
000173 3835                          .dw XT_DOCONDBRANCH
000174 0177                          DEST(IMMEDIATEQ1)
000175 3fe5                           .dw XT_ONE
000176 381f                           .dw XT_EXIT
                                 IMMEDIATEQ1:
                                     ; not immediate
000177 394a                          .dw XT_TRUE
000178 381f                          .dw XT_EXIT
                                 .include "words/name2flags.asm"
                                 
                                 ; Tools
                                 ; get the flags from a name token
                                 VE_NAME2FLAGS:
000179 ff0a                          .dw $ff0a
00017a 616e
00017b 656d
00017c 663e
00017d 616c
00017e 7367                          .db "name>flags"
00017f 0162                          .dw VE_HEAD
                                     .set VE_HEAD = VE_NAME2FLAGS
                                 XT_NAME2FLAGS:
000180 3800                          .dw DO_COLON
                                 PFA_NAME2FLAGS:
000181 3bca                          .dw XT_FETCHI ; skip to link field
000182 383c                          .dw XT_DOLITERAL
000183 ff00                          .dw $ff00
000184 3a12                          .dw XT_AND
000185 381f                          .dw XT_EXIT
                                 
                                 .if AMFORTH_NRWW_SIZE > 8000
                                 .elif AMFORTH_NRWW_SIZE > 4000
                                 .include "dict/appl_4k.inc"
                                 
                                 
                                 ; Tools
                                 ; print the version string
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_DOT_VER:
000186 ff03                          .dw $ff03
000187 6576
amforth-6.5\common\words/ver.asm(12): warning: .cseg .db misalignment - padding zero byte
000188 0072                          .db "ver"
000189 0179                          .dw VE_HEAD
                                     .set VE_HEAD = VE_DOT_VER
                                 XT_DOT_VER:
00018a 3800                          .dw DO_COLON
                                 PFA_DOT_VER:
                                 .endif
00018b 02da                          .dw XT_ENV_FORTHNAME
00018c 0403                          .dw XT_ITYPE
00018d 3fad                          .dw XT_SPACE
00018e 3ebc                          .dw XT_BASE
00018f 3878                          .dw XT_FETCH
                                 
000190 02e8                          .dw XT_ENV_FORTHVERSION
000191 3f40                          .dw XT_DECIMAL
000192 3fc6                          .dw XT_S2D
000193 0321                          .dw XT_L_SHARP
000194 0329                          .dw XT_SHARP
000195 383c                          .dw XT_DOLITERAL
000196 002e                          .dw '.'
000197 0312                          .dw XT_HOLD
000198 033f                          .dw XT_SHARP_S
000199 034a                          .dw XT_SHARP_G
00019a 0439                          .dw XT_TYPE
00019b 3ebc                          .dw XT_BASE
00019c 3880                          .dw XT_STORE
00019d 3fad                          .dw XT_SPACE
00019e 02f0                          .dw XT_ENV_CPU
00019f 0403                          .dw XT_ITYPE
                                 
0001a0 381f                          .dw XT_EXIT
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 .include "words/noop.asm"
                                 
                                 ; Tools
                                 ; do nothing
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_NOOP:
0001a1 ff04                          .dw $ff04
0001a2 6f6e
0001a3 706f                          .db "noop"
0001a4 0186                          .dw VE_HEAD
                                     .set VE_HEAD = VE_NOOP
                                 XT_NOOP:
0001a5 3800                          .dw DO_COLON
                                 PFA_NOOP:
                                 .endif
0001a6 381f                         .DW XT_EXIT
                                 .include "words/unused.asm"
                                 
                                 ; Tools
                                 ; Amount of available RAM (incl. PAD)
                                 VE_UNUSED:
0001a7 ff06                          .dw $ff06
0001a8 6e75
0001a9 7375
0001aa 6465                          .db "unused"
0001ab 01a1                          .dw VE_HEAD
                                     .set VE_HEAD = VE_UNUSED
                                 XT_UNUSED:
0001ac 3800                          .dw DO_COLON
                                 PFA_UNUSED:
0001ad 3a8c                          .dw XT_SP_FETCH
0001ae 3f22                          .dw XT_HERE
0001af 3992                          .dw XT_MINUS
0001b0 381f                          .dw XT_EXIT
                                 .include "words/to.asm"
                                 
                                 ; Tools
                                 ; store the TOS to the named value (eeprom cell)
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_TO:
0001b1 0002                          .dw $0002
0001b2 6f74                          .db "to"
0001b3 01a7                          .dw VE_HEAD
                                     .set VE_HEAD = VE_TO
                                 XT_TO:
0001b4 3800                          .dw DO_COLON
                                 PFA_TO:
                                 .endif
0001b5 0448                          .dw XT_TICK
0001b6 3fcf                          .dw XT_TO_BODY
0001b7 3eb6                          .dw XT_STATE
0001b8 3878                          .dw XT_FETCH
0001b9 3835                          .dw XT_DOCONDBRANCH
0001ba 01c5                          DEST(PFA_TO1)
0001bb 075c                          .dw XT_COMPILE
0001bc 01bf                          .dw XT_DOTO
0001bd 0767                          .dw XT_COMMA
0001be 381f                          .dw XT_EXIT
                                 
                                 ; ( n -- ) (R: IP -- IP+1)
                                 ; Tools
                                 ; runtime portion of to
                                 ;VE_DOTO:
                                 ;    .dw $ff04
                                 ;    .db "(to)"
                                 ;    .dw VE_HEAD
                                 ;    .set VE_HEAD = VE_DOTO
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 
                                 XT_DOTO:
0001bf 3800                          .dw DO_COLON
                                 PFA_DOTO:
                                 .endif
0001c0 38f5                          .dw XT_R_FROM
0001c1 38b0                          .dw XT_DUP
0001c2 01d1                          .dw XT_ICELLPLUS
0001c3 38fe                          .dw XT_TO_R
0001c4 3bca                          .dw XT_FETCHI
                                 PFA_TO1:
0001c5 38b0                          .dw XT_DUP
0001c6 01d1                          .dw XT_ICELLPLUS
0001c7 01d1                          .dw XT_ICELLPLUS
0001c8 3bca                          .dw XT_FETCHI
0001c9 3829                          .dw XT_EXECUTE
0001ca 381f                          .dw XT_EXIT
                                 .include "words/i-cellplus.asm"
                                 
                                 ; Compiler
                                 ; skip to the next cell in flash
                                 VE_ICELLPLUS:
0001cb ff07                          .dw $FF07
0001cc 2d69
0001cd 6563
0001ce 6c6c
0001cf 002b                          .db "i-cell+",0
0001d0 01b1                          .dw VE_HEAD
                                     .set VE_HEAD = VE_ICELLPLUS
                                 XT_ICELLPLUS:
0001d1 3800                          .dw DO_COLON
                                 PFA_ICELLPLUS:
0001d2 3a2e                          .dw XT_1PLUS
0001d3 381f                          .dw XT_EXIT
                                 .include "words/icompare.asm"
                                 
                                 ; Tools
                                 ; compares string in RAM with string in flash. f is zero if equal like COMPARE
                                 VE_ICOMPARE:
0001d4 ff08                          .dw $ff08
0001d5 6369
0001d6 6d6f
0001d7 6170
0001d8 6572                          .db "icompare"
0001d9 01cb                          .dw VE_HEAD
                                     .set VE_HEAD = VE_ICOMPARE
                                 XT_ICOMPARE:
0001da 3800                          .dw DO_COLON
                                 PFA_ICOMPARE:
0001db 38fe                          .dw XT_TO_R    ; ( -- r-addr r-len f-addr)
0001dc 38ce                          .dw XT_OVER    ; ( -- r-addr r-len f-addr r-len)
0001dd 38f5                          .dw XT_R_FROM  ; ( -- r-addr r-len f-addr r-len f-len )
0001de 3912                          .dw XT_NOTEQUAL ; ( -- r-addr r-len f-addr flag )
0001df 3835                          .dw XT_DOCONDBRANCH
0001e0 01e5                          .dw PFA_ICOMPARE_SAMELEN
0001e1 3ed1                            .dw XT_2DROP
0001e2 38d8                            .dw XT_DROP
0001e3 394a                            .dw XT_TRUE
0001e4 381f                            .dw XT_EXIT
                                 PFA_ICOMPARE_SAMELEN:
0001e5 38c3                          .dw XT_SWAP ; ( -- r-addr f-addr len )
0001e6 3953                          .dw XT_ZERO
0001e7 0826                          .dw XT_QDOCHECK
0001e8 3835                          .dw XT_DOCONDBRANCH
0001e9 0208                          .dw PFA_ICOMPARE_DONE
0001ea 3a9a                          .dw XT_DODO
                                 PFA_ICOMPARE_LOOP:
                                     ; ( r-addr f-addr --)
0001eb 38ce                          .dw XT_OVER
0001ec 3878                          .dw XT_FETCH
                                 .if WANT_IGNORECASE == 1
                                 .endif
0001ed 38ce                          .dw XT_OVER
0001ee 3bca                          .dw XT_FETCHI ; ( -- r-addr f-addr r-cc f- cc)
                                 .if WANT_IGNORECASE == 1
                                 .endif
                                     ; flash strings are zero-padded at the last cell
                                     ; that means: if the flash cell is less $0100, than mask the
                                     ; high byte in the ram cell
0001ef 38b0                          .dw XT_DUP
                                     ;.dw XT_BYTESWAP
0001f0 383c                          .dw XT_DOLITERAL
0001f1 0100                          .dw $100
0001f2 395b                          .dw XT_ULESS
0001f3 3835                          .dw XT_DOCONDBRANCH
0001f4 01f9                          .dw PFA_ICOMPARE_LASTCELL
0001f5 38c3                          .dw XT_SWAP
0001f6 383c                          .dw XT_DOLITERAL
0001f7 00ff                          .dw $00FF
0001f8 3a12                          .dw XT_AND  ; the final swap can be omitted
                                 PFA_ICOMPARE_LASTCELL:
0001f9 3912                          .dw XT_NOTEQUAL
0001fa 3835                          .dw XT_DOCONDBRANCH
0001fb 0200                          .dw PFA_ICOMPARE_NEXTLOOP
0001fc 3ed1                          .dw XT_2DROP
0001fd 394a                          .dw XT_TRUE
0001fe 3ad3                          .dw XT_UNLOOP
0001ff 381f                          .dw XT_EXIT
                                 PFA_ICOMPARE_NEXTLOOP:
000200 3a2e                          .dw XT_1PLUS
000201 38c3                          .dw XT_SWAP
000202 3c8f                          .dw XT_CELLPLUS
000203 38c3                          .dw XT_SWAP
000204 383c                          .dw XT_DOLITERAL
000205 0002                          .dw 2
000206 3ab9                          .dw XT_DOPLUSLOOP
000207 01eb                          .dw PFA_ICOMPARE_LOOP
                                 PFA_ICOMPARE_DONE:
000208 3ed1                          .dw XT_2DROP
000209 3953                          .dw XT_ZERO
00020a 381f                          .dw XT_EXIT
                                 
                                 .if WANT_IGNORECASE == 1
                                 .endif
                                 .include "words/star.asm"
                                 
                                 ; Arithmetics
                                 ; multiply routine
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_STAR:
00020b ff01                          .dw $ff01
00020c 002a                          .db "*",0
00020d 01d4                          .dw VE_HEAD
                                     .set VE_HEAD = VE_STAR
                                 XT_STAR:
00020e 3800                          .dw DO_COLON
                                 PFA_STAR:
                                 .endif
                                 
00020f 39a5                          .dw XT_MSTAR
000210 38d8                          .dw XT_DROP
000211 381f                          .dw XT_EXIT
                                 .include "words/j.asm"
                                 
                                 ; Compiler
                                 ; loop counter of outer loop
                                 VE_J:
000212 ff01                          .dw $FF01
000213 006a                          .db "j",0
000214 020b                          .dw VE_HEAD
                                     .set VE_HEAD = VE_J
                                 XT_J:
000215 3800                          .dw DO_COLON
                                 PFA_J:
000216 3a75                          .dw XT_RP_FETCH
000217 383c                          .dw XT_DOLITERAL
000218 0007                          .dw 7
000219 399c                          .dw XT_PLUS
00021a 3878                          .dw XT_FETCH
00021b 3a75                          .dw XT_RP_FETCH
00021c 383c                          .dw XT_DOLITERAL
00021d 0009                          .dw 9
00021e 399c                          .dw XT_PLUS
00021f 3878                          .dw XT_FETCH
000220 399c                          .dw XT_PLUS
000221 381f                          .dw XT_EXIT
                                 .include "words/dabs.asm"
                                 
                                 ; Arithmetics
                                 ; double cell absolute value
                                 VE_DABS:
000222 ff04                          .dw $ff04
000223 6164
000224 7362                          .db "dabs"
000225 0212                          .dw VE_HEAD
                                     .set VE_HEAD = VE_DABS
                                 XT_DABS:
000226 3800                          .dw DO_COLON
                                 PFA_DABS:
000227 38b0                          .dw XT_DUP
000228 3920                          .dw XT_ZEROLESS
000229 3835                          .dw XT_DOCONDBRANCH
00022a 022c                          .dw PFA_DABS1
00022b 0233                          .dw XT_DNEGATE
                                 PFA_DABS1:
00022c 381f                          .dw XT_EXIT
                                 ; : dabs      ( ud1 -- +d2 ) dup 0< if dnegate then ;
                                 .include "words/dnegate.asm"
                                 
                                 ; Arithmetics
                                 ; double cell negation
                                 VE_DNEGATE:
00022d ff07                          .dw $ff07
00022e 6e64
00022f 6765
000230 7461
000231 0065                          .db "dnegate",0
000232 0222                          .dw VE_HEAD
                                     .set VE_HEAD = VE_DNEGATE
                                 XT_DNEGATE:
000233 3800                          .dw DO_COLON
                                 PFA_DNEGATE:
000234 3c3a                          .dw XT_DINVERT
000235 3fe5                          .dw XT_ONE
000236 3953                          .dw XT_ZERO
000237 3c14                          .dw XT_DPLUS
000238 381f                          .dw XT_EXIT
                                 ; : dnegate   ( ud1 -- ud2 ) dinvert 1. d+ ;
                                 .include "words/cmove.asm"
                                 
                                 ; Memory
                                 ; copy data in RAM, from lower to higher addresses
                                 VE_CMOVE:
000239 ff05                          .dw $ff05
00023a 6d63
00023b 766f
00023c 0065                          .db "cmove",0
00023d 022d                          .dw VE_HEAD
                                     .set VE_HEAD  = VE_CMOVE
                                 XT_CMOVE:
00023e 023f                          .dw PFA_CMOVE
                                 PFA_CMOVE:
00023f 93bf                          push xh
000240 93af                          push xl
000241 91e9                          ld zl, Y+
000242 91f9                          ld zh, Y+ ; addr-to
000243 91a9                          ld xl, Y+
000244 91b9                          ld xh, Y+ ; addr-from
000245 2f09                          mov temp0, tosh
000246 2b08                          or temp0, tosl
000247 f021                          brbs 1, PFA_CMOVE1
                                 PFA_CMOVE2:
000248 911d                          ld temp1, X+
000249 9311                          st Z+, temp1
00024a 9701                          sbiw tosl, 1
00024b f7e1                          brbc 1, PFA_CMOVE2
                                 PFA_CMOVE1:
00024c 91af                          pop xl
00024d 91bf                          pop xh
00024e 9189
00024f 9199                          loadtos
000250 940c 3804                     jmp_ DO_NEXT
                                 .include "words/2swap.asm"
                                 
                                 ; Stack
                                 ; Exchange the two top cell pairs
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_2SWAP:
000252 ff05                          .dw $ff05
000253 7332
000254 6177
000255 0070                          .db "2swap",0
000256 0239                          .dw VE_HEAD
                                     .set VE_HEAD = VE_2SWAP
                                 XT_2SWAP:
000257 3800                          .dw DO_COLON
                                 PFA_2SWAP:
                                 
                                 .endif
000258 38e0                          .dw XT_ROT
000259 38fe                          .dw XT_TO_R
00025a 38e0                          .dw XT_ROT
00025b 38f5                          .dw XT_R_FROM
00025c 381f                          .dw XT_EXIT
                                 .include "words/tib.asm"
                                 
                                 ; System
                                 ; refills the input buffer
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_REFILLTIB:
00025d ff0a                          .dw $ff0a
00025e 6572
00025f 6966
000260 6c6c
000261 742d
000262 6269                          .db "refill-tib"
000263 0252                          .dw VE_HEAD
                                     .set VE_HEAD = VE_REFILLTIB
                                 XT_REFILLTIB:
000264 3800                          .dw DO_COLON
                                 PFA_REFILLTIB:
                                 .endif
000265 0280                          .dw XT_TIB
000266 383c                          .dw XT_DOLITERAL
000267 005a                          .dw TIB_SIZE
000268 0498                          .dw XT_ACCEPT
000269 0286                          .dw XT_NUMBERTIB
00026a 3880                          .dw XT_STORE
00026b 3953                          .dw XT_ZERO
00026c 3ee1                          .dw XT_TO_IN
00026d 3880                          .dw XT_STORE
00026e 394a                          .dw XT_TRUE ; -1
00026f 381f                          .dw XT_EXIT
                                 
                                 ; ( -- addr n ) 
                                 ; System
                                 ; address and current length of the input buffer
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_SOURCETIB:
000270 ff0a                          .dw $FF0A
000271 6f73
000272 7275
000273 6563
000274 742d
000275 6269                          .db "source-tib"
000276 025d                          .dw VE_HEAD
                                     .set VE_HEAD = VE_SOURCETIB
                                 XT_SOURCETIB:
000277 3800                          .dw DO_COLON
                                 PFA_SOURCETIB:
                                 .endif
000278 0280                          .dw XT_TIB
000279 0286                          .dw XT_NUMBERTIB
00027a 3878                          .dw XT_FETCH
00027b 381f                          .dw XT_EXIT
                                 
                                 ; ( -- addr ) 
                                 ; System Variable
                                 ; terminal input buffer address
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_TIB:
00027c ff03                          .dw $ff03
00027d 6974
00027e 0062                          .db "tib",0
00027f 0270                          .dw VE_HEAD
                                     .set VE_HEAD = VE_TIB
                                 XT_TIB:
000280 3847                          .dw PFA_DOVARIABLE
                                 PFA_TIB:
000281 012c                          .dw ram_tib
                                 .dseg
00012c                           ram_tib: .byte TIB_SIZE
                                 .cseg
                                 .endif
                                 
                                 ; ( -- addr ) 
                                 ; System Variable
                                 ; variable holding the number of characters in TIB
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_NUMBERTIB:
000282 ff04                          .dw $ff04
000283 7423
000284 6269                          .db "#tib"
000285 027c                          .dw VE_HEAD
                                     .set VE_HEAD  = VE_NUMBERTIB
                                 XT_NUMBERTIB:
000286 3847                          .dw PFA_DOVARIABLE
                                 PFA_NUMBERTIB:
000287 0186                          .dw ram_sharptib
                                 .dseg
000186                           ram_sharptib: .byte 2
                                 .cseg
                                 .endif
                                 .include "words/init-ram.asm"
                                 
                                 ; Tools
                                 ; copy len cells from eeprom to ram
                                 VE_EE2RAM:
000288 ff06                        .dw $ff06
000289 6565
00028a 723e
00028b 6d61                        .db "ee>ram"
00028c 0282                        .dw VE_HEAD
                                   .set VE_HEAD = VE_EE2RAM
                                 XT_EE2RAM:
00028d 3800                        .dw DO_COLON
                                 PFA_EE2RAM:          ; ( -- )
00028e 3953                          .dw XT_ZERO
00028f 3a9a                          .dw XT_DODO
                                 PFA_EE2RAM_1:
                                     ; ( -- e-addr r-addr )
000290 38ce                          .dw XT_OVER
000291 3b5e                          .dw XT_FETCHE
000292 38ce                          .dw XT_OVER
000293 3880                          .dw XT_STORE
000294 3c8f                          .dw XT_CELLPLUS
000295 38c3                          .dw XT_SWAP
000296 3c8f                          .dw XT_CELLPLUS
000297 38c3                          .dw XT_SWAP
000298 3ac8                          .dw XT_DOLOOP
000299 0290                          .dw PFA_EE2RAM_1
                                 PFA_EE2RAM_2:
00029a 3ed1                          .dw XT_2DROP
00029b 381f                          .dw XT_EXIT
                                 
                                 ; ( -- )
                                 ; Tools
                                 ; setup the default user area from eeprom
                                 VE_INIT_RAM:
00029c ff08                        .dw $ff08
00029d 6e69
00029e 7469
00029f 722d
0002a0 6d61                        .db "init-ram"
0002a1 0288                        .dw VE_HEAD
                                   .set VE_HEAD = VE_INIT_RAM
                                 XT_INIT_RAM:
0002a2 3800                        .dw DO_COLON
                                 PFA_INI_RAM:          ; ( -- )
0002a3 383c                          .dw XT_DOLITERAL
0002a4 006a                          .dw EE_INITUSER
0002a5 3b01                          .dw XT_UP_FETCH
0002a6 383c                          .dw XT_DOLITERAL
0002a7 0022                          .dw SYSUSERSIZE
0002a8 3a03                          .dw XT_2SLASH
0002a9 028d                          .dw XT_EE2RAM
0002aa 381f                          .dw XT_EXIT
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 
                                 
                                 .include "words/environment.asm"
                                 
                                 ; System Value
                                 ; word list identifier of the environmental search list
                                 VE_ENVIRONMENT:
0002ab ff0b                          .dw $ff0b
0002ac 6e65
0002ad 6976
0002ae 6f72
0002af 6d6e
0002b0 6e65
0002b1 0074                          .db "environment",0
0002b2 029c                          .dw VE_HEAD
                                     .set VE_HEAD = VE_ENVIRONMENT
                                 XT_ENVIRONMENT:
0002b3 3847                          .dw PFA_DOVARIABLE
                                 PFA_ENVIRONMENT:
0002b4 0044                          .dw CFG_ENVIRONMENT
                                 .include "words/env-wordlists.asm"
                                 
                                 ; Environment
                                 ; maximum number of wordlists in the dictionary search order
                                 VE_ENVWORDLISTS:
0002b5 ff09                          .dw $ff09
0002b6 6f77
0002b7 6472
0002b8 696c
0002b9 7473
0002ba 0073                          .db "wordlists",0
0002bb 0000                          .dw VE_ENVHEAD
                                     .set VE_ENVHEAD = VE_ENVWORDLISTS
                                 XT_ENVWORDLISTS:
0002bc 3800                          .dw DO_COLON
                                 PFA_ENVWORDLISTS:
0002bd 383c                          .dw XT_DOLITERAL
0002be 0008                          .dw NUMWORDLISTS
0002bf 381f                          .dw XT_EXIT
                                 .include "words/env-slashpad.asm"
                                 
                                 ; Environment
                                 ; Size of the PAD buffer in bytes
                                 VE_ENVSLASHPAD:
0002c0 ff04                          .dw $ff04
0002c1 702f
0002c2 6461                          .db "/pad"
0002c3 02b5                          .dw VE_ENVHEAD
                                     .set VE_ENVHEAD = VE_ENVSLASHPAD
                                 XT_ENVSLASHPAD:
0002c4 3800                          .dw DO_COLON
                                 PFA_ENVSLASHPAD:
0002c5 3a8c                          .dw XT_SP_FETCH
0002c6 3ee7                          .dw XT_PAD
0002c7 3992                          .dw XT_MINUS
0002c8 381f                          .dw XT_EXIT
                                 .include "words/env-slashhold.asm"
                                 
                                 ; Environment
                                 ; size of the pictured numeric output buffer in bytes
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_ENVSLASHHOLD:
0002c9 ff05                          .dw $ff05
0002ca 682f
0002cb 6c6f
0002cc 0064                          .db "/hold",0
0002cd 02c0                          .dw VE_ENVHEAD
                                     .set VE_ENVHEAD = VE_ENVSLASHHOLD
                                 XT_ENVSLASHHOLD:
0002ce 3800                          .dw DO_COLON
                                 PFA_ENVSLASHHOLD:
                                 .endif
0002cf 3ee7                          .dw XT_PAD
0002d0 3f22                          .dw XT_HERE
0002d1 3992                          .dw XT_MINUS
0002d2 381f                          .dw XT_EXIT
                                 .include "words/env-forthname.asm"
                                 
                                 ; Environment
                                 ; flash address of the amforth name string
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_ENV_FORTHNAME:
0002d3 ff0a                          .dw $ff0a
0002d4 6f66
0002d5 7472
0002d6 2d68
0002d7 616e
0002d8 656d                          .db "forth-name"
0002d9 02c9                          .dw VE_ENVHEAD
                                     .set VE_ENVHEAD = VE_ENV_FORTHNAME
                                 XT_ENV_FORTHNAME:
0002da 3800                          .dw DO_COLON
                                 PFA_EN_FORTHNAME:
0002db 03d0                          .dw XT_DOSLITERAL
0002dc 0007                          .dw 7
                                 .endif
0002dd 6d61
0002de 6f66
0002df 7472
amforth-6.5\common\words/env-forthname.asm(22): warning: .cseg .db misalignment - padding zero byte
0002e0 0068                          .db "amforth"
                                 .if cpu_msp430==1
                                 .endif
0002e1 381f                          .dw XT_EXIT
                                 .include "words/env-forthversion.asm"
                                 
                                 ; Environment
                                 ; version number of amforth
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_ENV_FORTHVERSION:
0002e2 ff07                          .dw $ff07
0002e3 6576
0002e4 7372
0002e5 6f69
0002e6 006e                          .db "version",0
0002e7 02d3                          .dw VE_ENVHEAD
                                     .set VE_ENVHEAD = VE_ENV_FORTHVERSION
                                 XT_ENV_FORTHVERSION:
0002e8 3800                          .dw DO_COLON
                                 PFA_EN_FORTHVERSION:
                                 .endif
0002e9 383c                          .dw XT_DOLITERAL
0002ea 0041                          .dw 65
0002eb 381f                          .dw XT_EXIT
                                 .include "words/env-cpu.asm"
                                 
                                 ; Environment
                                 ; flash address of the CPU identification string
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_ENV_CPU:
0002ec ff03                          .dw $ff03
0002ed 7063
0002ee 0075                          .db "cpu",0
0002ef 02e2                          .dw VE_ENVHEAD
                                     .set VE_ENVHEAD = VE_ENV_CPU
                                 XT_ENV_CPU:
0002f0 3800                          .dw DO_COLON
                                 PFA_EN_CPU:
                                 .endif
0002f1 383c                          .dw XT_DOLITERAL
0002f2 0037                          .dw mcu_name
0002f3 042f                          .dw XT_ICOUNT
0002f4 381f                          .dw XT_EXIT
                                 .include "words/env-mcuinfo.asm"
                                 
                                 ; Environment
                                 ; flash address of some CPU specific parameters
                                 VE_ENV_MCUINFO:
0002f5 ff08                          .dw $ff08
0002f6 636d
0002f7 2d75
0002f8 6e69
0002f9 6f66                          .db "mcu-info"
0002fa 02ec                          .dw VE_ENVHEAD
                                     .set VE_ENVHEAD = VE_ENV_MCUINFO
                                 XT_ENV_MCUINFO:
0002fb 3800                          .dw DO_COLON
                                 PFA_EN_MCUINFO:
0002fc 383c                          .dw XT_DOLITERAL
0002fd 0033                          .dw mcu_info
0002fe 381f                          .dw XT_EXIT
                                 .include "words/env-usersize.asm"
                                 
                                 ; Environment
                                 ; size of the USER area in bytes
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 
                                 VE_ENVUSERSIZE:
0002ff ff05                          .dw $ff05
000300 752f
000301 6573
000302 0072                          .db "/user",0
000303 02f5                          .dw VE_ENVHEAD
                                     .set VE_ENVHEAD = VE_ENVUSERSIZE
                                 XT_ENVUSERSIZE:
000304 3800                          .dw DO_COLON
                                 PFA_ENVUSERSIZE:
                                 .endif
000305 383c                          .dw XT_DOLITERAL
000306 002c                          .dw SYSUSERSIZE + APPUSERSIZE
000307 381f                          .dw XT_EXIT
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 .include "words/hld.asm"
                                 
                                 ; Numeric IO
                                 ; pointer to current write position in the Pictured Numeric Output buffer
                                 VE_HLD:
000308 ff03                          .dw $ff03
000309 6c68
00030a 0064                          .db "hld",0
00030b 02ab                          .dw VE_HEAD
                                     .set VE_HEAD = VE_HLD
                                 XT_HLD:
00030c 3847                          .dw PFA_DOVARIABLE
                                 PFA_HLD:
00030d 0188                          .dw ram_hld
                                 
                                 .dseg
000188                           ram_hld: .byte 2
                                 .cseg
                                 .include "words/hold.asm"
                                 
                                 ; Numeric IO
                                 ; prepend character to pictured numeric output buffer
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_HOLD:
00030e ff04                          .dw $ff04
00030f 6f68
000310 646c                          .db "hold"
000311 0308                          .dw VE_HEAD
                                     .set VE_HEAD = VE_HOLD
                                 XT_HOLD:
000312 3800                          .dw DO_COLON
                                 PFA_HOLD:
                                 .endif
000313 030c                          .dw XT_HLD
000314 38b0                          .dw XT_DUP
000315 3878                          .dw XT_FETCH
000316 3a34                          .dw XT_1MINUS
000317 38b0                          .dw XT_DUP
000318 38fe                          .dw XT_TO_R
000319 38c3                          .dw XT_SWAP
00031a 3880                          .dw XT_STORE
00031b 38f5                          .dw XT_R_FROM
00031c 388c                          .dw XT_CSTORE
00031d 381f                          .dw XT_EXIT
                                 .include "words/less-sharp.asm" ; <#
                                 
                                 ; Numeric IO
                                 ; initialize the pictured numeric output conversion process
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_L_SHARP:
00031e ff02                          .dw $ff02
00031f 233c                          .db "<#"
000320 030e                          .dw VE_HEAD
                                     .set VE_HEAD = VE_L_SHARP
                                 XT_L_SHARP:
000321 3800                          .dw DO_COLON
                                 PFA_L_SHARP:
                                 .endif
000322 3ee7                          .dw XT_PAD
000323 030c                          .dw XT_HLD
000324 3880                          .dw XT_STORE
000325 381f                          .dw XT_EXIT
                                 .include "words/sharp.asm"
                                 
                                 ; Numeric IO
                                 ; pictured numeric output: convert one digit
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 
                                 
                                 VE_SHARP:
000326 ff01                          .dw $ff01
000327 0023                          .db "#",0
000328 031e                          .dw VE_HEAD
                                     .set VE_HEAD = VE_SHARP
                                 XT_SHARP:
000329 3800                          .dw DO_COLON
                                 PFA_SHARP:
                                 .endif
00032a 3ebc                          .dw XT_BASE
00032b 3878                          .dw XT_FETCH
00032c 03a6                          .dw XT_UDSLASHMOD
00032d 38e0                          .dw XT_ROT
00032e 383c                          .dw XT_DOLITERAL
00032f 0009                          .dw 9
000330 38ce                          .dw XT_OVER
000331 396d                          .dw XT_LESS
000332 3835                          .dw XT_DOCONDBRANCH
000333 0337                          DEST(PFA_SHARP1)
000334 383c                          .dw XT_DOLITERAL
000335 0007                          .dw 7
000336 399c                          .dw XT_PLUS
                                 PFA_SHARP1:
000337 383c                          .dw XT_DOLITERAL
000338 0030                          .dw 48 ; ASCII 0
000339 399c                          .dw XT_PLUS
00033a 0312                          .dw XT_HOLD
00033b 381f                          .dw XT_EXIT
                                 ; : #    ( ud1 -- ud2 ) 
                                 ;        base @ ud/mod rot 9 over < if 7 + then 30 + hold ; 
                                 .include "words/sharp-s.asm"
                                 
                                 ; Numeric IO
                                 ; pictured numeric output: convert all digits until 0 (zero) is reached
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_SHARP_S:
00033c ff02                          .dw $ff02
00033d 7323                          .db "#s"
00033e 0326                          .dw VE_HEAD
                                     .set VE_HEAD = VE_SHARP_S
                                 XT_SHARP_S:
00033f 3800                          .dw DO_COLON
                                 PFA_SHARP_S:
                                 .endif
                                 NUMS1:
000340 0329                          .dw XT_SHARP
000341 3ec8                          .dw XT_2DUP
000342 3a1b                          .dw XT_OR
000343 3919                          .dw XT_ZEROEQUAL
000344 3835                          .dw XT_DOCONDBRANCH
000345 0340                          DEST(NUMS1) ; PFA_SHARP_S
000346 381f                          .dw XT_EXIT
                                 .include "words/sharp-greater.asm" ; #>
                                 
                                 ; Numeric IO
                                 ; Pictured Numeric Output: convert PNO buffer into an string
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_SHARP_G:
000347 ff02                          .dw $ff02
000348 3e23                          .db "#>"
000349 033c                          .dw VE_HEAD
                                     .set VE_HEAD = VE_SHARP_G
                                 XT_SHARP_G:
00034a 3800                          .dw DO_COLON
                                 PFA_SHARP_G:
                                 .endif
00034b 3ed1                          .dw XT_2DROP
00034c 030c                          .dw XT_HLD
00034d 3878                          .dw XT_FETCH
00034e 3ee7                          .dw XT_PAD
00034f 38ce                          .dw XT_OVER
000350 3992                          .dw XT_MINUS
000351 381f                          .dw XT_EXIT
                                 .include "words/sign.asm"
                                 
                                 ; Numeric IO
                                 ; place a - in HLD if n is negative
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_SIGN:
000352 ff04                          .dw $ff04
000353 6973
000354 6e67                          .db "sign"
000355 0347                          .dw VE_HEAD
                                     .set VE_HEAD = VE_SIGN
                                 XT_SIGN:
000356 3800                          .dw DO_COLON
                                 PFA_SIGN:
                                 .endif
000357 3920                          .dw XT_ZEROLESS
000358 3835                          .dw XT_DOCONDBRANCH
000359 035d                          DEST(PFA_SIGN1)
00035a 383c                          .dw XT_DOLITERAL
00035b 002d                          .dw 45 ; ascii -
00035c 0312                          .dw XT_HOLD
                                 PFA_SIGN1:
00035d 381f                          .dw XT_EXIT
                                 .include "words/d-dot-r.asm"
                                 
                                 ; Numeric IO
                                 ; singed PNO with double cell numbers, right aligned in width w
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_DDOTR:
00035e ff03                          .dw $ff03
00035f 2e64
000360 0072                          .db "d.r",0
000361 0352                          .dw VE_HEAD
                                     .set VE_HEAD = VE_DDOTR
                                 XT_DDOTR:
000362 3800                          .dw DO_COLON
                                 PFA_DDOTR:
                                 
                                 .endif
000363 38fe                          .dw XT_TO_R
000364 3ed9                          .dw XT_TUCK
000365 0226                          .dw XT_DABS
000366 0321                          .dw XT_L_SHARP
000367 033f                          .dw XT_SHARP_S
000368 38e0                          .dw XT_ROT
000369 0356                          .dw XT_SIGN
00036a 034a                          .dw XT_SHARP_G
00036b 38f5                          .dw XT_R_FROM
00036c 38ce                          .dw XT_OVER
00036d 3992                          .dw XT_MINUS
00036e 3fb6                          .dw XT_SPACES
00036f 0439                          .dw XT_TYPE
000370 381f                          .dw XT_EXIT
                                 ; : d.r       ( d n -- )
                                 ;             >r swap over dabs <# #s rot sign #> r> over - spaces type ;
                                 .include "words/dot-r.asm"
                                 
                                 ; Numeric IO
                                 ; singed PNO with single cell numbers, right aligned in width w
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_DOTR:
000371 ff02                          .dw $ff02
000372 722e                          .db ".r"
000373 035e                          .dw VE_HEAD
                                     .set VE_HEAD = VE_DOTR
                                 XT_DOTR:
000374 3800                          .dw DO_COLON
                                 PFA_DOTR:
                                 
                                 .endif
000375 38fe                          .dw XT_TO_R
000376 3fc6                          .dw XT_S2D
000377 38f5                          .dw XT_R_FROM
000378 0362                          .dw XT_DDOTR
000379 381f                          .dw XT_EXIT
                                 ; : .r        ( s n -- )  >r s>d r> d.r ;
                                 .include "words/d-dot.asm"
                                 
                                 ; Numeric IO
                                 ; singed PNO with double cell numbers
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_DDOT:
00037a ff02                          .dw $ff02
00037b 2e64                          .db "d."
00037c 0371                          .dw VE_HEAD
                                     .set VE_HEAD = VE_DDOT
                                 XT_DDOT:
00037d 3800                          .dw DO_COLON
                                 PFA_DDOT:
                                 
                                 .endif
00037e 3953                          .dw XT_ZERO
00037f 0362                          .dw XT_DDOTR
000380 3fad                          .dw XT_SPACE
000381 381f                          .dw XT_EXIT
                                 ; : d.        ( d -- )    0 d.r space ;
                                 .include "words/dot.asm"
                                 
                                 ; Numeric IO
                                 ; singed PNO with single cell numbers
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 
                                 
                                 VE_DOT:
000382 ff01                          .dw $ff01
000383 002e                          .db ".",0
000384 037a                          .dw VE_HEAD
                                     .set VE_HEAD = VE_DOT
                                 XT_DOT:
000385 3800                          .dw DO_COLON
                                 PFA_DOT:
                                 .endif
000386 3fc6                          .dw XT_S2D
000387 037d                          .dw XT_DDOT
000388 381f                          .dw XT_EXIT
                                 ; : .         ( s -- )    s>d d. ; 
                                 .include "words/ud-dot.asm"
                                 
                                 ; Numeric IO
                                 ; unsigned PNO with double cell numbers
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_UDDOT:
000389 ff03                          .dw $ff03
00038a 6475
00038b 002e                          .db "ud.",0
00038c 0382                          .dw VE_HEAD
                                     .set VE_HEAD = VE_UDDOT
                                 XT_UDDOT:
00038d 3800                          .dw DO_COLON
                                 PFA_UDDOT:
                                 .endif
00038e 3953                          .dw XT_ZERO
00038f 0396                          .dw XT_UDDOTR
000390 3fad                          .dw XT_SPACE
000391 381f                          .dw XT_EXIT
                                 .include "words/ud-dot-r.asm"
                                 
                                 ; Numeric IO
                                 ; unsigned PNO with double cell numbers, right aligned in width w
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 
                                 
                                 VE_UDDOTR:
000392 ff04                          .dw $ff04
000393 6475
000394 722e                          .db "ud.r"
000395 0389                          .dw VE_HEAD
                                     .set VE_HEAD = VE_UDDOTR
                                 XT_UDDOTR:
000396 3800                          .dw DO_COLON
                                 PFA_UDDOTR:
                                 .endif
000397 38fe                          .dw XT_TO_R
000398 0321                          .dw XT_L_SHARP
000399 033f                          .dw XT_SHARP_S
00039a 034a                          .dw XT_SHARP_G
00039b 38f5                          .dw XT_R_FROM
00039c 38ce                          .dw XT_OVER
00039d 3992                          .dw XT_MINUS
00039e 3fb6                          .dw XT_SPACES
00039f 0439                          .dw XT_TYPE
0003a0 381f                          .dw XT_EXIT
                                 .include "words/ud-slash-mod.asm"
                                 
                                 ; Arithmetics
                                 ; unsigned double cell division with remainder
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_UDSLASHMOD:
0003a1 ff06                          .dw $ff06
0003a2 6475
0003a3 6d2f
0003a4 646f                          .db "ud/mod"
0003a5 0392                          .dw VE_HEAD
                                     .set VE_HEAD = VE_UDSLASHMOD
                                 XT_UDSLASHMOD:
0003a6 3800                          .dw DO_COLON
                                 PFA_UDSLASHMOD:
                                 .endif
0003a7 38fe                          .dw XT_TO_R
0003a8 3953                          .dw XT_ZERO
0003a9 3907                          .dw XT_R_FETCH
0003aa 39c1                          .dw XT_UMSLASHMOD
0003ab 38f5                          .dw XT_R_FROM
0003ac 38c3                          .dw XT_SWAP
0003ad 38fe                          .dw XT_TO_R
0003ae 39c1                          .dw XT_UMSLASHMOD
0003af 38f5                          .dw XT_R_FROM
0003b0 381f                          .dw XT_EXIT
                                 .include "words/digit-q.asm"
                                 
                                 ; Numeric IO
                                 ; tries to convert a character to a number, set flag accordingly
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_DIGITQ:
0003b1 ff06                          .dw $ff06 
0003b2 6964
0003b3 6967
0003b4 3f74                          .db "digit?"
0003b5 03a1                          .dw VE_HEAD
                                     .set VE_HEAD = VE_DIGITQ
                                 XT_DIGITQ:
0003b6 3800                          .dw DO_COLON 
                                 PFA_DIGITQ:
                                 .endif
0003b7 3f65                          .dw XT_TOUPPER
0003b8 38b0
0003b9 383c
0003ba 0039
0003bb 3977
0003bc 383c
0003bd 0100                          .DW XT_DUP,XT_DOLITERAL,57,XT_GREATER,XT_DOLITERAL,256
0003be 3a12
0003bf 399c
0003c0 38b0
0003c1 383c
0003c2 0140
0003c3 3977                          .DW XT_AND,XT_PLUS,XT_DUP,XT_DOLITERAL,320,XT_GREATER
0003c4 383c
0003c5 0107
0003c6 3a12
0003c7 3992
0003c8 383c
0003c9 0030                          .DW XT_DOLITERAL,263,XT_AND,XT_MINUS,XT_DOLITERAL,48
0003ca 3992
0003cb 38b0
0003cc 3ebc
0003cd 3878
0003ce 395b                          .DW XT_MINUS,XT_DUP,XT_BASE,XT_FETCH,XT_ULESS
0003cf 381f                          .DW XT_EXIT
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 .include "words/do-sliteral.asm"
                                 
                                 ; String
                                 ; runtime portion of sliteral
                                 ;VE_DOSLITERAL:
                                 ;  .dw $ff0a
                                 ;  .db "(sliteral)"
                                 ;  .dw VE_HEAD
                                 ;  .set VE_HEAD = VE_DOSLITERAL
                                 XT_DOSLITERAL:
0003d0 3800                        .dw DO_COLON
                                 PFA_DOSLITERAL:
0003d1 3907                        .dw XT_R_FETCH   ; ( -- addr )
0003d2 042f                        .dw XT_ICOUNT
0003d3 38f5                        .dw XT_R_FROM
0003d4 38ce                        .dw XT_OVER     ; ( -- addr' n addr n)
0003d5 3a2e                        .dw XT_1PLUS
0003d6 3a03                        .dw XT_2SLASH   ; ( -- addr' n addr k )
0003d7 399c                        .dw XT_PLUS     ; ( -- addr' n addr'' )
0003d8 3a2e                        .dw XT_1PLUS
0003d9 38fe                        .dw XT_TO_R     ; ( -- )
0003da 381f                        .dw XT_EXIT
                                 .include "words/scomma.asm"
                                 
                                 ; Compiler
                                 ; compiles a string from RAM to Flash
                                 VE_SCOMMA:
0003db ff02                        .dw $ff02
0003dc 2c73                        .db "s",$2c
0003dd 03b1                        .dw VE_HEAD
                                   .set VE_HEAD = VE_SCOMMA
                                 XT_SCOMMA:
0003de 3800                          .dw DO_COLON
                                 PFA_SCOMMA:
0003df 38b0                          .dw XT_DUP
0003e0 03e2                          .dw XT_DOSCOMMA
0003e1 381f                          .dw XT_EXIT
                                 
                                 ; ( addr len len' -- ) 
                                 ; Compiler
                                 ; compiles a string from RAM to Flash
                                 ;VE_DOSCOMMA:
                                 ;  .dw $ff04
                                 ;  .db "(s",$2c,")"
                                 ;  .dw VE_HEAD
                                 ;  .set VE_HEAD = VE_DOSCOMMA
                                 XT_DOSCOMMA:
0003e2 3800                          .dw DO_COLON
                                 PFA_DOSCOMMA:
0003e3 0767                          .dw XT_COMMA
0003e4 38b0                          .dw XT_DUP   ; ( --addr len len)
0003e5 3a03                          .dw XT_2SLASH ; ( -- addr len len/2
0003e6 3ed9                          .dw XT_TUCK   ; ( -- addr len/2 len len/2
0003e7 3a0a                          .dw XT_2STAR  ; ( -- addr len/2 len len'
0003e8 3992                          .dw XT_MINUS  ; ( -- addr len/2 rem
0003e9 38fe                          .dw XT_TO_R
0003ea 3953                          .dw XT_ZERO
0003eb 0826                          .dw XT_QDOCHECK
0003ec 3835                          .dw XT_DOCONDBRANCH
0003ed 03f5                          .dw PFA_SCOMMA2
0003ee 3a9a                          .dw XT_DODO
                                 PFA_SCOMMA1:
0003ef 38b0                          .dw XT_DUP         ; ( -- addr addr )
0003f0 3878                          .dw XT_FETCH       ; ( -- addr c1c2 )
0003f1 0767                          .dw XT_COMMA       ; ( -- addr )
0003f2 3c8f                          .dw XT_CELLPLUS    ; ( -- addr+cell )
0003f3 3ac8                          .dw XT_DOLOOP
0003f4 03ef                          .dw PFA_SCOMMA1
                                 PFA_SCOMMA2:
0003f5 38f5                          .dw XT_R_FROM
0003f6 3927                          .dw XT_GREATERZERO
0003f7 3835                          .dw XT_DOCONDBRANCH
0003f8 03fc                          .dw PFA_SCOMMA3
0003f9 38b0                            .dw XT_DUP     ; well, tricky
0003fa 3897                            .dw XT_CFETCH
0003fb 0767                            .dw XT_COMMA
                                 PFA_SCOMMA3:
0003fc 38d8                          .dw XT_DROP        ; ( -- )
0003fd 381f                          .dw XT_EXIT
                                 .include "words/itype.asm"
                                 
                                 ; Tools
                                 ; reads string from flash and prints it
                                 VE_ITYPE:
0003fe ff05                          .dw $ff05
0003ff 7469
000400 7079
000401 0065                          .db "itype",0
000402 03db                          .dw VE_HEAD
                                     .set VE_HEAD = VE_ITYPE
                                 XT_ITYPE:
000403 3800                          .dw DO_COLON
                                 PFA_ITYPE:
000404 38b0                          .dw XT_DUP    ; ( --addr len len)
000405 3a03                          .dw XT_2SLASH ; ( -- addr len len/2
000406 3ed9                          .dw XT_TUCK   ; ( -- addr len/2 len len/2
000407 3a0a                          .dw XT_2STAR  ; ( -- addr len/2 len len'
000408 3992                          .dw XT_MINUS  ; ( -- addr len/2 rem
000409 38fe                          .dw XT_TO_R
00040a 3953                          .dw XT_ZERO
00040b 0826                          .dw XT_QDOCHECK
00040c 3835                          .dw XT_DOCONDBRANCH
00040d 0417                          .dw PFA_ITYPE2
00040e 3a9a                          .dw XT_DODO
                                 PFA_ITYPE1:
00040f 38b0                          .dw XT_DUP         ; ( -- addr addr )
000410 3bca                          .dw XT_FETCHI      ; ( -- addr c1c2 )
000411 38b0                          .dw XT_DUP
000412 0424                          .dw XT_LOWEMIT
000413 0420                          .dw XT_HIEMIT
000414 3a2e                          .dw XT_1PLUS    ; ( -- addr+cell )
000415 3ac8                          .dw XT_DOLOOP
000416 040f                          .dw PFA_ITYPE1
                                 PFA_ITYPE2:
000417 38f5                          .dw XT_R_FROM
000418 3927                          .dw XT_GREATERZERO
000419 3835                          .dw XT_DOCONDBRANCH
00041a 041e                          .dw PFA_ITYPE3
00041b 38b0                            .dw XT_DUP     ; make sure the drop below has always something to do
00041c 3bca                            .dw XT_FETCHI
00041d 0424                            .dw XT_LOWEMIT
                                 PFA_ITYPE3:
00041e 38d8                          .dw XT_DROP
00041f 381f                          .dw XT_EXIT
                                 
                                 ; ( w -- )
                                 ; R( -- )
                                 ; content of cell fetched on stack.
                                 ;VE_HIEMIT:
                                 ;    .dw $ff06
                                 ;    .db "hiemit"
                                 ;    .dw VE_HEAD
                                 ;    .set VE_HEAD = VE_HIEMIT
                                 XT_HIEMIT:
000420 3800                          .dw DO_COLON
                                 PFA_HIEMIT:
000421 3af8                          .dw XT_BYTESWAP
000422 0424                          .dw XT_LOWEMIT
000423 381f                          .dw XT_EXIT
                                 
                                 ; ( w -- )
                                 ; R( -- )
                                 ; content of cell fetched on stack.
                                 ;VE_LOWEMIT:
                                 ;    .dw $ff07
                                 ;    .db "lowemit"
                                 ;    .dw VE_HEAD
                                 ;    .set VE_HEAD = VE_LOWEMIT
                                 XT_LOWEMIT:
000424 3800                          .dw DO_COLON
                                 PFA_LOWEMIT:
000425 383c                          .dw XT_DOLITERAL
000426 00ff                          .dw $00ff
000427 3a12                          .dw XT_AND
000428 3ef1                          .dw XT_EMIT
000429 381f                          .dw XT_EXIT
                                 .include "words/icount.asm"
                                 
                                 ; Tools
                                 ; get count information out of a counted string in flash
                                 VE_ICOUNT:
00042a ff06                          .dw $ff06
00042b 6369
00042c 756f
00042d 746e                          .db "icount"
00042e 03fe                          .dw VE_HEAD
                                     .set VE_HEAD = VE_ICOUNT
                                 XT_ICOUNT:
00042f 3800                          .dw DO_COLON
                                 PFA_ICOUNT:
000430 38b0                          .dw XT_DUP
000431 3a2e                          .dw XT_1PLUS
000432 38c3                          .dw XT_SWAP
000433 3bca                          .dw XT_FETCHI
000434 381f                          .dw XT_EXIT
                                 .include "words/type.asm"
                                 
                                 ; Character IO
                                 ; print a RAM based string
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_TYPE:
000435 ff04                          .dw $ff04
000436 7974
000437 6570                          .db "type"
000438 042a                          .dw VE_HEAD
                                     .set VE_HEAD = VE_TYPE
                                 XT_TYPE:
000439 3800                          .dw DO_COLON
                                 PFA_TYPE:
                                 
                                 .endif
00043a 3f98                          .dw XT_BOUNDS
00043b 0826                          .dw XT_QDOCHECK
00043c 3835                          .dw XT_DOCONDBRANCH
00043d 0444                          DEST(PFA_TYPE2)
00043e 3a9a                          .dw XT_DODO
                                 PFA_TYPE1:
00043f 3aab                          .dw XT_I
000440 3897                          .dw XT_CFETCH
000441 3ef1                          .dw XT_EMIT
000442 3ac8                          .dw XT_DOLOOP
000443 043f                          DEST(PFA_TYPE1)
                                 PFA_TYPE2:
000444 381f                          .dw XT_EXIT
                                 .include "words/tick.asm"
                                 
                                 ; Dictionary
                                 ; search dictionary for name, return XT or throw an exception -13
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_TICK:
000445 ff01                          .dw $ff01
000446 0027                          .db "'",0
000447 0435                          .dw VE_HEAD
                                     .set VE_HEAD = VE_TICK
                                 XT_TICK:
000448 3800                          .dw DO_COLON
                                 PFA_TICK:
                                 .endif
000449 05bb                          .dw XT_PARSENAME
00044a 05fe                          .dw XT_FORTHRECOGNIZER
00044b 0609                          .dw XT_RECOGNIZE
                                     ; a word is tickable unless DT:TOKEN is DT:NULL or 
                                     ; the interpret action is a NOOP
00044c 38b0                          .dw XT_DUP
00044d 0696                          .dw XT_DT_NULL
00044e 3fde                          .dw XT_EQUAL
00044f 38c3                          .dw XT_SWAP
000450 3bca                          .dw XT_FETCHI
000451 383c                          .dw XT_DOLITERAL
000452 01a5                          .dw XT_NOOP
000453 3fde                          .dw XT_EQUAL
000454 3a1b                          .dw XT_OR
000455 3835                          .dw XT_DOCONDBRANCH
000456 045a                          DEST(PFA_TICK1)
000457 383c                            .dw XT_DOLITERAL
000458 fff3                            .dw -13
000459 3d85                            .dw XT_THROW
                                 PFA_TICK1:
00045a 38d8                          .dw XT_DROP
00045b 381f                          .dw XT_EXIT
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 .include "words/cskip.asm"
                                 
                                 ; String
                                 ; skips leading occurancies in string at addr1/n1 leaving addr2/n2 pointing to the 1st non-c character
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_CSKIP:
00045c ff05                          .dw $ff05
00045d 7363
00045e 696b
00045f 0070                          .db "cskip",0
000460 0445                          .dw VE_HEAD
                                     .set VE_HEAD = VE_CSKIP
                                 XT_CSKIP:
000461 3800                          .dw DO_COLON
                                 PFA_CSKIP:
                                 .endif
000462 38fe                          .dw XT_TO_R           ; ( -- addr1 n1 )
                                 PFA_CSKIP1:
000463 38b0                          .dw XT_DUP            ; ( -- addr' n' n' )
000464 3835                          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
000465 0470                          DEST(PFA_CSKIP2)
000466 38ce                          .dw XT_OVER           ; ( -- addr' n' addr' )
000467 3897                          .dw XT_CFETCH         ; ( -- addr' n' c' )
000468 3907                          .dw XT_R_FETCH        ; ( -- addr' n' c' c )
000469 3fde                          .dw XT_EQUAL          ; ( -- addr' n' f )
00046a 3835                          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
00046b 0470                          DEST(PFA_CSKIP2)
00046c 3fe5                          .dw XT_ONE
00046d 05ac                          .dw XT_SLASHSTRING
00046e 382e                          .dw XT_DOBRANCH
00046f 0463                          DEST(PFA_CSKIP1)
                                 PFA_CSKIP2:
000470 38f5                          .dw XT_R_FROM
000471 38d8                          .dw XT_DROP           ; ( -- addr2 n2)
000472 381f                          .dw XT_EXIT
                                 .include "words/cscan.asm"
                                 
                                 ; String
                                 ; Scan string at addr1/n1 for the first occurance of c, leaving addr1/n2, char at n2 is first non-c character
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_CSCAN:
000473 ff05                          .dw $ff05
000474 7363
000475 6163
amforth-6.5\common\words/cscan.asm(12): warning: .cseg .db misalignment - padding zero byte
000476 006e                          .db "cscan"
000477 045c                          .dw VE_HEAD
                                     .set VE_HEAD = VE_CSCAN
                                 XT_CSCAN:
000478 3800                          .dw DO_COLON
                                 PFA_CSCAN:
                                 .endif
000479 38fe                          .dw XT_TO_R
00047a 38ce                          .dw XT_OVER
                                 PFA_CSCAN1:
00047b 38b0                          .dw XT_DUP
00047c 3897                          .dw XT_CFETCH
00047d 3907                          .dw XT_R_FETCH
00047e 3fde                          .dw XT_EQUAL
00047f 3919                          .dw XT_ZEROEQUAL
000480 3835                          .dw XT_DOCONDBRANCH
000481 048d                          DEST(PFA_CSCAN2)
000482 38c3                            .dw XT_SWAP
000483 3a34                            .dw XT_1MINUS
000484 38c3                            .dw XT_SWAP
000485 38ce                            .dw XT_OVER
000486 3920                            .dw XT_ZEROLESS ; not negative
000487 3919                            .dw XT_ZEROEQUAL
000488 3835                            .dw XT_DOCONDBRANCH
000489 048d                            DEST(PFA_CSCAN2)
00048a 3a2e                              .dw XT_1PLUS
00048b 382e                              .dw XT_DOBRANCH
00048c 047b                              DEST(PFA_CSCAN1)
                                 PFA_CSCAN2:
00048d 38ef                          .dw XT_NIP
00048e 38ce                          .dw XT_OVER
00048f 3992                          .dw XT_MINUS
000490 38f5                          .dw XT_R_FROM
000491 38d8                          .dw XT_DROP
000492 381f                          .dw XT_EXIT
                                 
                                 ; : my-cscan ( addr len c -- addr len' )
                                 ;    >r over ( -- addr len addr )
                                 ;    begin
                                 ;      dup c@ r@ <> while
                                 ;       swap 1- swap over 0 >=  while
                                 ;        1+ 
                                 ;     repeat then
                                 ;     nip over - r> drop 
                                 ; ;
                                 .include "words/accept.asm"
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_ACCEPT:
000493 ff06                          .dw $ff06
000494 6361
000495 6563
000496 7470                          .db "accept"
000497 0473                          .dw VE_HEAD
                                     .set VE_HEAD = VE_ACCEPT
                                 XT_ACCEPT:
000498 3800                          .dw DO_COLON
                                 PFA_ACCEPT:
                                 
                                 .endif
000499 38ce
00049a 399c
00049b 3a34
00049c 38ce                              .DW XT_OVER,XT_PLUS,XT_1MINUS,XT_OVER
00049d 3f02
00049e 38b0
00049f 04d9
0004a0 3919
0004a1 3835                      ACC1:   .DW XT_KEY,XT_DUP,XT_CRLFQ,XT_ZEROEQUAL,XT_DOCONDBRANCH
0004a2 04cb                              DEST(ACC5)
0004a3 38b0
0004a4 383c
0004a5 0008
0004a6 3fde
0004a7 3835                              .DW XT_DUP,XT_DOLITERAL,8,XT_EQUAL,XT_DOCONDBRANCH
0004a8 04bb                              DEST(ACC3)
0004a9 38d8
0004aa 38e0
0004ab 3ec8
0004ac 3977
0004ad 38fe
0004ae 38e0
0004af 38e0
0004b0 38f5
0004b1 3835                              .DW XT_DROP,XT_ROT,XT_2DUP,XT_GREATER,XT_TO_R,XT_ROT,XT_ROT,XT_R_FROM,XT_DOCONDBRANCH
0004b2 04b9                      	DEST(ACC6)
0004b3 04d1
0004b4 3a34
0004b5 38fe
0004b6 38ce
0004b7 38f5
0004b8 015a                      	.DW XT_BS,XT_1MINUS,XT_TO_R,XT_OVER,XT_R_FROM,XT_UMAX
0004b9 382e                      ACC6:   .DW XT_DOBRANCH
0004ba 04c9                              DEST(ACC4)
                                     
                                 
                                 ACC3:    ; check for remaining control characters, replace them with blank
0004bb 38b0                      	.dw XT_DUP            ; ( -- addr k k )
0004bc 3f53                              .dw XT_BL
0004bd 396d                              .dw XT_LESS
0004be 3835                              .dw XT_DOCONDBRANCH
0004bf 04c2                              DEST(PFA_ACCEPT6)
0004c0 38d8                              .dw XT_DROP
0004c1 3f53                              .dw XT_BL
                                 PFA_ACCEPT6:
0004c2 38b0
0004c3 3ef1
0004c4 38ce
0004c5 388c
0004c6 3a2e
0004c7 38ce
0004c8 0166                      	.DW XT_DUP,XT_EMIT,XT_OVER,XT_CSTORE,XT_1PLUS,XT_OVER,XT_UMIN
0004c9 382e                      ACC4:   .DW XT_DOBRANCH
0004ca 049d                              DEST(ACC1)
0004cb 38d8
0004cc 38ef
0004cd 38c3
0004ce 3992
0004cf 3fa0
0004d0 381f                      ACC5:   .DW XT_DROP,XT_NIP,XT_SWAP,XT_MINUS,XT_CR,XT_EXIT
                                 
                                 
                                 ; ( --  ) 
                                 ; System
                                 ; send a backspace character to overwrite the current char
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 
                                 ;VE_BS:
                                 ;    .dw $ff02
                                 ;    .db "bs"
                                 ;    .dw VE_HEAD
                                 ;    .set VE_HEAD = VE_BS
                                 XT_BS:
0004d1 3800                          .dw DO_COLON
                                 .endif
0004d2 383c                          .dw XT_DOLITERAL
0004d3 0008                          .dw 8
0004d4 38b0                          .dw XT_DUP
0004d5 3ef1                          .dw XT_EMIT
0004d6 3fad                          .dw XT_SPACE
0004d7 3ef1                          .dw XT_EMIT
0004d8 381f                          .dw XT_EXIT
                                 
                                 
                                 ; ( c -- f ) 
                                 ; System
                                 ; is the character a line end character?
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 ;VE_CRLFQ:
                                 ;    .dw $ff02
                                 ;    .db "crlf?"
                                 ;    .dw VE_HEAD
                                 ;    .set VE_HEAD = VE_CRLFQ
                                 XT_CRLFQ:
0004d9 3800                          .dw DO_COLON
                                 .endif
0004da 38b0                          .dw XT_DUP
0004db 383c                          .dw XT_DOLITERAL
0004dc 000d                          .dw 13
0004dd 3fde                          .dw XT_EQUAL
0004de 38c3                          .dw XT_SWAP
0004df 383c                          .dw XT_DOLITERAL
0004e0 000a                          .dw 10
0004e1 3fde                          .dw XT_EQUAL
0004e2 3a1b                          .dw XT_OR
0004e3 381f                          .dw XT_EXIT
                                 .include "words/refill.asm"
                                 
                                 ; System
                                 ; refills the input buffer
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_REFILL:
0004e4 ff06                          .dw $ff06
0004e5 6572
0004e6 6966
0004e7 6c6c                          .db "refill"
0004e8 0493                          .dw VE_HEAD
                                     .set VE_HEAD = VE_REFILL
                                 XT_REFILL:
0004e9 3dfe                          .dw PFA_DODEFER1
                                 PFA_REFILL:
                                 .endif
0004ea 001a                          .dw USER_REFILL
0004eb 3dc7                          .dw XT_UDEFERFETCH
0004ec 3dd3                          .dw XT_UDEFERSTORE
                                 .include "words/char.asm"
                                 
                                 ; Tools
                                 ; copy the first character of the next word onto the stack
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_CHAR:
0004ed ff04                          .dw $ff04
0004ee 6863
0004ef 7261                          .db "char"
0004f0 04e4                          .dw VE_HEAD
                                     .set VE_HEAD = VE_CHAR
                                 XT_CHAR:
0004f1 3800                          .dw DO_COLON
                                 PFA_CHAR:
                                 .endif
0004f2 05bb                          .dw XT_PARSENAME
0004f3 38d8                          .dw XT_DROP
0004f4 3897                          .dw XT_CFETCH
0004f5 381f                          .dw XT_EXIT
                                 .include "words/number.asm"
                                 
                                 ; Numeric IO
                                 ; convert a string at addr to a number
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_NUMBER:
0004f6 ff06                          .dw $ff06
0004f7 756e
0004f8 626d
0004f9 7265                          .db "number"
0004fa 04ed                          .dw VE_HEAD
                                     .set VE_HEAD = VE_NUMBER
                                 XT_NUMBER:
0004fb 3800                          .dw DO_COLON
                                 PFA_NUMBER:
                                 .endif
0004fc 3ebc                          .dw XT_BASE
0004fd 3878                          .dw XT_FETCH
0004fe 38fe                          .dw XT_TO_R
0004ff 053f                          .dw XT_QSIGN
000500 38fe                          .dw XT_TO_R
000501 0552                          .dw XT_SET_BASE
000502 053f                          .dw XT_QSIGN
000503 38f5                          .dw XT_R_FROM
000504 3a1b                          .dw XT_OR
000505 38fe                          .dw XT_TO_R
                                     ; check whether something is left
000506 38b0                          .dw XT_DUP
000507 3919                          .dw XT_ZEROEQUAL
000508 3835                          .dw XT_DOCONDBRANCH
000509 0512                          DEST(PFA_NUMBER0)
                                       ; nothing is left. It cannot be a number at all
00050a 3ed1                            .dw XT_2DROP
00050b 38f5                            .dw XT_R_FROM
00050c 38d8                            .dw XT_DROP
00050d 38f5                            .dw XT_R_FROM
00050e 3ebc                            .dw XT_BASE
00050f 3880                            .dw XT_STORE
000510 3953                            .dw XT_ZERO
000511 381f                            .dw XT_EXIT
                                 PFA_NUMBER0:
000512 3b1d                          .dw XT_2TO_R
000513 3953                          .dw XT_ZERO       ; starting value
000514 3953                          .dw XT_ZERO
000515 3b2c                          .dw XT_2R_FROM
000516 0570                          .dw XT_TO_NUMBER ; ( 0. addr len -- d addr' len'
                                     ; check length of the remaining string.
                                     ; if zero: a single cell number is entered
000517 38b8                          .dw XT_QDUP
000518 3835                          .dw XT_DOCONDBRANCH
000519 0534                          DEST(PFA_NUMBER1)
                                     ; if equal 1: mayba a trailing dot? --> double cell number
00051a 3fe5                          .dw XT_ONE
00051b 3fde                          .dw XT_EQUAL
00051c 3835                          .dw XT_DOCONDBRANCH
00051d 052b                          DEST(PFA_NUMBER2)
                                 	; excatly one character is left
00051e 3897                      	.dw XT_CFETCH
00051f 383c                      	.dw XT_DOLITERAL
000520 002e                      	.dw 46 ; .
000521 3fde                      	.dw XT_EQUAL
000522 3835                      	.dw XT_DOCONDBRANCH
000523 052c                      	DEST(PFA_NUMBER6)
                                 	; its a double cell number
                                         ; incorporate sign into number
000524 38f5                      	.dw XT_R_FROM
000525 3835                              .dw XT_DOCONDBRANCH
000526 0528                      	DEST(PFA_NUMBER3)
000527 0233                              .dw XT_DNEGATE
                                 PFA_NUMBER3:
000528 3fea                      	.dw XT_TWO
000529 382e                      	.dw XT_DOBRANCH
00052a 053a                      	DEST(PFA_NUMBER5)
                                 PFA_NUMBER2:
00052b 38d8                      	.dw XT_DROP
                                 PFA_NUMBER6:
00052c 3ed1                      	.dw XT_2DROP
00052d 38f5                      	.dw XT_R_FROM
00052e 38d8                      	.dw XT_DROP
00052f 38f5                              .dw XT_R_FROM
000530 3ebc                              .dw XT_BASE
000531 3880                              .dw XT_STORE
000532 3953                      	.dw XT_ZERO
000533 381f                      	.dw XT_EXIT
                                 PFA_NUMBER1:
000534 3ed1                          .dw XT_2DROP ; remove the address
                                     ; incorporate sign into number
000535 38f5                          .dw XT_R_FROM
000536 3835                          .dw XT_DOCONDBRANCH
000537 0539                          DEST(PFA_NUMBER4)
000538 3e26                          .dw XT_NEGATE
                                 PFA_NUMBER4:
000539 3fe5                          .dw XT_ONE
                                 PFA_NUMBER5:
00053a 38f5                          .dw XT_R_FROM
00053b 3ebc                          .dw XT_BASE
00053c 3880                          .dw XT_STORE
00053d 394a                          .dw XT_TRUE
00053e 381f                          .dw XT_EXIT
                                 .include "words/q-sign.asm"
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 XT_QSIGN:
00053f 3800                          .dw DO_COLON 
                                 PFA_QSIGN:        ; ( c -- ) 
                                 .endif
000540 38ce                          .dw XT_OVER    ; ( -- addr len addr )
000541 3897                          .dw XT_CFETCH
000542 383c                          .dw XT_DOLITERAL
000543 002d                          .dw '-'
000544 3fde                          .dw XT_EQUAL  ; ( -- addr len flag )
000545 38b0                          .dw XT_DUP
000546 38fe                          .dw XT_TO_R
000547 3835                          .dw XT_DOCONDBRANCH
000548 054b                          DEST(PFA_NUMBERSIGN_DONE)
000549 3fe5                          .dw XT_ONE    ; skip sign character
00054a 05ac                          .dw XT_SLASHSTRING
                                 PFA_NUMBERSIGN_DONE:
00054b 38f5                          .dw XT_R_FROM
00054c 381f                          .dw XT_EXIT
                                 .include "words/set-base.asm"
                                 
                                 ; Numeric IO
                                 ; skip a numeric prefix character
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 XT_BASES:
00054d 3851                          .dw PFA_DOCONSTANT
                                 .endif
00054e 000a
00054f 0010
000550 0002
000551 000a                          .dw 10,16,2,10 ; last one could a 8 instead.
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 XT_SET_BASE:
000552 3800                          .dw DO_COLON 
                                 PFA_SET_BASE:        ; ( adr1 len1 -- adr2 len2 ) 
                                 .endif
000553 38ce                          .dw XT_OVER
000554 3897                          .dw XT_CFETCH
000555 383c                          .dw XT_DOLITERAL
000556 0023                          .dw 35
000557 3992                          .dw XT_MINUS
000558 38b0                          .dw XT_DUP
000559 3953                          .dw XT_ZERO
00055a 383c                          .dw XT_DOLITERAL
00055b 0004                          .dw 4
00055c 3e56                          .dw XT_WITHIN
00055d 3835                          .dw XT_DOCONDBRANCH
00055e 0568                          DEST(SET_BASE1)
                                 	.if cpu_msp430==1
                                 	.endif
00055f 054d                      	.dw XT_BASES
000560 399c                      	.dw XT_PLUS
000561 3bca                      	.dw XT_FETCHI
000562 3ebc                      	.dw XT_BASE
000563 3880                      	.dw XT_STORE
000564 3fe5                      	.dw XT_ONE
000565 05ac                      	.dw XT_SLASHSTRING
000566 382e                      	.dw XT_DOBRANCH
000567 0569                      	DEST(SET_BASE2)
                                 SET_BASE1:
000568 38d8                      	.dw XT_DROP
                                 SET_BASE2:
000569 381f                          .dw XT_EXIT 
                                 
                                 ; create bases 10 , 16 , 2 , 8 ,
                                 ; : set-base 35 - dup 0 4 within if 
                                 ;    bases + @i base ! 1 /string 
                                 ;   else 
                                 ;    drop
                                 ;   then ;
                                 .include "words/to-number.asm"
                                 
                                 ; Numeric IO
                                 ; convert a string to a number  c-addr2/u2 is the unconverted string
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_TO_NUMBER:
00056a ff07                          .dw $ff07
00056b 6e3e
00056c 6d75
00056d 6562
00056e 0072                          .db ">number",0
00056f 04f6                          .dw VE_HEAD
                                     .set VE_HEAD = VE_TO_NUMBER
                                 XT_TO_NUMBER:
000570 3800                          .dw DO_COLON
                                 
                                 .endif
                                 
000571 38b0
000572 3835                      TONUM1: .DW XT_DUP,XT_DOCONDBRANCH
000573 0588                              DEST(TONUM3)
000574 38ce
000575 3897
000576 03b6                              .DW XT_OVER,XT_CFETCH,XT_DIGITQ
000577 3919
000578 3835                              .DW XT_ZEROEQUAL,XT_DOCONDBRANCH
000579 057c                              DEST(TONUM2)
00057a 38d8
00057b 381f                              .DW XT_DROP,XT_EXIT
00057c 38fe
00057d 0257
00057e 3ebc
00057f 3878
000580 014b                      TONUM2: .DW XT_TO_R,XT_2SWAP,XT_BASE,XT_FETCH,XT_UDSTAR
000581 38f5
000582 0143
000583 0257                              .DW XT_R_FROM,XT_MPLUS,XT_2SWAP
000584 3fe5
000585 05ac
000586 382e                              .DW XT_ONE,XT_SLASHSTRING,XT_DOBRANCH
000587 0571                              DEST(TONUM1)
000588 381f                      TONUM3: .DW XT_EXIT
                                 
                                 ;C >NUMBER  ud adr u -- ud' adr' u'
                                 ;C                      convert string to number
                                 ;   BEGIN
                                 ;   DUP WHILE
                                 ;       OVER C@ DIGIT?
                                 ;       0= IF DROP EXIT THEN
                                 ;       >R 2SWAP BASE @ UD*
                                 ;       R> M+ 2SWAP
                                 ;       1 /STRING
                                 ;   REPEAT ;
                                 .include "words/parse.asm"
                                 
                                 ; String
                                 ; in input buffer parse ccc delimited string by the delimiter char.
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_PARSE:
000589 ff05                          .dw $ff05
00058a 6170
00058b 7372
00058c 0065                          .db "parse",0
00058d 056a                          .dw VE_HEAD
                                     .set VE_HEAD = VE_PARSE
                                 XT_PARSE:
00058e 3800                          .dw DO_COLON
                                 PFA_PARSE:
                                 .endif
00058f 38fe                          .dw XT_TO_R     ; ( -- )
000590 05a2                          .dw XT_SOURCE   ; ( -- addr len)
000591 3ee1                          .dw XT_TO_IN     ; ( -- addr len >in)
000592 3878                          .dw XT_FETCH
000593 05ac                          .dw XT_SLASHSTRING ; ( -- addr' len' )
                                 
000594 38f5                          .dw XT_R_FROM      ; ( -- addr' len' c)
000595 0478                          .dw XT_CSCAN       ; ( -- addr' len'')
000596 38b0                          .dw XT_DUP         ; ( -- addr' len'' len'')
000597 3a2e                          .dw XT_1PLUS
000598 3ee1                          .dw XT_TO_IN        ; ( -- addr' len'' len'' >in)
000599 3a64                          .dw XT_PLUSSTORE   ; ( -- addr' len')
00059a 3fe5                          .dw XT_ONE
00059b 05ac                          .dw XT_SLASHSTRING
00059c 381f                          .dw XT_EXIT
                                 .include "words/source.asm"
                                 
                                 ; System
                                 ; address and current length of the input buffer
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_SOURCE:
00059d ff06                          .dw $FF06
00059e 6f73
00059f 7275
0005a0 6563                          .db "source"
0005a1 0589                          .dw VE_HEAD
                                     .set VE_HEAD = VE_SOURCE
                                 XT_SOURCE:
0005a2 3dfe                          .dw PFA_DODEFER1
                                 PFA_SOURCE:
                                 .endif
0005a3 0016                          .dw USER_SOURCE
0005a4 3dc7                          .dw XT_UDEFERFETCH
0005a5 3dd3                          .dw XT_UDEFERSTORE
                                 
                                 
                                 .include "words/slash-string.asm"
                                 
                                 ; String
                                 ; adjust string from addr1 to addr1+n, reduce length from u1 to u2 by n
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_SLASHSTRING:
0005a6 ff07                          .dw $ff07
0005a7 732f
0005a8 7274
0005a9 6e69
0005aa 0067                          .db "/string",0
0005ab 059d                          .dw VE_HEAD
                                     .set VE_HEAD = VE_SLASHSTRING
                                 XT_SLASHSTRING:
0005ac 3800                          .dw DO_COLON
                                 PFA_SLASHSTRING:
                                 .endif
0005ad 38e0                          .dw XT_ROT
0005ae 38ce                          .dw XT_OVER
0005af 399c                          .dw XT_PLUS
0005b0 38e0                          .dw XT_ROT
0005b1 38e0                          .dw XT_ROT
0005b2 3992                          .dw XT_MINUS
0005b3 381f                          .dw XT_EXIT
                                 
                                 .include "words/parse-name.asm"
                                 
                                 ; String
                                 ; In the SOURCE buffer parse whitespace delimited string. Returns string address within SOURCE.
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 
                                 VE_PARSENAME:
0005b4 ff0a                          .dw $FF0A 
0005b5 6170
0005b6 7372
0005b7 2d65
0005b8 616e
0005b9 656d                          .db "parse-name"
0005ba 05a6                          .dw VE_HEAD
                                     .set VE_HEAD = VE_PARSENAME
                                 XT_PARSENAME:
0005bb 3800                          .dw DO_COLON 
                                 PFA_PARSENAME:
                                 .endif
0005bc 3f53                          .dw XT_BL
0005bd 05bf                          .dw XT_SKIPSCANCHAR
0005be 381f                          .dw XT_EXIT 
                                 
                                 ; ( c -- addr2 len2 ) 
                                 ; String
                                 ; skips char and scan what's left in source for char
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 ;VE_SKIPSCANCHAR:
                                 ;    .dw $FF0A 
                                 ;    .db "skipscanchar"
                                 ;    .dw VE_HEAD
                                 ;    .set VE_HEAD = VE_SKIPSCANCHAR
                                 XT_SKIPSCANCHAR:
0005bf 3800                          .dw DO_COLON
                                 PFA_SKIPSCANCHAR:
                                 .endif
0005c0 38fe                          .dw XT_TO_R
0005c1 05a2                          .dw XT_SOURCE 
0005c2 3ee1                          .dw XT_TO_IN 
0005c3 3878                          .dw XT_FETCH 
0005c4 05ac                          .dw XT_SLASHSTRING 
                                 
0005c5 3907                          .dw XT_R_FETCH
0005c6 0461                          .dw XT_CSKIP
0005c7 38f5                          .dw XT_R_FROM
0005c8 0478                          .dw XT_CSCAN
                                 
                                     ; adjust >IN
0005c9 3ec8                          .dw XT_2DUP
0005ca 399c                          .dw XT_PLUS
0005cb 05a2                          .dw XT_SOURCE 
0005cc 38d8                          .dw XT_DROP
0005cd 3992                          .dw XT_MINUS
0005ce 3ee1                          .dw XT_TO_IN
0005cf 3880                          .dw XT_STORE
0005d0 381f                          .dw XT_EXIT
                                 .include "words/sp0.asm"
                                 
                                 ; Stack
                                 ; start address of the data stack
                                 VE_SP0:
0005d1 ff03                          .dw $ff03
0005d2 7073
0005d3 0030                          .db "sp0",0
0005d4 05b4                          .dw VE_HEAD
                                     .set VE_HEAD = VE_SP0
                                 XT_SP0:
0005d5 386e                          .dw PFA_DOVALUE1
                                 PFA_SP0:
0005d6 0006                          .dw USER_SP0
0005d7 3dc7                          .dw XT_UDEFERFETCH
0005d8 3dd3                          .dw XT_UDEFERSTORE
                                 
                                 ; ( -- addr) 
                                 ; Stack
                                 ; address of user variable to store top-of-stack for inactive tasks
                                 VE_SP:
0005d9 ff02                          .dw $ff02
0005da 7073                          .db "sp"
0005db 05d1                          .dw VE_HEAD
                                     .set VE_HEAD = VE_SP
                                 XT_SP:
0005dc 3857                          .dw PFA_DOUSER
                                 PFA_SP:
0005dd 0008                          .dw USER_SP
                                 .include "words/rp0.asm"
                                 
                                 ; Stack
                                 ; start address of return stack
                                 VE_RP0:
0005de ff03                          .dw $ff03
0005df 7072
0005e0 0030                          .db "rp0",0
0005e1 05d9                          .dw VE_HEAD
                                     .set VE_HEAD = VE_RP0
                                 XT_RP0:
0005e2 3800                          .dw DO_COLON
                                 PFA_RP0:
0005e3 05e6                          .dw XT_DORP0
0005e4 3878                          .dw XT_FETCH
0005e5 381f                          .dw XT_EXIT
                                 
                                 ; ( -- addr) 
                                 ; Stack
                                 ; user variable of the address of the initial return stack
                                 ;VE_DORP0:
                                 ;    .dw $ff05
                                 ;    .db "(rp0)"
                                 ;    .dw VE_HEAD
                                 ;    .set VE_HEAD = VE_DORP0
                                 XT_DORP0:
0005e6 3857                          .dw PFA_DOUSER
                                 PFA_DORP0:
0005e7 0004                          .dw USER_RP
                                 .include "words/depth.asm"
                                 
                                 ; Stack
                                 ; number of single-cell values contained in the data stack before n was placed on the stack.
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_DEPTH:
0005e8 ff05                          .dw $ff05
0005e9 6564
0005ea 7470
0005eb 0068                          .db "depth",0
0005ec 05de                          .dw VE_HEAD
                                     .set VE_HEAD = VE_DEPTH
                                 XT_DEPTH:
0005ed 3800                          .dw DO_COLON
                                 PFA_DEPTH:
                                 .endif
0005ee 05d5                          .dw XT_SP0
0005ef 3a8c                          .dw XT_SP_FETCH
0005f0 3992                          .dw XT_MINUS
0005f1 3a03                          .dw XT_2SLASH
0005f2 3a34                          .dw XT_1MINUS
0005f3 381f                          .dw XT_EXIT
                                 .include "words/forth-recognizer.asm"
                                 
                                 ; System Value
                                 ; address of the next free data space (RAM) cell
                                 VE_FORTHRECOGNIZER:
0005f4 ff10                          .dw $ff10
0005f5 6f66
0005f6 7472
0005f7 2d68
0005f8 6572
0005f9 6f63
0005fa 6e67
0005fb 7a69
0005fc 7265                          .db "forth-recognizer"
0005fd 05e8                          .dw VE_HEAD
                                     .set VE_HEAD = VE_FORTHRECOGNIZER
                                 XT_FORTHRECOGNIZER:
0005fe 386e                          .dw PFA_DOVALUE1
                                 PFA_FORTHRECOGNIZER:
0005ff 003e                          .dw CFG_FORTHRECOGNIZER
000600 3d9f                          .dw XT_EDEFERFETCH
000601 3da9                          .dw XT_EDEFERSTORE
                                 .include "words/recognize.asm"
                                 
                                 ; System
                                 ; walk the recognizer stack
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_RECOGNIZE:
000602 ff09                          .dw $ff09
000603 6572
000604 6f63
000605 6e67
000606 7a69
000607 0065                          .db "recognize",0
000608 05f4                          .dw VE_HEAD
                                     .set VE_HEAD = VE_RECOGNIZE
                                 XT_RECOGNIZE:
000609 3800                          .dw DO_COLON
                                 PFA_RECOGNIZE:
                                 .endif
00060a 383c                          .dw XT_DOLITERAL
00060b 0614                          .dw XT_RECOGNIZE_A
00060c 38c3                          .dw XT_SWAP
00060d 09a7                          .dw XT_MAPSTACK
00060e 3919                          .dw XT_ZEROEQUAL
00060f 3835                          .dw XT_DOCONDBRANCH
000610 0613                          DEST(PFA_RECOGNIZE1)
000611 3ed1                            .dw XT_2DROP
000612 0696                            .dw XT_DT_NULL
                                 PFA_RECOGNIZE1:
000613 381f                          .dw XT_EXIT
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 ; ( addr len XT -- addr len [ dt:xt -1 | 0 ] )
                                 XT_RECOGNIZE_A:
000614 3800                         .dw DO_COLON
                                 PFA_RECOGNIZE_A:
                                 .endif
000615 38e0                         .dw XT_ROT  ; -- len xt addr
000616 38e0                         .dw XT_ROT  ; -- xt addr len
000617 3ec8                         .dw XT_2DUP 
000618 3b1d                         .dw XT_2TO_R
000619 38e0                         .dw XT_ROT  ; -- addr len xt
00061a 3829                         .dw XT_EXECUTE ; -- i*x dt:* | dt:null
00061b 3b2c                         .dw XT_2R_FROM
00061c 38e0                         .dw XT_ROT
00061d 38b0                         .dw XT_DUP
00061e 0696                         .dw XT_DT_NULL
00061f 3fde                         .dw XT_EQUAL
000620 3835                         .dw XT_DOCONDBRANCH
000621 0625                         DEST(PFA_RECOGNIZE_A1)
000622 38d8                           .dw XT_DROP
000623 3953                           .dw XT_ZERO
000624 381f                           .dw XT_EXIT
                                 PFA_RECOGNIZE_A1:
000625 38ef                         .dw XT_NIP 
000626 38ef                         .dw XT_NIP
000627 394a                         .dw XT_TRUE
000628 381f                         .dw XT_EXIT
                                 
                                 ; : recognize ( addr len stack-id -- i*x dt:* | dt:null )
                                 ;   [: ( addr len -- addr len 0 | i*x dt:* -1 )
                                 ;      rot rot 2dup 2>r rot execute 2r> rot 
                                 ;      dup dt:null = ( -- addr len dt:* f )
                                 ;      if drop 0 else nip nip -1 then
                                 ;    ;] 
                                 ;    map-stack ( -- i*x addr len dt:* f )
                                 ;    0= if \ a recognizer did the job, remove addr/len
                                 ;     2drop dt:null
                                 ;    then ;
                                 ;
                                 .include "words/interpret.asm"
                                 
                                 ; System
                                 ; Interpret SOURCE word by word.
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_INTERPRET:
000629 ff09                          .dw $ff09
00062a 6e69
00062b 6574
00062c 7072
00062d 6572
00062e 0074                          .db "interpret",0
00062f 0602                          .dw VE_HEAD
                                     .set VE_HEAD = VE_INTERPRET
                                 XT_INTERPRET:
000630 3800                          .dw DO_COLON
                                 .endif
                                 PFA_INTERPRET:
000631 05bb                          .dw XT_PARSENAME ; ( -- addr len )
000632 38b0                          .dw XT_DUP   ; ( -- addr len flag)
000633 3835                          .dw XT_DOCONDBRANCH
000634 0641                          DEST(PFA_INTERPRET2)
000635 05fe                            .dw XT_FORTHRECOGNIZER
000636 0609                            .dw XT_RECOGNIZE
000637 3eb6                            .dw XT_STATE
000638 3878                            .dw XT_FETCH
000639 3835                            .dw XT_DOCONDBRANCH
00063a 063c                          DEST(PFA_INTERPRET1)
00063b 01d1                            .dw XT_ICELLPLUS   ; we need the compile action
                                 PFA_INTERPRET1:
00063c 3bca                            .dw XT_FETCHI
00063d 3829                            .dw XT_EXECUTE
00063e 3f8a                            .dw XT_QSTACK
00063f 382e                          .dw XT_DOBRANCH
000640 0631                          DEST(PFA_INTERPRET)
                                 PFA_INTERPRET2:
000641 3ed1                          .dw XT_2DROP
000642 381f                          .dw XT_EXIT
                                 .include "words/rec-intnum.asm"
                                 
                                 ; Interpreter
                                 ; Method table for single cell integers
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_DT_NUM:
000643 ff06                          .dw $ff06
000644 7464
000645 6e3a
000646 6d75                          .db "dt:num"
000647 0629                          .dw VE_HEAD
                                     .set VE_HEAD = VE_DT_NUM
                                 XT_DT_NUM:
000648 3851                          .dw PFA_DOCONSTANT
                                 PFA_DT_NUM:
                                 .endif
000649 01a5                          .dw XT_NOOP    ; interpret
00064a 077d                          .dw XT_LITERAL ; compile
00064b 077d                          .dw XT_LITERAL ; postpone
                                 
                                 ; ( -- addr )
                                 ; Interpreter
                                 ; Method table for double cell integers
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_DT_DNUM:
00064c ff07                          .dw $ff07
00064d 7464
00064e 643a
00064f 756e
000650 006d                          .db "dt:dnum",0
000651 0643                          .dw VE_HEAD
                                     .set VE_HEAD = VE_DT_DNUM
                                 XT_DT_DNUM:
000652 3851                          .dw PFA_DOCONSTANT
                                 PFA_DT_DNUM:
                                 .endif
000653 01a5                          .dw XT_NOOP     ; interpret
000654 3fd6                          .dw XT_2LITERAL ; compile
000655 3fd6                          .dw XT_2LITERAL ; postpone
                                 
                                 ; ( addr len -- f )
                                 ; Interpreter
                                 ; recognizer for integer numbers
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 
                                 VE_REC_NUM:
000656 ff07                          .dw $ff07
000657 6572
000658 3a63
000659 756e
00065a 006d                          .db "rec:num",0
00065b 064c                          .dw VE_HEAD
                                     .set VE_HEAD = VE_REC_NUM
                                 XT_REC_NUM:
00065c 3800                          .dw DO_COLON
                                 PFA_REC_NUM:
                                 .endif
                                     ; try converting to a number
00065d 04fb                          .dw XT_NUMBER
00065e 3835                          .dw XT_DOCONDBRANCH
00065f 0668                          DEST(PFA_REC_NONUMBER)
000660 3fe5                          .dw XT_ONE
000661 3fde                          .dw XT_EQUAL
000662 3835                          .dw XT_DOCONDBRANCH
000663 0666                          DEST(PFA_REC_INTNUM2)
000664 0648                            .dw XT_DT_NUM
000665 381f                            .dw XT_EXIT
                                 PFA_REC_INTNUM2:
000666 0652                            .dw XT_DT_DNUM
000667 381f                            .dw XT_EXIT
                                 PFA_REC_NONUMBER:
000668 0696                          .dw XT_DT_NULL
000669 381f                          .dw XT_EXIT
                                 .include "words/rec-find.asm"
                                 
                                 ; Interpreter
                                 ; search for a word
                                 .if cpu_msp430==1
                                 .endif
                                 .if cpu_avr8==1
                                 VE_REC_FIND:
00066a ff08                          .dw $ff08
00066b 6572
00066c 3a63
00066d 6966
00066e 646e                          .db "rec:find"
00066f 0656                          .dw VE_HEAD
                                     .set VE_HEAD = VE_REC_FIND
                                 XT_REC_FIND:
000670 3800                          .dw DO_COLON
                                 PFA_REC_FIND:
                                 .endif
000671 070b                          .DW XT_FINDXT
000672 38b0                          .dw XT_DUP
000673 3919                          .dw XT_ZEROEQUAL
000674 3835                          .dw XT_DOCONDBRANCH
000675 0679                          DEST(PFA_REC_WORD_FOUND)
000676 38d8                              .dw XT_DROP
000677 0696                      	.dw XT_DT_NULL
000678 381f                      	.dw XT_EXIT
                                 PFA_REC_WORD_FOUND:
000679 0680                          .dw XT_DT_XT
                                 
00067a 381f                          .dw XT_EXIT
                                 
                                 ; ( -- addr )
                                 ; Interpreter
                                 ; actions to handle execution tokens and their flags
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_DT_XT:
00067b ff05                          .dw $ff05
00067c 7464
00067d 783a
00067e 0074                          .db "dt:xt",0
00067f 066a                          .dw VE_HEAD
                                     .set VE_HEAD = VE_DT_XT
                                 XT_DT_XT:
000680 3851                          .dw PFA_DOCONSTANT
                                 PFA_DT_XT:
                                 .endif
000681 0684                          .dw XT_R_WORD_INTERPRET
000682 0688                          .dw XT_R_WORD_COMPILE
000683 3fd6                          .dw XT_2LITERAL
                                 
                                 ; ( XT flags -- )
                                 ; Interpreter
                                 ; interpret method for WORD recognizer
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 XT_R_WORD_INTERPRET:
000684 3800                          .dw DO_COLON
                                 PFA_R_WORD_INTERPRET:
                                 .endif
000685 38d8                          .dw XT_DROP ; the flags are in the way
000686 3829                          .dw XT_EXECUTE
000687 381f                          .dw XT_EXIT
                                 
                                 ; ( XT flags -- )
                                 ; Interpreter
                                 ; Compile method for WORD recognizer
                                 .if cpu_msp430==1
                                 .endif
                                 .if cpu_avr8==1
                                 XT_R_WORD_COMPILE:
000688 3800                          .dw DO_COLON
                                 PFA_R_WORD_COMPILE:
                                 .endif
000689 3920                          .dw XT_ZEROLESS
00068a 3835                          .dw XT_DOCONDBRANCH
00068b 068e                          DEST(PFA_R_WORD_COMPILE1)
00068c 0767                      	.dw XT_COMMA
00068d 381f                              .dw XT_EXIT
                                 PFA_R_WORD_COMPILE1:
00068e 3829                              .dw XT_EXECUTE
00068f 381f                          .dw XT_EXIT
                                 .include "words/dt-null.asm"
                                 
                                 ; Interpreter
                                 ; there is no parser for this recognizer, this is the default and failsafe part
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_DT_NULL:
000690 ff07                          .dw $ff07
000691 7464
000692 6e3a
000693 6c75
amforth-6.5\common\words/dt-null.asm(12): warning: .cseg .db misalignment - padding zero byte
000694 006c                          .db "dt:null"
000695 067b                          .dw VE_HEAD
                                     .set VE_HEAD = VE_DT_NULL
                                 XT_DT_NULL:
000696 3851                          .dw PFA_DOCONSTANT
                                 PFA_DT_NULL:
                                 .endif
000697 069a                          .dw XT_FAIL  ; interpret
000698 069a                          .dw XT_FAIL  ; compile
000699 069a                          .dw XT_FAIL  ; postpone
                                 
                                 ; ( addr len -- )
                                 ; Interpreter
                                 ; default failure action: throw exception -13.
                                 .if cpu_msp430==1
                                 .endif
                                 .if cpu_avr8==1
                                 ;VE_FAIL:
                                 ;    .dw $ff04
                                 ;    .db "fail"
                                 ;    .dw VE_HEAD
                                 ;    .set VE_HEAD = VE_FAIL
                                 XT_FAIL:
00069a 3800                          .dw DO_COLON
                                 PFA_FAIL:
                                 .endif
00069b 383c                          .dw XT_DOLITERAL
00069c fff3                          .dw -13
00069d 3d85                          .dw XT_THROW
                                 .include "words/search-wordlist.asm"
                                 
                                 ; Search Order
                                 ; searches the word list wid for the word at c-addr/len
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_SEARCH_WORDLIST:
00069e ff0f                          .dw $ff0f
00069f 6573
0006a0 7261
0006a1 6863
0006a2 772d
0006a3 726f
0006a4 6c64
0006a5 7369
0006a6 0074                          .db "search-wordlist",0
0006a7 0690                          .dw VE_HEAD
                                     .set VE_HEAD = VE_SEARCH_WORDLIST
                                 XT_SEARCH_WORDLIST:
0006a8 3800                          .dw DO_COLON
                                 PFA_SEARCH_WORDLIST:
                                 .endif
0006a9 38fe                          .dw XT_TO_R
0006aa 3953                          .dw XT_ZERO
0006ab 383c                          .dw XT_DOLITERAL
0006ac 06bd                          .dw XT_ISWORD
0006ad 38f5                          .dw XT_R_FROM
0006ae 06da                          .dw XT_TRAVERSEWORDLIST
0006af 38b0                          .dw XT_DUP
0006b0 3919                          .dw XT_ZEROEQUAL
0006b1 3835                          .dw XT_DOCONDBRANCH
0006b2 06b7                          DEST(PFA_SEARCH_WORDLIST1)
0006b3 3ed1                             .dw XT_2DROP
0006b4 38d8                             .dw XT_DROP
0006b5 3953                             .dw XT_ZERO
0006b6 381f                             .dw XT_EXIT
                                 PFA_SEARCH_WORDLIST1:
                                       ; ... get the XT ...
0006b7 38b0                            .dw XT_DUP
0006b8 0701                            .dw XT_NFA2CFA
                                       ; .. and get the header flag
0006b9 38c3                            .dw XT_SWAP
0006ba 0180                            .dw XT_NAME2FLAGS
0006bb 016e                            .dw XT_IMMEDIATEQ
0006bc 381f                          .dw XT_EXIT
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 XT_ISWORD:
0006bd 3800                          .dw DO_COLON
                                 PFA_ISWORD:
                                 .endif
                                     ; ( c-addr len 0 nt -- c-addr len 0 true| nt false )
0006be 38fe                          .dw XT_TO_R
0006bf 38d8                          .dw XT_DROP
0006c0 3ec8                          .dw XT_2DUP
0006c1 3907                          .dw XT_R_FETCH  ; -- addr len addr len nt
0006c2 06f5                          .dw XT_NAME2STRING
0006c3 01da                          .dw XT_ICOMPARE      ; (-- addr len f )
0006c4 3835                          .dw XT_DOCONDBRANCH
0006c5 06cb                          DEST(PFA_ISWORD3)
                                       ; not now
0006c6 38f5                            .dw XT_R_FROM
0006c7 38d8                            .dw XT_DROP
0006c8 3953                            .dw XT_ZERO
0006c9 394a                            .dw XT_TRUE         ; maybe next word
0006ca 381f                            .dw XT_EXIT
                                 PFA_ISWORD3:
                                       ; we found the word, now clean up iteration data ...
0006cb 3ed1                            .dw XT_2DROP
0006cc 38f5                            .dw XT_R_FROM
0006cd 3953                            .dw XT_ZERO       ; finish traverse-wordlist
0006ce 381f                            .dw XT_EXIT
                                 .include "words/traverse-wordlist.asm"
                                 
                                 ; Tools Ext (2012)
                                 ; call the xt for every member of the wordlist wid until xt returns false
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_TRAVERSEWORDLIST:
0006cf ff11                          .dw $ff11
0006d0 7274
0006d1 7661
0006d2 7265
0006d3 6573
0006d4 772d
0006d5 726f
0006d6 6c64
0006d7 7369
0006d8 0074                          .db "traverse-wordlist",0
0006d9 069e                          .dw VE_HEAD
                                     .set VE_HEAD = VE_TRAVERSEWORDLIST
                                 XT_TRAVERSEWORDLIST:
0006da 3800                          .dw DO_COLON
                                 PFA_TRAVERSEWORDLIST:
                                 
                                 .endif
0006db 3b5e                          .dw XT_FETCHE
                                 PFA_TRAVERSEWORDLIST1:
0006dc 38b0                          .dw XT_DUP           ; ( -- xt nt nt )
0006dd 3835                          .dw XT_DOCONDBRANCH  ; ( -- nt ) is nfa = counted string
0006de 06eb                          DEST(PFA_TRAVERSEWORDLIST2)
0006df 3ec8                          .dw XT_2DUP
0006e0 3b1d                          .dw XT_2TO_R
0006e1 38c3                          .dw XT_SWAP
0006e2 3829                          .dw XT_EXECUTE
0006e3 3b2c                          .dw XT_2R_FROM
0006e4 38e0                          .dw XT_ROT
0006e5 3835                          .dw XT_DOCONDBRANCH
0006e6 06eb                          DEST(PFA_TRAVERSEWORDLIST2)
0006e7 0a16                          .dw XT_NFA2LFA
0006e8 3bca                          .dw XT_FETCHI
0006e9 382e                          .dw XT_DOBRANCH      ; ( -- addr )
0006ea 06dc                          DEST(PFA_TRAVERSEWORDLIST1)       ; ( -- addr )
                                 PFA_TRAVERSEWORDLIST2:
0006eb 3ed1                          .dw XT_2DROP
0006ec 381f                          .dw XT_EXIT
                                 
                                 ; : traverse-wordlist ( i*x xt wid -- i*x' )
                                 ;        begin @ dup
                                 ;        while
                                 ;          2dup 2>r
                                 ;          swap execute ( i*x nt -- i*x' f )
                                 ;          2r> rot
                                 ;        while
                                 ;          nfa>lfa @i
                                 ;        repeat then 2drop ;
                                 .include "words/name2string.asm"
                                 
                                 ; Tools Ext (2012)
                                 ; get a (flash) string from a name token nt
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_NAME2STRING:
0006ed ff0b                          .dw $ff0b
0006ee 616e
0006ef 656d
0006f0 733e
0006f1 7274
0006f2 6e69
0006f3 0067                          .db "name>string",0
0006f4 06cf                          .dw VE_HEAD
                                     .set VE_HEAD = VE_NAME2STRING
                                 XT_NAME2STRING:
0006f5 3800                          .dw DO_COLON
                                 PFA_NAME2STRING:
                                 
                                 .endif
0006f6 042f                          .dw XT_ICOUNT   ; ( -- addr n )
0006f7 383c                          .dw XT_DOLITERAL
0006f8 00ff                          .dw 255
0006f9 3a12                          .dw XT_AND      ; mask immediate bit
0006fa 381f                          .dw XT_EXIT
                                 .include "words/nfa2cfa.asm"
                                 
                                 ; Tools
                                 ; get the XT from a name token
                                 VE_NFA2CFA:
0006fb ff07                          .dw $ff07
0006fc 666e
0006fd 3e61
0006fe 6663
amforth-6.5\avr8\words/nfa2cfa.asm(6): warning: .cseg .db misalignment - padding zero byte
0006ff 0061                          .db "nfa>cfa"
000700 06ed                          .dw VE_HEAD
                                     .set VE_HEAD = VE_NFA2CFA
                                 XT_NFA2CFA:
000701 3800                          .dw DO_COLON
                                 PFA_NFA2CFA:
000702 0a16                          .dw XT_NFA2LFA ; skip to link field
000703 3a2e                          .dw XT_1PLUS   ; next is the execution token
000704 381f                          .dw XT_EXIT
                                 .include "words/find-xt.asm"
                                 
                                 ; Tools
                                 ; search wordlists for an entry with the xt from c-addr/len
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_FINDXT:
000705 ff07                          .dw $ff07
000706 6966
000707 646e
000708 782d
000709 0074                          .db "find-xt",0
00070a 06fb                          .dw VE_HEAD
                                     .set VE_HEAD = VE_FINDXT
                                 XT_FINDXT:
00070b 3800                          .dw DO_COLON
                                 PFA_FINDXT:
                                 .endif
00070c 383c                          .dw XT_DOLITERAL
00070d 0717                          .dw XT_FINDXTA
00070e 383c                          .dw XT_DOLITERAL
00070f 004a                          .dw CFG_ORDERLISTLEN
000710 09a7                          .dw XT_MAPSTACK
000711 3919                          .dw XT_ZEROEQUAL
000712 3835                          .dw XT_DOCONDBRANCH
000713 0716                          DEST(PFA_FINDXT1)
000714 3ed1                            .dw XT_2DROP
000715 3953                            .dw XT_ZERO
                                 PFA_FINDXT1:
000716 381f                          .dw XT_EXIT
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 
                                 XT_FINDXTA:
000717 3800                          .dw DO_COLON
                                 PFA_FINDXTA:
                                 .endif
000718 38fe                          .dw XT_TO_R
000719 3ec8                          .dw XT_2DUP
00071a 38f5                          .dw XT_R_FROM
00071b 06a8                          .dw XT_SEARCH_WORDLIST
00071c 38b0                          .dw XT_DUP
00071d 3835                          .dw XT_DOCONDBRANCH
00071e 0724                          DEST(PFA_FINDXTA1)
00071f 38fe                            .dw XT_TO_R
000720 38ef                            .dw XT_NIP
000721 38ef                            .dw XT_NIP
000722 38f5                            .dw XT_R_FROM
000723 394a                            .dw XT_TRUE
                                 PFA_FINDXTA1:
000724 381f                          .dw XT_EXIT
                                 
                                 .include "dict/compiler1.inc"
                                 
                                 .include "words/newest.asm"
                                 
                                 ; System Variable
                                 ; system state
                                 VE_NEWEST:
000725 ff06                          .dw $ff06
000726 656e
000727 6577
000728 7473                          .db "newest"
000729 0705                          .dw VE_HEAD
                                     .set VE_HEAD = VE_NEWEST
                                 XT_NEWEST:
00072a 3847                          .dw PFA_DOVARIABLE
                                 PFA_NEWEST:
00072b 018a                          .dw ram_newest
                                 
                                 .dseg
00018a                           ram_newest: .byte 4
                                 .include "words/latest.asm"
                                 
                                 ; System Variable
                                 ; system state
                                 VE_LATEST:
00072c ff06                          .dw $ff06
00072d 616c
00072e 6574
00072f 7473                          .db "latest"
000730 0725                          .dw VE_HEAD
                                     .set VE_HEAD = VE_LATEST
                                 XT_LATEST:
000731 3847                          .dw PFA_DOVARIABLE
                                 PFA_LATEST:
000732 018e                          .dw ram_latest
                                 
                                 .dseg
00018e                           ram_latest: .byte 2
                                 .include "words/do-create.asm"
                                 
                                 ; Compiler
                                 ; parse the input and create an empty vocabulary entry without XT and data field (PF)
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_DOCREATE:
000733 ff08                          .dw $ff08
000734 6328
000735 6572
000736 7461
000737 2965                          .db "(create)"
000738 072c                          .dw VE_HEAD
                                     .set VE_HEAD = VE_DOCREATE
                                 XT_DOCREATE:
000739 3800                          .dw DO_COLON
                                 PFA_DOCREATE:
                                 .endif
00073a 05bb
00073b 0890                          .DW XT_PARSENAME,XT_WLSCOPE  ; ( -- addr len wid)
00073c 38b0
00073d 072a
00073e 3c8f
00073f 3880                          .DW XT_DUP,XT_NEWEST,XT_CELLPLUS,XT_STORE ; save the wid
000740 0875
000741 072a
000742 3880                          .DW XT_HEADER,XT_NEWEST,XT_STORE          ; save the nt
000743 381f                          .DW XT_EXIT
                                 .include "words/backslash.asm"
                                 
                                 ; Compiler
                                 ; everything up to the end of the current line is a comment
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_BACKSLASH:
000744 0001                          .dw $0001
000745 005c                          .db $5c,0
000746 0733                          .dw VE_HEAD
                                     .set VE_HEAD = VE_BACKSLASH
                                 XT_BACKSLASH:
000747 3800                          .dw DO_COLON
                                 PFA_BACKSLASH:
                                 .endif
000748 05a2                          .dw XT_SOURCE
000749 38ef                          .dw XT_NIP
00074a 3ee1                          .dw XT_TO_IN
00074b 3880                          .dw XT_STORE
00074c 381f                          .dw XT_EXIT
                                 .include "words/l-paren.asm"
                                 
                                 ; Compiler
                                 ; skip everything up to the closing bracket on the same line
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_LPAREN:
00074d 0001                          .dw $0001
00074e 0028                          .db "(" ,0
00074f 0744                          .dw VE_HEAD
                                     .set VE_HEAD = VE_LPAREN
                                 XT_LPAREN:
000750 3800                          .dw DO_COLON
                                 PFA_LPAREN:
                                 .endif
000751 383c                          .dw XT_DOLITERAL
000752 0029                          .dw ')'
000753 058e                          .dw XT_PARSE
000754 3ed1                          .dw XT_2DROP
000755 381f                          .dw XT_EXIT
                                 
                                 .include "words/compile.asm"
                                 
                                 ; Dictionary
                                 ; read the following cell from the dictionary and append it to the current dictionary position.
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_COMPILE:
000756 ff07                          .dw $ff07
000757 6f63
000758 706d
000759 6c69
00075a 0065                          .db "compile",0
00075b 074d                          .dw  VE_HEAD
                                     .set VE_HEAD = VE_COMPILE
                                 XT_COMPILE:
00075c 3800                          .dw DO_COLON
                                 PFA_COMPILE:
                                 .endif
00075d 38f5                          .dw XT_R_FROM
00075e 38b0                          .dw XT_DUP
00075f 01d1                          .dw XT_ICELLPLUS
000760 38fe                          .dw XT_TO_R
000761 3bca                          .dw XT_FETCHI
000762 0767                          .dw XT_COMMA
000763 381f                          .dw XT_EXIT
                                 .include "words/comma.asm"
                                 
                                 ; Dictionary
                                 ; compile 16 bit into flash at DP
                                 VE_COMMA:
000764 ff01                          .dw $ff01
000765 002c                          .db ',',0 ; ,
000766 0756                          .dw VE_HEAD
                                     .set VE_HEAD = VE_COMMA
                                 XT_COMMA:
000767 3800                          .dw DO_COLON
                                 PFA_COMMA:
000768 3f11                          .dw XT_DP
000769 3b72                          .dw XT_STOREI
00076a 3f11                          .dw XT_DP
00076b 3a2e                          .dw XT_1PLUS
00076c 01bf                          .dw XT_DOTO
00076d 3f12                          .dw PFA_DP
00076e 381f                          .dw XT_EXIT
                                 .include "words/brackettick.asm"
                                 
                                 ; Compiler
                                 ; what ' does in the interpreter mode, do in colon definitions
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_BRACKETTICK:
00076f 0003                          .dw $0003
000770 275b
000771 005d                          .db "[']",0
000772 0764                          .dw VE_HEAD
                                     .set VE_HEAD = VE_BRACKETTICK
                                 XT_BRACKETTICK:
000773 3800                          .dw DO_COLON
                                 PFA_BRACKETTICK:
                                 .endif
000774 0448                          .dw XT_TICK
000775 077d                          .dw XT_LITERAL
000776 381f                          .dw XT_EXIT
                                 
                                 
                                 .include "words/literal.asm"
                                 
                                 ; Compiler
                                 ; compile a literal in colon defintions
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_LITERAL:
000777 0007                          .dw $0007
000778 696c
000779 6574
00077a 6172
00077b 006c                          .db "literal",0
00077c 076f                          .dw VE_HEAD
                                     .set VE_HEAD = VE_LITERAL
                                 XT_LITERAL:
00077d 3800                          .dw DO_COLON
                                 PFA_LITERAL:
                                 .endif
00077e 075c                              .DW XT_COMPILE
00077f 383c                              .DW XT_DOLITERAL
000780 0767                              .DW XT_COMMA
000781 381f                              .DW XT_EXIT
                                 .include "words/sliteral.asm"
                                 
                                 ; String
                                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_SLITERAL:
000782 0008                        .dw $0008
000783 6c73
000784 7469
000785 7265
000786 6c61                        .db "sliteral"
000787 0777                        .dw VE_HEAD
                                   .set VE_HEAD = VE_SLITERAL
                                 XT_SLITERAL:
000788 3800                          .dw DO_COLON
                                 PFA_SLITERAL:
                                 .endif
000789 075c                          .dw XT_COMPILE
00078a 03d0                          .dw XT_DOSLITERAL    ; ( -- addr n)
00078b 03de                          .dw XT_SCOMMA
00078c 381f                          .dw XT_EXIT
                                 .include "words/g-mark.asm"
                                 
                                 ; Compiler
                                 ; places current dictionary position for backward resolves
                                 ;VE_GMARK:
                                 ;    .dw $ff05
                                 ;    .db ">mark"
                                 ;    .dw VE_HEAD
                                 ;    .set VE_HEAD = VE_GMARK
                                 XT_GMARK:
00078d 3800                          .dw DO_COLON
                                 PFA_GMARK:
00078e 3f11                          .dw XT_DP
00078f 075c                          .dw XT_COMPILE
000790 ffff                          .dw -1           ; ffff does not erase flash
000791 381f                          .dw XT_EXIT
                                 .include "words/g-resolve.asm"
                                 
                                 ; Compiler
                                 ; resolve backward jumps
                                 ;VE_GRESOLVE:
                                 ;    .dw $ff08
                                 ;    .db ">resolve"
                                 ;    .dw VE_HEAD
                                 ;    .set VE_HEAD = VE_GRESOLVE
                                 XT_GRESOLVE:
000792 3800                          .dw DO_COLON
                                 PFA_GRESOLVE:
000793 3f8a                          .dw XT_QSTACK
000794 3f11                          .dw XT_DP
000795 38c3                          .dw XT_SWAP
000796 3b72                          .dw XT_STOREI
000797 381f                          .dw XT_EXIT
                                 .include "words/l_mark.asm"
                                 
                                 ; Compiler
                                 ; place destination for backward branch
                                 ;VE_LMARK:
                                 ;    .dw $ff05
                                 ;    .db "<mark"
                                 ;    .dw VE_HEAD
                                 ;    .set VE_HEAD = VE_LMARK
                                 XT_LMARK:
000798 3800                          .dw DO_COLON
                                 PFA_LMARK:
000799 3f11                          .dw XT_DP
00079a 381f                          .dw XT_EXIT
                                 .include "words/l_resolve.asm"
                                 
                                 ; Compiler
                                 ; resolve backward branch
                                 ;VE_LRESOLVE:
                                 ;    .dw $ff08
                                 ;    .db "<resolve"
                                 ;    .dw VE_HEAD
                                 ;    .set VE_HEAD = VE_LRESOLVE
                                 XT_LRESOLVE:
00079b 3800                          .dw DO_COLON
                                 PFA_LRESOLVE:
00079c 3f8a                          .dw XT_QSTACK
00079d 0767                          .dw XT_COMMA
00079e 381f                          .dw XT_EXIT
                                 
                                 .include "words/ahead.asm"
                                 
                                 ; Compiler
                                 ; do a unconditional branch
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_AHEAD:
00079f 0005                          .dw $0005
0007a0 6861
0007a1 6165
0007a2 0064                          .db "ahead",0
0007a3 0782                          .dw VE_HEAD
                                     .set VE_HEAD = VE_AHEAD
                                 XT_AHEAD:
0007a4 3800                          .dw DO_COLON
                                 PFA_AHEAD:
                                 .endif
0007a5 075c                          .dw XT_COMPILE
0007a6 382e                          .dw XT_DOBRANCH
0007a7 078d                          .dw XT_GMARK
0007a8 381f                          .dw XT_EXIT
                                 .include "words/if.asm"
                                 
                                 ; Compiler
                                 ; start conditional branch
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_IF:
0007a9 0002                          .dw $0002
0007aa 6669                          .db "if"
0007ab 079f                          .dw VE_HEAD
                                     .set VE_HEAD = VE_IF
                                 XT_IF:
0007ac 3800                          .dw DO_COLON
                                 PFA_IF:
                                 .endif
0007ad 075c                          .dw XT_COMPILE
0007ae 3835                          .dw XT_DOCONDBRANCH
0007af 078d                          .dw XT_GMARK
0007b0 381f                          .dw XT_EXIT
                                 .include "words/else.asm"
                                 
                                 ; Compiler
                                 ; resolve the forward reference and place a new unresolved forward reference
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_ELSE:
0007b1 0004                          .dw $0004
0007b2 6c65
0007b3 6573                          .db "else"
0007b4 07a9                          .dw VE_HEAD
                                     .set VE_HEAD = VE_ELSE
                                 XT_ELSE:
0007b5 3800                          .dw DO_COLON
                                 PFA_ELSE:
                                 .endif
0007b6 075c                          .dw XT_COMPILE
0007b7 382e                          .dw XT_DOBRANCH
0007b8 078d                          .dw XT_GMARK
0007b9 38c3                          .dw XT_SWAP
0007ba 0792                          .dw XT_GRESOLVE
0007bb 381f                          .dw XT_EXIT
                                 .include "words/then.asm"
                                 
                                 ; Compiler
                                 ; finish if
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_THEN:
0007bc 0004                          .dw $0004
0007bd 6874
0007be 6e65                          .db "then"
0007bf 07b1                          .dw VE_HEAD
                                     .set VE_HEAD = VE_THEN
                                 XT_THEN:
0007c0 3800                          .dw DO_COLON
                                 PFA_THEN:
                                 .endif
0007c1 0792                          .dw XT_GRESOLVE
0007c2 381f                          .dw XT_EXIT
                                 .include "words/begin.asm"
                                 
                                 ; Compiler
                                 ; put the next location for a transfer of control onto the control flow stack
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_BEGIN:
0007c3 0005                          .dw $0005
0007c4 6562
0007c5 6967
0007c6 006e                          .db "begin",0
0007c7 07bc                          .dw VE_HEAD
                                     .set VE_HEAD = VE_BEGIN
                                 XT_BEGIN:
0007c8 3800                          .dw DO_COLON
                                 PFA_BEGIN:
                                 .endif
0007c9 0798                          .dw XT_LMARK
0007ca 381f                          .dw XT_EXIT
                                 .include "words/while.asm"
                                 
                                 ; Compiler
                                 ; at runtime skip until repeat if non-true
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_WHILE:
0007cb 0005                          .dw $0005
0007cc 6877
0007cd 6c69
0007ce 0065                          .db "while",0
0007cf 07c3                          .dw VE_HEAD
                                     .set VE_HEAD = VE_WHILE
                                 XT_WHILE:
0007d0 3800                          .dw DO_COLON
                                 PFA_WHILE:
                                 .endif
0007d1 07ac                          .dw XT_IF
0007d2 38c3                          .dw XT_SWAP
0007d3 381f                          .dw XT_EXIT
                                 .include "words/repeat.asm"
                                 
                                 ; Compiler
                                 ; continue execution at dest, resolve orig
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_REPEAT:
0007d4 0006                          .dw $0006
0007d5 6572
0007d6 6570
0007d7 7461                          .db "repeat"
0007d8 07cb                          .dw VE_HEAD
                                     .set VE_HEAD = VE_REPEAT
                                 XT_REPEAT:
0007d9 3800                          .dw DO_COLON
                                 PFA_REPEAT:
                                 .endif
0007da 07ed                          .dw XT_AGAIN
0007db 07c0                          .dw XT_THEN
0007dc 381f                          .dw XT_EXIT
                                 .include "words/until.asm"
                                 
                                 ; Compiler
                                 ; finish begin with conditional branch, leaves the loop if true flag at runtime
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_UNTIL:
0007dd 0005                          .dw $0005
0007de 6e75
0007df 6974
0007e0 006c                          .db "until",0
0007e1 07d4                          .dw VE_HEAD
                                     .set VE_HEAD = VE_UNTIL
                                 XT_UNTIL:
0007e2 3800                          .dw DO_COLON
                                 PFA_UNTIL:
                                 .endif
0007e3 383c                          .dw XT_DOLITERAL
0007e4 3835                          .dw XT_DOCONDBRANCH
0007e5 0767                          .dw XT_COMMA
                                 
0007e6 079b                          .dw XT_LRESOLVE
0007e7 381f                          .dw XT_EXIT
                                 .include "words/again.asm"
                                 
                                 ; Compiler
                                 ; compile a jump back to dest
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_AGAIN:
0007e8 0005                          .dw $0005
0007e9 6761
0007ea 6961
0007eb 006e                          .db "again",0
0007ec 07dd                          .dw VE_HEAD
                                     .set VE_HEAD = VE_AGAIN
                                 XT_AGAIN:
0007ed 3800                          .dw DO_COLON
                                 PFA_AGAIN:
                                 .endif
0007ee 075c                          .dw XT_COMPILE
0007ef 382e                          .dw XT_DOBRANCH
0007f0 079b                          .dw XT_LRESOLVE
0007f1 381f                          .dw XT_EXIT
                                 .include "words/do.asm"
                                 
                                 ; Compiler
                                 ; start do .. [+]loop
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_DO:
0007f2 0002                          .dw $0002
0007f3 6f64                          .db "do"
0007f4 07e8                          .dw VE_HEAD
                                     .set VE_HEAD = VE_DO
                                 XT_DO:
0007f5 3800                          .dw DO_COLON
                                 PFA_DO:
                                 
                                 .endif
0007f6 075c                          .dw XT_COMPILE
0007f7 3a9a                          .dw XT_DODO
0007f8 0798                          .dw XT_LMARK
0007f9 3953                          .dw XT_ZERO
0007fa 0850                          .dw XT_TO_L
0007fb 381f                          .dw XT_EXIT
                                 .include "words/loop.asm"
                                 
                                 ; Compiler
                                 ; compile (loop) and resolve the backward branch
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_LOOP:
0007fc 0004                          .dw $0004
0007fd 6f6c
0007fe 706f                          .db "loop"
0007ff 07f2                          .dw VE_HEAD
                                     .set VE_HEAD = VE_LOOP
                                 XT_LOOP:
000800 3800                          .dw DO_COLON
                                 PFA_LOOP:
                                 .endif
000801 075c                          .dw XT_COMPILE
000802 3ac8                          .dw XT_DOLOOP
000803 0837                          .dw XT_ENDLOOP
000804 381f                          .dw XT_EXIT
                                 .include "words/plusloop.asm"
                                 
                                 ; Compiler
                                 ; compile (+loop) and resolve branches
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_PLUSLOOP:
000805 0005                          .dw $0005
000806 6c2b
000807 6f6f
000808 0070                          .db "+loop",0
000809 07fc                          .dw VE_HEAD
                                     .set VE_HEAD = VE_PLUSLOOP
                                 XT_PLUSLOOP:
00080a 3800                          .dw DO_COLON
                                 PFA_PLUSLOOP:
                                 .endif
00080b 075c                          .dw XT_COMPILE
00080c 3ab9                          .dw XT_DOPLUSLOOP
00080d 0837                          .dw XT_ENDLOOP
00080e 381f                          .dw XT_EXIT
                                 .include "words/leave.asm"
                                 
                                 ; Compiler
                                 ; immediatly leave the current DO..LOOP
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_LEAVE:
00080f 0005                         .dw $0005
000810 656c
000811 7661
000812 0065                         .db "leave",0
000813 0805                         .dw VE_HEAD
                                    .set VE_HEAD = VE_LEAVE
                                 XT_LEAVE:
000814 3800                          .dw DO_COLON
                                 PFA_LEAVE:
                                 .endif
000815 075c
000816 3ad3                          .DW XT_COMPILE,XT_UNLOOP
000817 07a4
000818 0850
000819 381f                          .DW XT_AHEAD,XT_TO_L,XT_EXIT
                                 .include "words/qdo.asm"
                                 
                                 ; Compiler
                                 ; start a ?do .. [+]loop control structure
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 
                                 VE_QDO:
00081a 0003                          .dw $0003
00081b 643f
00081c 006f                          .db "?do",0
00081d 080f                          .dw VE_HEAD
                                     .set VE_HEAD = VE_QDO
                                 XT_QDO:
00081e 3800                          .dw DO_COLON
                                 PFA_QDO:
                                 .endif
00081f 075c                          .dw XT_COMPILE
000820 0826                          .dw XT_QDOCHECK
000821 07ac                          .dw XT_IF
000822 07f5                          .dw XT_DO
000823 38c3                          .dw XT_SWAP    ; DO sets a 0 marker on the leave stack
000824 0850                          .dw XT_TO_L    ; then follows at the end.
000825 381f                          .dw XT_EXIT
                                 
                                 ; there is no special runtime for ?do, the do runtime
                                 ; gets wrapped with the sequence
                                 ; ... ?do-check if do ..... loop then
                                 ; with
                                 ; : ?do-check ( n1 n2 -- n1 n2 true | false )
                                 ;   2dup = dup >r if 2drop then r> invert ;
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 XT_QDOCHECK:
000826 3800                          .dw DO_COLON
                                 PFA_QDOCHECK:
                                 .endif
000827 3ec8                          .dw XT_2DUP
000828 3fde                          .dw XT_EQUAL
000829 38b0                          .dw XT_DUP
00082a 38fe                          .dw XT_TO_R
00082b 3835                          .dw XT_DOCONDBRANCH
00082c 082e                          DEST(PFA_QDOCHECK1)
00082d 3ed1                          .dw XT_2DROP
                                 PFA_QDOCHECK1:
00082e 38f5                          .dw XT_R_FROM
00082f 39fc                          .dw XT_INVERT
000830 381f                          .dw XT_EXIT
                                 .include "words/endloop.asm"
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_ENDLOOP:
000831 ff07                          .dw $ff07
000832 6e65
000833 6c64
000834 6f6f
000835 0070                          .db "endloop",0
000836 081a                          .dw VE_HEAD
                                     .set VE_HEAD = VE_ENDLOOP
                                 XT_ENDLOOP:
000837 3800                          .dw DO_COLON
                                 PFA_ENDLOOP:
                                 .endif
                                 ;Z ENDLOOP   adrs xt --   L: 0 a1 a2 .. aN --
                                 ;   <resolve                backward loop
                                 ;   BEGIN L> ?DUP WHILE POSTPONE THEN REPEAT ;
                                 ;                                 resolve LEAVEs
                                 ; This is a common factor of LOOP and +LOOP.
                                 
000838 079b                              .DW XT_LRESOLVE
000839 0844
00083a 38b8
00083b 3835                      LOOP1:  .DW XT_L_FROM,XT_QDUP,XT_DOCONDBRANCH
00083c 0840                               DEST(LOOP2)
00083d 07c0                              .DW XT_THEN
00083e 382e                      	.dw XT_DOBRANCH
00083f 0839                               DEST(LOOP1)
000840 381f                      LOOP2:  .DW XT_EXIT
                                 ; leave address stack
                                 .include "words/l-from.asm"
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_L_FROM:
000841 ff02                          .dw $ff02
000842 3e6c                          .db "l>"
000843 0831                          .dw VE_HEAD
                                     .set VE_HEAD = VE_L_FROM
                                 XT_L_FROM:
000844 3800                          .dw DO_COLON
                                 PFA_L_FROM:
                                 
                                 .endif
                                 ;Z L>   -- x   L: x --      move from leave stack
                                 ;   LP @ @  -2 LP +! ;
                                 
000845 0863                          .dw XT_LP
000846 3878                          .dw XT_FETCH
000847 3878                          .dw XT_FETCH
000848 383c                          .dw XT_DOLITERAL
000849 fffe                          .dw -2
00084a 0863                          .dw XT_LP
00084b 3a64                          .dw XT_PLUSSTORE
00084c 381f                          .dw XT_EXIT
                                 .include "words/to-l.asm"
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_TO_L:
00084d ff02                          .dw $ff02
00084e 6c3e                          .db ">l"
00084f 0841                          .dw VE_HEAD
                                     .set VE_HEAD = VE_TO_L
                                 XT_TO_L:
000850 3800                          .dw DO_COLON
                                 PFA_TO_L:
                                 .endif
                                 ;Z >L   x --   L: -- x        move to leave stack
                                 ;   CELL LP +!  LP @ ! ;      (L stack grows up)
                                 
000851 3fea                              .dw XT_TWO
000852 0863                      	.dw XT_LP
000853 3a64                      	.dw XT_PLUSSTORE
000854 0863                      	.dw XT_LP
000855 3878                      	.dw XT_FETCH
000856 3880                      	.dw XT_STORE
000857 381f                      	.dw XT_EXIT
                                 .include "words/lp0.asm"
                                 
                                 ; Stack
                                 ; start address of leave stack
                                 VE_LP0:
000858 ff03                          .dw $ff03
000859 706c
00085a 0030                          .db "lp0",0
00085b 084d                          .dw VE_HEAD
                                     .set VE_HEAD = VE_LP0
                                 XT_LP0:
00085c 386e                          .dw PFA_DOVALUE1
                                 PFA_LP0:
00085d 0040                          .dw CFG_LP0
00085e 3d9f                          .dw XT_EDEFERFETCH
00085f 3da9                          .dw XT_EDEFERSTORE
                                 .include "words/lp.asm"
                                 
                                 ; System Variable
                                 ; leave stack pointer
                                 VE_LP:
000860 ff02                          .dw $ff02
000861 706c                          .db "lp"
000862 0858                          .dw VE_HEAD
                                     .set VE_HEAD = VE_LP
                                 XT_LP:
000863 3847                          .dw PFA_DOVARIABLE
                                 PFA_LP:
000864 0190                          .dw ram_lp
                                 
                                 .dseg
000190                           ram_lp: .byte 2
                                 .cseg
                                 
                                 
                                 .include "words/create.asm"
                                 
                                 ; Dictionary
                                 ; create a dictionary header. XT is (constant), with the address of the data field of name
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_CREATE:
000865 ff06                          .dw $ff06
000866 7263
000867 6165
000868 6574                          .db "create"
000869 0860                          .dw VE_HEAD
                                     .set VE_HEAD = VE_CREATE
                                 XT_CREATE:
00086a 3800                          .dw DO_COLON
                                 PFA_CREATE:
                                 .endif
00086b 0739                          .dw XT_DOCREATE
00086c 0899                          .dw XT_REVEAL
00086d 075c                          .dw XT_COMPILE
00086e 3851                          .dw PFA_DOCONSTANT
00086f 381f                          .dw XT_EXIT
                                 .include "words/header.asm"
                                 
                                 ; Compiler
                                 ; creates the vocabulary header without XT and data field (PF) in the wordlist wid
                                 VE_HEADER:
000870 ff06                          .dw $ff06
000871 6568
000872 6461
000873 7265                          .db "header"
000874 0865                          .dw VE_HEAD
                                     .set VE_HEAD = VE_HEADER
                                 XT_HEADER:
000875 3800                          .dw DO_COLON
                                 PFA_HEADER:
000876 3f11                          .dw XT_DP           ; the new Name Field
000877 38fe                          .dw XT_TO_R
000878 38fe                          .dw XT_TO_R		; ( R: NFA WID )
000879 38b0                          .dw XT_DUP    
00087a 3927                          .dw XT_GREATERZERO 
00087b 3835                          .dw XT_DOCONDBRANCH
00087c 0887                          .dw PFA_HEADER1
00087d 38b0                          .dw XT_DUP
00087e 383c                          .dw XT_DOLITERAL
00087f ff00                          .dw $ff00           ; all flags are off (e.g. immediate)
000880 3a1b                          .dw XT_OR
000881 03e2                          .dw XT_DOSCOMMA
                                     ; make the link to the previous entry in this wordlist
000882 38f5                          .dw XT_R_FROM
000883 3b5e                          .dw XT_FETCHE
000884 0767                          .dw XT_COMMA
000885 38f5                          .dw XT_R_FROM
000886 381f                          .dw XT_EXIT
                                 
                                 PFA_HEADER1:
                                     ; -16: attempt to use zero length string as a name
000887 383c                          .dw XT_DOLITERAL
000888 fff0                          .dw -16
000889 3d85                          .dw XT_THROW
                                 
                                 .include "words/wlscope.asm"
                                 
                                 ; Compiler
                                 ; dynamically place a word in a wordlist. The word name may be changed.
                                 VE_WLSCOPE:
00088a ff07                          .dw $ff07
00088b 6c77
00088c 6373
00088d 706f
00088e 0065                          .db "wlscope",0
00088f 0870                          .dw VE_HEAD
                                     .set VE_HEAD = VE_WLSCOPE
                                 XT_WLSCOPE:
000890 3dfe                          .dw PFA_DODEFER1
                                 PFA_WLSCOPE:
000891 003c                          .dw CFG_WLSCOPE
000892 3d9f                          .dw XT_EDEFERFETCH
000893 3da9                          .dw XT_EDEFERSTORE
                                 
                                 ; wlscope, "wordlist scope" ( addr len -- addr' len' wid ), is a deferred word
                                 ; which enables the AmForth application to choose the wordlist ( wid ) for the
                                 ; new voc entry based on the input ( addr len ) string. The name of the new voc
                                 ; entry ( addr' len' ) may be different from the input string. Note that all
                                 ; created voc entry types pass through the wlscope mechanism. The default
                                 ; wlscope action passes the input string to the output without modification and
                                 ; uses get-current to select the wid.
                                 .include "words/reveal.asm"
                                 
                                 ; Dictionary
                                 ; makes an entry in a wordlist visible, if not already done.
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_REVEAL:
000894 ff06                          .dw $ff06
000895 6572
000896 6576
000897 6c61                          .db "reveal"
000898 088a                          .dw VE_HEAD
                                     .set VE_HEAD = VE_REVEAL
                                 XT_REVEAL:
000899 3800                          .dw DO_COLON
                                 PFA_REVEAL:
                                 .endif
00089a 072a
00089b 3c8f
00089c 3878                          .DW XT_NEWEST,XT_CELLPLUS,XT_FETCH ; only if wordlist is in use
00089d 38b8
00089e 3835                          .DW XT_QDUP,XT_DOCONDBRANCH
00089f 08a4                          DEST(REVEAL1)
0008a0 072a
0008a1 3878
0008a2 38c3
0008a3 3b3a                          .DW XT_NEWEST,XT_FETCH,XT_SWAP,XT_STOREE
                                 ;    .DW XT_ZERO,XT_NEWEST,XT_CELLPLUS,XT_STORE ; clean wordlist entry
                                 REVEAL1:
0008a4 381f                          .DW XT_EXIT
                                 .include "words/does.asm"
                                 
                                 ; Compiler
                                 ; organize the XT replacement to call other colon code
                                 VE_DOES:
0008a5 0005                          .dw $0005
0008a6 6f64
0008a7 7365
0008a8 003e                          .db "does>",0
0008a9 0894                          .dw VE_HEAD
                                     .set VE_HEAD = VE_DOES
                                 XT_DOES:
0008aa 3800                          .dw DO_COLON
                                 PFA_DOES:
0008ab 075c                          .dw XT_COMPILE
0008ac 08bd                          .dw XT_DODOES
0008ad 075c                          .dw XT_COMPILE  ; create a code snippet to be used in an embedded XT
0008ae 940e                          .dw $940e       ; the address of this compiled
0008af 075c                          .dw XT_COMPILE  ; code will replace the XT of the 
0008b0 08b2                          .dw DO_DODOES   ; word that CREATE created
0008b1 381f                          .dw XT_EXIT     ; 
                                 
                                 DO_DODOES: ; ( -- PFA )
0008b2 939a
0008b3 938a                          savetos
0008b4 01cb                          movw tosl, wl
0008b5 9601                          adiw tosl, 1
                                     ; the following takes the address from a real uC-call
                                 .if (pclen==3)
                                 .endif
0008b6 917f                          pop wh
0008b7 916f                          pop wl
                                 
0008b8 93bf                          push XH
0008b9 93af                          push XL
0008ba 01db                          movw XL, wl
0008bb 940c 3804                     jmp_ DO_NEXT
                                 
                                 ; ( -- )
                                 ; System
                                 ; replace the XT written by CREATE to call the code that follows does>
                                 ;VE_DODOES:
                                 ;   .dw $ff07
                                 ;   .db "(does>)"
                                 ;   .set VE_HEAD = VE_DODOES
                                 XT_DODOES:
0008bd 3800                          .dw DO_COLON
                                 PFA_DODOES:
0008be 38f5                          .dw XT_R_FROM
0008bf 072a                          .dw XT_NEWEST
0008c0 3c8f                          .dw XT_CELLPLUS
0008c1 3878                          .dw XT_FETCH
0008c2 3b5e                          .dw XT_FETCHE
0008c3 0701                          .dw XT_NFA2CFA
0008c4 3b72                          .dw XT_STOREI
0008c5 381f                          .dw XT_EXIT
                                 .include "words/colon.asm"
                                 
                                 ; Compiler
                                 ; create a named entry in the dictionary, XT is DO_COLON
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_COLON:
0008c6 ff01                          .dw $ff01
0008c7 003a                          .db ":",0
0008c8 08a5                          .dw VE_HEAD
                                     .set VE_HEAD = VE_COLON
                                 XT_COLON:
0008c9 3800                          .dw DO_COLON
                                 PFA_COLON:
                                 .endif
0008ca 0739                          .dw XT_DOCREATE
0008cb 08d4                          .dw XT_COLONNONAME
0008cc 38d8                          .dw XT_DROP
0008cd 381f                          .dw XT_EXIT
                                 .include "words/colon-noname.asm"
                                 
                                 ; Compiler
                                 ; create an unnamed entry in the dictionary, XT is DO_COLON
                                 VE_COLONNONAME:
0008ce ff07                          .dw $ff07
0008cf 6e3a
0008d0 6e6f
0008d1 6d61
0008d2 0065                          .db ":noname",0
0008d3 08c6                          .dw VE_HEAD
                                     .set VE_HEAD = VE_COLONNONAME
                                 XT_COLONNONAME:
0008d4 3800                          .dw DO_COLON
                                 PFA_COLONNONAME:
0008d5 3f11                          .dw XT_DP
0008d6 38b0                          .dw XT_DUP
0008d7 0731                          .dw XT_LATEST
0008d8 3880                          .dw XT_STORE
                                 
0008d9 075c                          .dw XT_COMPILE
0008da 3800                          .dw DO_COLON
                                 
0008db 08e9                          .dw XT_RBRACKET
0008dc 381f                          .dw XT_EXIT
                                 .include "words/semicolon.asm"
                                 
                                 ; Compiler
                                 ; finish colon defintion, compiles (exit) and returns to interpret state 
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 
                                 
                                 VE_SEMICOLON:
0008dd 0001                          .dw $0001
0008de 003b                          .db $3b,0
0008df 08ce                          .dw VE_HEAD
                                     .set VE_HEAD = VE_SEMICOLON
                                 XT_SEMICOLON:
0008e0 3800                          .dw DO_COLON
                                 PFA_SEMICOLON:
                                 .endif
0008e1 075c                          .dw XT_COMPILE
0008e2 381f                          .dw XT_EXIT
0008e3 08f1                          .dw XT_LBRACKET
0008e4 0899                          .dw XT_REVEAL
0008e5 381f                          .dw XT_EXIT
                                 .include "words/right-bracket.asm"
                                 
                                 ; Compiler
                                 ; enter compiler mode
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_RBRACKET:
0008e6 ff01                          .dw $ff01
0008e7 005d                          .db "]",0
0008e8 08dd                          .dw VE_HEAD
                                     .set VE_HEAD = VE_RBRACKET
                                 XT_RBRACKET:
0008e9 3800                          .dw DO_COLON
                                 PFA_RBRACKET:
                                 .endif
0008ea 3fe5                          .dw XT_ONE
0008eb 3eb6                          .dw XT_STATE
0008ec 3880                          .dw XT_STORE
0008ed 381f                          .dw XT_EXIT
                                 .include "words/left-bracket.asm"
                                 
                                 ; Compiler
                                 ; enter interpreter mode
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_LBRACKET:
0008ee 0001                          .dw $0001
0008ef 005b                          .db "[",0
0008f0 08e6                          .dw VE_HEAD
                                     .set VE_HEAD = VE_LBRACKET
                                 XT_LBRACKET:
0008f1 3800                          .dw DO_COLON
                                 PFA_LBRACKET:
                                 .endif
0008f2 3953                          .dw XT_ZERO
0008f3 3eb6                          .dw XT_STATE
0008f4 3880                          .dw XT_STORE
0008f5 381f                          .dw XT_EXIT
                                 .include "words/variable.asm"
                                 
                                 ; Compiler
                                 ; create a dictionary entry for a variable and allocate 1 cell RAM
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 
                                 VE_VARIABLE:
0008f6 ff08                          .dw $ff08
0008f7 6176
0008f8 6972
0008f9 6261
0008fa 656c                          .db "variable"
0008fb 08ee                          .dw VE_HEAD
                                     .set VE_HEAD = VE_VARIABLE
                                 XT_VARIABLE:
0008fc 3800                          .dw DO_COLON
                                 PFA_VARIABLE:
                                 .endif
0008fd 3f22                          .dw XT_HERE
0008fe 0908                          .dw XT_CONSTANT
0008ff 3fea                          .dw XT_TWO
000900 3f2b                          .dw XT_ALLOT
000901 381f                          .dw XT_EXIT
                                 .include "words/constant.asm"
                                 
                                 ; Compiler
                                 ; create a constant in the dictionary
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 
                                 VE_CONSTANT:
000902 ff08                          .dw $ff08
000903 6f63
000904 736e
000905 6174
000906 746e                          .db "constant"
000907 08f6                          .dw VE_HEAD
                                     .set VE_HEAD = VE_CONSTANT
                                 XT_CONSTANT:
000908 3800                          .dw DO_COLON
                                 PFA_CONSTANT:
                                 .endif
000909 0739                          .dw XT_DOCREATE
00090a 0899                          .dw XT_REVEAL
00090b 075c                          .dw XT_COMPILE
00090c 3847                          .dw PFA_DOVARIABLE
00090d 0767                          .dw XT_COMMA
00090e 381f                          .dw XT_EXIT
                                 .include "words/user.asm"
                                 
                                 ; Compiler
                                 ; create a dictionary entry for a user variable at offset n
                                 VE_USER:
00090f ff04                          .dw $ff04
000910 7375
000911 7265                          .db "user"
000912 0902                          .dw VE_HEAD
                                     .set VE_HEAD = VE_USER
                                 XT_USER:
000913 3800                          .dw DO_COLON
                                 PFA_USER:
000914 0739                          .dw XT_DOCREATE
000915 0899                          .dw XT_REVEAL
                                 
000916 075c                          .dw XT_COMPILE
000917 3857                          .dw PFA_DOUSER
000918 0767                          .dw XT_COMMA
000919 381f                          .dw XT_EXIT
                                 
                                 .include "words/recurse.asm"
                                 
                                 ; Compiler
                                 ; compile the XT of the word currently being defined into the dictionary
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_RECURSE:
00091a 0007                          .dw $0007
00091b 6572
00091c 7563
00091d 7372
00091e 0065                          .db "recurse",0
00091f 090f                          .dw VE_HEAD
                                     .set VE_HEAD = VE_RECURSE
                                 XT_RECURSE:
000920 3800                          .dw DO_COLON
                                 PFA_RECURSE:
                                 .endif
000921 0731                          .dw XT_LATEST
000922 3878                          .dw XT_FETCH
000923 0767                          .dw XT_COMMA
000924 381f                          .dw XT_EXIT
                                 .include "words/immediate.asm"
                                 
                                 ; Compiler
                                 ; set immediate flag for the most recent word definition
                                 VE_IMMEDIATE:
000925 ff09                          .dw $ff09
000926 6d69
000927 656d
000928 6964
000929 7461
00092a 0065                          .db "immediate",0
00092b 091a                          .dw VE_HEAD
                                     .set VE_HEAD = VE_IMMEDIATE
                                 XT_IMMEDIATE:
00092c 3800                          .dw DO_COLON
                                 PFA_IMMEDIATE:
00092d 09ce                          .dw XT_GET_CURRENT
00092e 3b5e                          .dw XT_FETCHE
00092f 38b0                          .dw XT_DUP
000930 3bca                          .dw XT_FETCHI
000931 383c                          .dw XT_DOLITERAL
000932 7fff                          .dw $7fff
000933 3a12                          .dw XT_AND
000934 38c3                          .dw XT_SWAP
000935 3b72                          .dw XT_STOREI
000936 381f                          .dw XT_EXIT
                                 
                                 .include "words/bracketchar.asm"
                                 
                                 ; Tools
                                 ; skip leading space delimites, place the first character of the word on the stack
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_BRACKETCHAR:
000937 0006                          .dw $0006
000938 635b
000939 6168
00093a 5d72                          .db "[char]"
00093b 0925                          .dw VE_HEAD
                                     .set VE_HEAD = VE_BRACKETCHAR
                                 XT_BRACKETCHAR:
00093c 3800                          .dw DO_COLON
                                 PFA_BRACKETCHAR:
                                 .endif
00093d 075c                          .dw XT_COMPILE
00093e 383c                          .dw XT_DOLITERAL
00093f 04f1                          .dw XT_CHAR
000940 0767                          .dw XT_COMMA
000941 381f                          .dw XT_EXIT
                                 .include "words/abort-string.asm"
                                 
                                 ;C         i*x x1 --       R: j*x --      x1<>0
                                 ;   POSTPONE IS" POSTPONE ?ABORT ; IMMEDIATE
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_ABORTQUOTE:
000942 0006                          .dw $0006
000943 6261
000944 726f
000945 2274                          .db "abort",'"'
000946 0937                          .dw VE_HEAD
                                     .set VE_HEAD = VE_ABORTQUOTE
                                 XT_ABORTQUOTE:
000947 3800                          .dw DO_COLON
                                 PFA_ABORTQUOTE:
                                 .endif
000948 3e89                          .dw XT_SQUOTE
000949 075c                          .dw XT_COMPILE
00094a 0959                          .dw XT_QABORT
00094b 381f                          .DW XT_EXIT
                                 .include "words/abort.asm"
                                 
                                 ; Exceptions
                                 ; send an exception -1
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_ABORT:
00094c ff05                          .dw $ff05
00094d 6261
00094e 726f
00094f 0074                          .db "abort",0
000950 0942                          .dw VE_HEAD
                                     .set VE_HEAD = VE_ABORT
                                 XT_ABORT:
000951 3800                          .dw DO_COLON
                                 PFA_ABORT:
                                 .endif
000952 394a                          .dw XT_TRUE
000953 3d85                          .dw XT_THROW
                                 .include "words/q-abort.asm"
                                 
                                 ;   ROT IF ITYPE ABORT THEN 2DROP ;
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_QABORT:
000954 ff06                          .dw $ff06
000955 613f
000956 6f62
000957 7472                          .db "?abort"
000958 094c                          .dw VE_HEAD
                                     .set VE_HEAD = VE_QABORT
                                 XT_QABORT:
000959 3800                          .dw DO_COLON
                                 PFA_QABORT:
                                 
                                 .endif
00095a 38e0
00095b 3835                              .DW XT_ROT,XT_DOCONDBRANCH
00095c 095f                              DEST(QABO1)
00095d 0403
00095e 0951                              .DW XT_ITYPE,XT_ABORT
00095f 3ed1
000960 381f                      QABO1:  .DW XT_2DROP,XT_EXIT
                                 
                                 .include "words/get-stack.asm"
                                 
                                 ; Tools
                                 ; Get a stack from EEPROM
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_GET_STACK:
000961 ff09                          .dw $ff09
000962 6567
000963 2d74
000964 7473
000965 6361
000966 006b                          .db "get-stack",0
000967 0954                          .dw VE_HEAD
                                     .set VE_HEAD = VE_GET_STACK
                                 XT_GET_STACK:
000968 3800                          .dw DO_COLON
                                 .endif
000969 38b0                          .dw XT_DUP
00096a 3c8f                          .dw XT_CELLPLUS
00096b 38c3                          .dw XT_SWAP
00096c 3b5e                          .dw XT_FETCHE
00096d 38b0                          .dw XT_DUP
00096e 38fe                          .dw XT_TO_R
00096f 3953                          .dw XT_ZERO
000970 38c3                          .dw XT_SWAP    ; go from bigger to smaller addresses
000971 0826                          .dw XT_QDOCHECK
000972 3835                          .dw XT_DOCONDBRANCH
000973 097f                          DEST(PFA_N_FETCH_E2)
000974 3a9a                          .dw XT_DODO
                                 PFA_N_FETCH_E1:
                                     ; ( ee-addr )
000975 3aab                          .dw XT_I
000976 3a34                          .dw XT_1MINUS
000977 3ec3                          .dw XT_CELLS ; ( -- ee-addr i*2 )
000978 38ce                          .dw XT_OVER  ; ( -- ee-addr i*2 ee-addr )
000979 399c                          .dw XT_PLUS  ; ( -- ee-addr ee-addr+i
00097a 3b5e                          .dw XT_FETCHE ;( -- ee-addr item_i )
00097b 38c3                          .dw XT_SWAP   ;( -- item_i ee-addr )
00097c 394a                          .dw XT_TRUE  ; shortcut for -1
00097d 3ab9                          .dw XT_DOPLUSLOOP
00097e 0975                          DEST(PFA_N_FETCH_E1)
                                 PFA_N_FETCH_E2:
00097f 3ed1                          .dw XT_2DROP
000980 38f5                          .dw XT_R_FROM
000981 381f                          .dw XT_EXIT
                                 
                                 .include "words/set-stack.asm"
                                 
                                 ; Tools
                                 ; Write a stack to EEPROM
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_SET_STACK:
000982 ff09                          .dw $ff09
000983 6573
000984 2d74
000985 7473
000986 6361
000987 006b                          .db "set-stack",0
000988 0961                          .dw VE_HEAD
                                     .set VE_HEAD = VE_SET_STACK
                                 XT_SET_STACK:
000989 3800                          .dw DO_COLON
                                 PFA_SET_STACK:
                                 .endif
00098a 38ce                          .dw XT_OVER
00098b 3920                          .dw XT_ZEROLESS
00098c 3835                          .dw XT_DOCONDBRANCH
00098d 0991                          DEST(PFA_SET_STACK0)
00098e 383c                          .dw XT_DOLITERAL
00098f fffc                          .dw -4
000990 3d85                          .dw XT_THROW
                                 PFA_SET_STACK0:
000991 3ec8                          .dw XT_2DUP
000992 3b3a                          .dw XT_STOREE ; ( -- i_n .. i_0 n e-addr )
000993 38c3                          .dw XT_SWAP    
000994 3953                          .dw XT_ZERO
000995 0826                          .dw XT_QDOCHECK
000996 3835                          .dw XT_DOCONDBRANCH
000997 099e                          DEST(PFA_SET_STACK2)
000998 3a9a                          .dw XT_DODO
                                 PFA_SET_STACK1:
000999 3c8f                          .dw XT_CELLPLUS ; ( -- i_x e-addr )
00099a 3ed9                          .dw XT_TUCK      ; ( -- e-addr i_x e-addr
00099b 3b3a                          .dw XT_STOREE
00099c 3ac8                          .dw XT_DOLOOP
00099d 0999                          DEST(PFA_SET_STACK1)
                                 PFA_SET_STACK2:
00099e 38d8                          .dw XT_DROP
00099f 381f                          .dw XT_EXIT
                                 
                                 .include "words/map-stack.asm"
                                 
                                 ; Tools
                                 ; Iterate over a stack
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_MAPSTACK:
0009a0 ff09                          .dw $ff09
0009a1 616d
0009a2 2d70
0009a3 7473
0009a4 6361
0009a5 006b                          .db "map-stack",0
0009a6 0982                          .dw VE_HEAD
                                     .set VE_HEAD = VE_MAPSTACK
                                 XT_MAPSTACK:
0009a7 3800                          .dw DO_COLON
                                 PFA_MAPSTACK:
                                 .endif
0009a8 38b0                          .dw XT_DUP
0009a9 3c8f                          .dw XT_CELLPLUS
0009aa 38c3                          .dw XT_SWAP
0009ab 3b5e                          .dw XT_FETCHE
0009ac 3ec3                          .dw XT_CELLS
0009ad 3f98                          .dw XT_BOUNDS
0009ae 0826                          .dw XT_QDOCHECK
0009af 3835                          .dw XT_DOCONDBRANCH
0009b0 09c3                          DEST(PFA_MAPSTACK3)
0009b1 3a9a                          .dw XT_DODO
                                 PFA_MAPSTACK1:
0009b2 3aab                            .dw XT_I
0009b3 3b5e                            .dw XT_FETCHE   ; -- i*x XT id
0009b4 38c3                            .dw XT_SWAP
0009b5 38fe                            .dw XT_TO_R
0009b6 3907                            .dw XT_R_FETCH
0009b7 3829                            .dw XT_EXECUTE  ; i*x id -- j*y true | i*x false
0009b8 38b8                            .dw XT_QDUP
0009b9 3835                            .dw XT_DOCONDBRANCH
0009ba 09bf                            DEST(PFA_MAPSTACK2)
0009bb 38f5                               .dw XT_R_FROM
0009bc 38d8                               .dw XT_DROP
0009bd 3ad3                               .dw XT_UNLOOP
0009be 381f                               .dw XT_EXIT
                                 PFA_MAPSTACK2:
0009bf 38f5                            .dw XT_R_FROM
0009c0 3fea                            .dw XT_TWO
0009c1 3ab9                            .dw XT_DOPLUSLOOP
0009c2 09b2                            DEST(PFA_MAPSTACK1)
                                 PFA_MAPSTACK3:
0009c3 38d8                          .dw XT_DROP
0009c4 3953                          .dw XT_ZERO
0009c5 381f                          .dw XT_EXIT
                                 
                                 ;
                                 ; : map-stack ( i*x XT e-addr -- j*y )
                                 ;     dup cell+ swap @e cells bounds ?do 
                                 ;       ( -- i*x XT )
                                 ;       i @e swap >r r@ execute
                                 ;       ?dup if r> drop unloop exit then
                                 ;       r>
                                 ;     2 +loop drop 0
                                 ; ;
                                 .include "words/get-current.asm"
                                 
                                 ; Search Order
                                 ; get the wid of the current compilation word list
                                 VE_GET_CURRENT:
0009c6 ff0b                          .dw $ff0b
0009c7 6567
0009c8 2d74
0009c9 7563
0009ca 7272
0009cb 6e65
0009cc 0074                          .db "get-current",0
0009cd 09a0                          .dw VE_HEAD
                                     .set VE_HEAD = VE_GET_CURRENT
                                 XT_GET_CURRENT:
0009ce 3800                          .dw DO_COLON
                                 PFA_GET_CURRENT:
0009cf 383c                          .dw XT_DOLITERAL
0009d0 0046                          .dw CFG_CURRENT
0009d1 3b5e                          .dw XT_FETCHE
0009d2 381f                          .dw XT_EXIT
                                 .include "words/get-order.asm"
                                 
                                 ; Search Order
                                 ; Get the current search order word list
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_GET_ORDER:
0009d3 ff09                          .dw $ff09
0009d4 6567
0009d5 2d74
0009d6 726f
0009d7 6564
0009d8 0072                          .db "get-order",0
0009d9 09c6                          .dw VE_HEAD
                                     .set VE_HEAD = VE_GET_ORDER
                                 XT_GET_ORDER:
0009da 3800                          .dw DO_COLON
                                 PFA_GET_ORDER:
                                 .endif
0009db 383c                          .dw XT_DOLITERAL
0009dc 004a                          .dw CFG_ORDERLISTLEN
0009dd 0968                          .dw XT_GET_STACK
0009de 381f                          .dw XT_EXIT
                                 .include "words/cfg-order.asm"
                                 
                                 ; Search Order
                                 ; Get the current search order word list
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_CFG_ORDER:
0009df ff09                          .dw $ff09
0009e0 6663
0009e1 2d67
0009e2 726f
0009e3 6564
0009e4 0072                          .db "cfg-order",0
0009e5 09d3                          .dw VE_HEAD
                                     .set VE_HEAD = VE_CFG_ORDER
                                 XT_CFG_ORDER:
0009e6 3847                          .dw PFA_DOVARIABLE
                                 PFA_CFG_ORDER:
                                 .endif
0009e7 004a                          .dw CFG_ORDERLISTLEN
                                 .include "words/compare.asm"
                                 
                                 ; String
                                 ; compares two strings in RAM
                                 VE_COMPARE:
0009e8 ff07                          .dw $ff07
0009e9 6f63
0009ea 706d
0009eb 7261
0009ec 0065                          .db "compare",0
0009ed 09df                          .dw VE_HEAD
                                     .set VE_HEAD = VE_COMPARE
                                 XT_COMPARE:
0009ee 09ef                          .dw PFA_COMPARE
                                 PFA_COMPARE:
0009ef 93bf                          push xh
0009f0 93af                          push xl
0009f1 018c                          movw temp0, tosl
0009f2 9189
0009f3 9199                          loadtos
0009f4 01dc                          movw xl, tosl
0009f5 9189
0009f6 9199                          loadtos
0009f7 019c                          movw temp2, tosl
0009f8 9189
0009f9 9199                          loadtos
0009fa 01fc                          movw zl, tosl
                                 PFA_COMPARE_LOOP:
0009fb 90ed                          ld temp4, X+
0009fc 90f1                          ld temp5, Z+
0009fd 14ef                          cp temp4, temp5
0009fe f451                          brne PFA_COMPARE_NOTEQUAL
0009ff 950a                          dec temp0
000a00 f019                          breq PFA_COMPARE_ENDREACHED2
000a01 952a                          dec temp2
000a02 f7c1                          brne PFA_COMPARE_LOOP
000a03 c001                          rjmp PFA_COMPARE_ENDREACHED
                                 PFA_COMPARE_ENDREACHED2:
000a04 952a                          dec temp2
                                 PFA_COMPARE_ENDREACHED:
000a05 2b02                          or temp0, temp2
000a06 f411                          brne PFA_COMPARE_CHECKLASTCHAR
000a07 2788                          clr tosl
000a08 c002                          rjmp PFA_COMPARE_DONE
                                 PFA_COMPARE_CHECKLASTCHAR:
                                 PFA_COMPARE_NOTEQUAL:
000a09 ef8f                          ser tosl
000a0a c000                          rjmp PFA_COMPARE_DONE
                                 
                                 PFA_COMPARE_DONE:
000a0b 2f98                          mov tosh, tosl
000a0c 91af                          pop xl
000a0d 91bf                          pop xh
000a0e 940c 3804                     jmp_ DO_NEXT
                                 .include "words/nfa2lfa.asm"
                                 
                                 ; System
                                 ; get the link field address from the name field address
                                 VE_NFA2LFA:
000a10 ff07                         .dw $ff07
000a11 666e
000a12 3e61
000a13 666c
000a14 0061                         .db "nfa>lfa",0
000a15 09e8                         .dw VE_HEAD
                                    .set VE_HEAD = VE_NFA2LFA
                                 XT_NFA2LFA:
000a16 3800                          .dw DO_COLON
                                 PFA_NFA2LFA:
000a17 06f5                          .dw XT_NAME2STRING
000a18 3a2e                          .dw XT_1PLUS
000a19 3a03                          .dw XT_2SLASH
000a1a 399c                          .dw XT_PLUS
000a1b 381f                          .dw XT_EXIT
                                 .elif AMFORTH_NRWW_SIZE > 2000
                                 .else
                                 .endif
                                 .include "dict_appl.inc"
                                 
                                 ; they may be moved to the core dictionary if needed
                                 
                                 .include "dict/compiler2.inc" ; additional words for the compiler
                                 
                                 ; included almost independently from each other
                                 ; on a include-per-use basis
                                 ;
                                 .if DICT_COMPILER2 == 0
                                 .set DICT_COMPILER2 = 1
                                 
                                 .include "words/set-current.asm"
                                 
                                 ; Search Order
                                 ; set current word list to the given word list wid
                                 VE_SET_CURRENT:
000a1c ff0b                          .dw $ff0b
000a1d 6573
000a1e 2d74
000a1f 7563
000a20 7272
000a21 6e65
000a22 0074                          .db "set-current",0
000a23 0a10                          .dw VE_HEAD
                                     .set VE_HEAD = VE_SET_CURRENT
                                 XT_SET_CURRENT:
000a24 3800                          .dw DO_COLON
                                 PFA_SET_CURRENT:
000a25 383c                          .dw XT_DOLITERAL
000a26 0046                          .dw CFG_CURRENT
000a27 3b3a                          .dw XT_STOREE
000a28 381f                          .dw XT_EXIT
                                 .include "words/wordlist.asm"
                                 
                                 ; Search Order
                                 ; create a new, empty wordlist
                                 VE_WORDLIST:
000a29 ff08                          .dw $ff08
000a2a 6f77
000a2b 6472
000a2c 696c
000a2d 7473                          .db "wordlist"
000a2e 0a1c                          .dw VE_HEAD
                                     .set VE_HEAD = VE_WORDLIST
                                 XT_WORDLIST:
000a2f 3800                          .dw DO_COLON
                                 PFA_WORDLIST:
000a30 3f1a                          .dw XT_EHERE
000a31 3953                          .dw XT_ZERO
000a32 38ce                          .dw XT_OVER
000a33 3b3a                          .dw XT_STOREE
000a34 38b0                          .dw XT_DUP
000a35 3c8f                          .dw XT_CELLPLUS
000a36 01bf                          .dw XT_DOTO
000a37 3f1b                          .dw PFA_EHERE
000a38 381f                          .dw XT_EXIT
                                 
                                 .include "words/forth-wordlist.asm"
                                 
                                 ; Search Order
                                 ; get the system default word list
                                 VE_FORTHWORDLIST:
000a39 ff0e                          .dw $ff0e
000a3a 6f66
000a3b 7472
000a3c 2d68
000a3d 6f77
000a3e 6472
000a3f 696c
000a40 7473                          .db "forth-wordlist"
000a41 0a29                          .dw VE_HEAD
                                     .set VE_HEAD = VE_FORTHWORDLIST
                                 XT_FORTHWORDLIST:
000a42 3847                          .dw PFA_DOVARIABLE
                                 PFA_FORTHWORDLIST:
000a43 0048                          .dw CFG_FORTHWORDLIST
                                 .include "words/set-order.asm"
                                 
                                 ; Search Order
                                 ; replace the search order list
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_SET_ORDER:
000a44 ff09                          .dw $ff09
000a45 6573
000a46 2d74
000a47 726f
000a48 6564
000a49 0072                          .db "set-order",0
000a4a 0a39                          .dw VE_HEAD
                                     .set VE_HEAD = VE_SET_ORDER
                                 XT_SET_ORDER:
000a4b 3800                          .dw DO_COLON
                                 PFA_SET_ORDER:
                                 .endif
000a4c 383c                          .dw XT_DOLITERAL
000a4d 004a                          .dw CFG_ORDERLISTLEN
000a4e 0989                          .dw XT_SET_STACK
000a4f 381f                          .dw XT_EXIT
                                 
                                 .include "words/set-recognizer.asm"
                                 
                                 ; Interpreter
                                 ; replace the recognizer list
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_SET_RECOGNIZERS:
000a50 ff0f                          .dw $ff0f
000a51 6573
000a52 2d74
000a53 6572
000a54 6f63
000a55 6e67
000a56 7a69
000a57 7265
000a58 0073                          .db "set-recognizers",0
000a59 0a44                          .dw VE_HEAD
                                     .set VE_HEAD = VE_SET_RECOGNIZERS
                                 XT_SET_RECOGNIZERS:
000a5a 3800                          .dw DO_COLON
                                 PFA_SET_RECOGNIZERS:
                                 .endif
000a5b 383c                          .dw XT_DOLITERAL
000a5c 005c                          .dw CFG_RECOGNIZERLISTLEN
000a5d 0989                          .dw XT_SET_STACK
000a5e 381f                          .dw XT_EXIT
                                 
                                 .include "words/get-recognizer.asm"
                                 
                                 ; Interpreter
                                 ; Get the current recognizer list
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_GET_RECOGNIZERS:
000a5f ff0f                          .dw $ff0f
000a60 6567
000a61 2d74
000a62 6572
000a63 6f63
000a64 6e67
000a65 7a69
000a66 7265
000a67 0073                          .db "get-recognizers",0
000a68 0a50                          .dw VE_HEAD
                                     .set VE_HEAD = VE_GET_RECOGNIZERS
                                 XT_GET_RECOGNIZERS:
000a69 3800                          .dw DO_COLON
                                 PFA_GET_RECOGNIZERS:
                                 .endif
000a6a 383c                          .dw XT_DOLITERAL
000a6b 005c                          .dw CFG_RECOGNIZERLISTLEN
000a6c 0968                          .dw XT_GET_STACK
000a6d 381f                          .dw XT_EXIT
                                 .include "words/code.asm"
                                 
                                 ; Compiler
                                 ; create named entry in the dictionary, XT is the data field
                                 VE_CODE:
000a6e ff04                          .dw $ff04
000a6f 6f63
000a70 6564                          .db "code"
000a71 0a5f                          .dw VE_HEAD
                                     .set VE_HEAD = VE_CODE
                                 XT_CODE:
000a72 3800                          .dw DO_COLON
                                 PFA_CODE:
000a73 0739                          .dw XT_DOCREATE
000a74 0899                          .dw XT_REVEAL
000a75 3f11                          .dw XT_DP
000a76 01d1                          .dw XT_ICELLPLUS
000a77 0767                          .dw XT_COMMA
000a78 381f                          .dw XT_EXIT
                                 .include "words/end-code.asm"
                                 
                                 ; Compiler
                                 ; finish a code definition
                                 VE_ENDCODE:
000a79 ff08                          .dw $ff08
000a7a 6e65
000a7b 2d64
000a7c 6f63
000a7d 6564                          .db "end-code"
000a7e 0a6e                          .dw VE_HEAD
                                     .set VE_HEAD = VE_ENDCODE
                                 XT_ENDCODE:
000a7f 3800                          .dw DO_COLON
                                 PFA_ENDCODE:
000a80 075c                          .dw XT_COMPILE
000a81 940c                          .dw $940c
000a82 075c                          .dw XT_COMPILE
000a83 3804                          .dw DO_NEXT
000a84 381f                          .dw XT_EXIT
                                 .include "words/marker.asm"
                                 
                                 ; System Value
                                 ; The eeprom address until which MARKER saves and restores the eeprom data.
                                 VE_MARKER:
000a85 ff08                          .dw $ff08
000a86 6d28
000a87 7261
000a88 656b
000a89 2972                          .db "(marker)"
000a8a 0a79                          .dw VE_HEAD
                                     .set VE_HEAD = VE_MARKER
                                 XT_MARKER:
000a8b 386e                          .dw PFA_DOVALUE1
                                 PFA_MARKER:
000a8c 0068                          .dw EE_MARKER
000a8d 3d9f                          .dw XT_EDEFERFETCH
000a8e 3da9                          .dw XT_EDEFERSTORE
                                 .include "words/postpone.asm"
                                 
                                 ; Compiler
                                 ; Append the compilation semantics of "name" to the dictionary
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_POSTPONE:
000a8f 0008                          .dw $0008
000a90 6f70
000a91 7473
000a92 6f70
000a93 656e                          .db "postpone"
000a94 0a85                          .dw VE_HEAD
                                     .set VE_HEAD = VE_POSTPONE
                                 XT_POSTPONE:
000a95 3800                          .dw DO_COLON
                                 PFA_POSTPONE:
                                 .endif
000a96 05bb                          .dw XT_PARSENAME
000a97 05fe                          .dw XT_FORTHRECOGNIZER
000a98 0609                          .dw XT_RECOGNIZE
000a99 38b0                          .dw XT_DUP
000a9a 38fe                          .dw XT_TO_R
000a9b 01d1                          .dw XT_ICELLPLUS
000a9c 01d1                          .dw XT_ICELLPLUS
000a9d 3bca                          .dw XT_FETCHI
000a9e 3829                          .dw XT_EXECUTE
000a9f 38f5                          .dw XT_R_FROM
000aa0 01d1                          .dw XT_ICELLPLUS
000aa1 3bca                          .dw XT_FETCHI
000aa2 0767                          .dw XT_COMMA
000aa3 381f                          .dw XT_EXIT
                                 .endif
                                 
                                 .include "words/applturnkey.asm"
                                 
                                 ; R( -- )
                                 ; application specific turnkey action
                                 VE_APPLTURNKEY:
000aa4 ff0b                          .dw $ff0b
000aa5 7061
000aa6 6c70
000aa7 7574
000aa8 6e72
000aa9 656b
000aaa 0079                          .db "applturnkey",0
000aab 0a8f                          .dw VE_HEAD
                                     .set VE_HEAD = VE_APPLTURNKEY
                                 XT_APPLTURNKEY:
000aac 3800                          .dw DO_COLON
                                 PFA_APPLTURNKEY:
000aad 00c7                          .dw XT_USART
                                 
                                 .if WANT_INTERRUPTS == 1
000aae 3c96                          .dw XT_INTON
                                 .endif
                                 
000aaf 018a                          .dw XT_DOT_VER
000ab0 3fad                          .dw XT_SPACE
000ab1 03d0                          .dw XT_DOSLITERAL
000ab2 000a                          .dw 10
000ab3 6f46
000ab4 7472
000ab5 6468
000ab6 6975
000ab7 6f6e                          .db "Forthduino"
000ab8 0403                          .dw XT_ITYPE
                                 
000ab9 381f                          .dw XT_EXIT
                                 
                                 
                                 .set DPSTART = pc
                                 .if(pc>AMFORTH_RO_SEG)
                                 .endif
                                 
                                 .org AMFORTH_RO_SEG
                                 .include "amforth-interpreter.asm"
                                 
                                 
                                 DO_COLON:
003800 93bf                          push XH
003801 93af                          push XL          ; PUSH IP
003802 01db                          movw XL, wl
003803 9611                          adiw xl, 1
                                 DO_NEXT:
                                 .if WANT_INTERRUPTS == 1
003804 14b2                          cp isrflag, zerol
003805 f469                          brne DO_INTERRUPT
                                 .endif
003806 01fd                          movw zl, XL        ; READ IP
003807 0fee
003808 1fff
003809 9165
00380a 9175                          readflashcell wl, wh
00380b 9611                          adiw XL, 1        ; INC IP
                                 
                                 DO_EXECUTE:
00380c 01fb                          movw zl, wl
00380d 0fee
00380e 1fff
00380f 9105
003810 9115                          readflashcell temp0,temp1
003811 01f8                          movw zl, temp0
003812 9409                          ijmp
                                 
                                 .if WANT_INTERRUPTS == 1
                                 DO_INTERRUPT:
                                     ; here we deal with interrupts the forth way
003813 939a
003814 938a                          savetos
003815 2d8b                          mov tosl, isrflag
003816 2799                          clr tosh
003817 24bb                          clr isrflag
003818 eb6f                          ldi wl, LOW(XT_ISREXEC)
003819 e37c                          ldi wh, HIGH(XT_ISREXEC)
00381a cff1                          rjmp DO_EXECUTE
                                 .include "dict/nrww.inc"
                                 
                                 ; section together with the forth inner interpreter
                                 
                                 .include "words/exit.asm"
                                 
                                 ; Compiler
                                 ; end of current colon word
                                 VE_EXIT:
00381b ff04                          .dw $ff04
00381c 7865
00381d 7469                          .db "exit"
00381e 0aa4                          .dw VE_HEAD
                                     .set VE_HEAD = VE_EXIT
                                 XT_EXIT:
00381f 3820                          .dw PFA_EXIT
                                 PFA_EXIT:
003820 91af                          pop XL
003821 91bf                          pop XH
003822 cfe1                          jmp_ DO_NEXT
                                 .include "words/execute.asm"
                                 
                                 ; System
                                 ; execute XT
                                 VE_EXECUTE:
003823 ff07                          .dw $ff07
003824 7865
003825 6365
003826 7475
003827 0065                          .db "execute",0
003828 381b                          .dw VE_HEAD
                                     .set VE_HEAD = VE_EXECUTE
                                 XT_EXECUTE:
003829 382a                          .dw PFA_EXECUTE
                                 PFA_EXECUTE:
00382a 01bc                          movw wl, tosl
00382b 9189
00382c 9199                          loadtos
00382d cfde                          jmp_ DO_EXECUTE
                                 .include "words/dobranch.asm"
                                 
                                 ; System
                                 ; runtime of branch
                                 ;VE_DOBRANCH:
                                 ;    .dw $ff08
                                 ;    .db "(branch)"
                                 ;    .dw VE_HEAD
                                 ;    .set VE_HEAD = VE_DOBRANCH
                                 XT_DOBRANCH:
00382e 382f                          .dw PFA_DOBRANCH
                                 PFA_DOBRANCH:
00382f 01fd                          movw zl, XL
003830 0fee
003831 1fff
003832 91a5
003833 91b5                          readflashcell XL,XH
003834 cfcf                          jmp_ DO_NEXT
                                 .include "words/docondbranch.asm"
                                 
                                 ; System
                                 ; runtime of ?branch
                                 ;VE_DOCONDBRANCH:
                                 ;    .dw $ff09
                                 ;    .db "(?branch)"
                                 ;    .dw  VE_HEAD
                                 ;    .set VE_HEAD = VE_DOCONDBRANCH
                                 XT_DOCONDBRANCH:
003835 3836                          .dw PFA_DOCONDBRANCH
                                 PFA_DOCONDBRANCH:
003836 2b98                          or tosh, tosl
003837 9189
003838 9199                          loadtos
003839 f3a9                          brbs 1, PFA_DOBRANCH ; 1 is z flag; if tos is zero (false), do the branch
00383a 9611                          adiw XL, 1
00383b cfc8                          jmp_ DO_NEXT
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 .include "words/doliteral.asm"
                                 
                                 ; System
                                 ; runtime of literal
                                 ;VE_DOLITERAL:
                                 ;    .dw $ff09
                                 ;    .db "(literal)"
                                 ;    .dw VE_HEAD
                                 ;    .set VE_HEAD = VE_DOLITERAL
                                 XT_DOLITERAL:
00383c 383d                          .dw PFA_DOLITERAL
                                 PFA_DOLITERAL:
00383d 939a
00383e 938a                          savetos
00383f 01fd                          movw zl, xl
003840 0fee
003841 1fff
003842 9185
003843 9195                          readflashcell tosl,tosh
003844 9611                          adiw xl, 1
003845 cfbe                          jmp_ DO_NEXT
                                 
                                 .include "words/dovariable.asm"
                                 
                                 ; System
                                 ; puts content of parameter field (1 cell) to TOS
                                 ;VE_DOVARIABLE:
                                 ;    .dw $ff0a
                                 ;    .db "(variable)"
                                 ;    .dw VE_HEAD
                                 ;    .set VE_HEAD = VE_DOVARIABLE
                                 XT_DOVARIABLE:
003846 3847                          .dw PFA_DOVARIABLE
                                 PFA_DOVARIABLE:
003847 939a
003848 938a                          savetos
003849 01fb                          movw zl, wl
00384a 9631                          adiw zl,1
00384b 0fee
00384c 1fff
00384d 9185
00384e 9195                          readflashcell tosl,tosh
00384f cfb4                          jmp_ DO_NEXT
                                 .include "words/doconstant.asm"
                                 
                                 ; System
                                 ; place data field address on TOS
                                 ;VE_DOCONSTANT:
                                 ;    .dw $ff0a
                                 ;    .db "(constant)"
                                 ;    .dw VE_HEAD
                                 ;    .set VE_HEAD = VE_DOCONSTANT
                                 XT_DOCONSTANT:
003850 3851                          .dw PFA_DOCONSTANT
                                 PFA_DOCONSTANT:
003851 939a
003852 938a                          savetos
003853 01cb                          movw tosl, wl
003854 9601                          adiw tosl, 1
003855 cfae                          jmp_ DO_NEXT
                                 .include "words/douser.asm"
                                 
                                 ; System
                                 ; runtime part of user
                                 ;VE_DOUSER:
                                 ;    .dw $ff06
                                 ;    .db "(user)"
                                 ;    .dw VE_HEAD
                                 ;    .set VE_HEAD = VE_DOUSER
                                 XT_DOUSER:
003856 3857                          .dw PFA_DOUSER
                                 PFA_DOUSER:
003857 939a
003858 938a                          savetos
003859 01fb                          movw zl, wl
00385a 9631                          adiw zl, 1
00385b 0fee
00385c 1fff
00385d 9185
00385e 9195                          readflashcell tosl,tosh
00385f 0d84                          add tosl, upl
003860 1d95                          adc tosh, uph
003861 cfa2                          jmp_ DO_NEXT
                                 .include "words/do-value.asm"
                                 
                                 ; System
                                 ; runtime of value
                                 VE_DOVALUE:
003862 ff07                          .dw $ff07
003863 7628
003864 6c61
003865 6575
003866 0029                          .db "(value)", 0
003867 3823                          .dw VE_HEAD
                                     .set VE_HEAD = VE_DOVALUE
                                 XT_DOVALUE:
003868 3800                          .dw DO_COLON
                                 PFA_DOVALUE:
003869 0739                          .dw XT_DOCREATE
00386a 0899                          .dw XT_REVEAL
00386b 075c                          .dw XT_COMPILE
00386c 386e                          .dw PFA_DOVALUE1
00386d 381f                          .dw XT_EXIT
                                 PFA_DOVALUE1:
00386e 940e 08b2                     call_ DO_DODOES
003870 38b0                          .dw XT_DUP
003871 01d1                          .dw XT_ICELLPLUS
003872 3bca                          .dw XT_FETCHI
003873 3829                          .dw XT_EXECUTE
003874 381f                          .dw XT_EXIT
                                 
                                 ; : (value) <builds does> dup icell+ @i execute ;
                                 .include "words/fetch.asm"
                                 
                                 ; Memory
                                 ; read 1 cell from RAM address
                                 VE_FETCH:
003875 ff01                          .dw $ff01
003876 0040                          .db "@",0
003877 3862                          .dw VE_HEAD
                                     .set VE_HEAD = VE_FETCH
                                 XT_FETCH:
003878 3879                          .dw PFA_FETCH
                                 PFA_FETCH:
                                 .if WANT_UNIFIED == 1
                                 .endif
                                 PFA_FETCHRAM:
003879 01fc                          movw zl, tosl
                                     ; low byte is read before the high byte
00387a 9181                          ld tosl, z+
00387b 9191                          ld tosh, z+
00387c cf87                          jmp_ DO_NEXT
                                 .if WANT_UNIFIED == 1
                                 .endif
                                 .include "words/store.asm"
                                 
                                 ; Memory
                                 ; write n to RAM memory at addr, low byte first
                                 VE_STORE:
00387d ff01                          .dw $ff01
00387e 0021                          .db "!",0
00387f 3875                          .dw VE_HEAD
                                     .set VE_HEAD = VE_STORE
                                 XT_STORE:
003880 3881                          .dw PFA_STORE
                                 PFA_STORE:
                                 .if WANT_UNIFIED == 1
                                 .endif
                                 PFA_STORERAM:
003881 01fc                          movw zl, tosl
003882 9189
003883 9199                          loadtos
                                     ; the high byte is written before the low byte
003884 8391                          std Z+1, tosh
003885 8380                          std Z+0, tosl
003886 9189
003887 9199                          loadtos
003888 cf7b                          jmp_ DO_NEXT
                                 .if WANT_UNIFIED == 1
                                 .endif
                                 .include "words/cstore.asm"
                                 
                                 ; Memory
                                 ; store a single byte to RAM address
                                 VE_CSTORE:
003889 ff02                          .dw $ff02
00388a 2163                          .db "c!"
00388b 387d                          .dw VE_HEAD
                                     .set VE_HEAD = VE_CSTORE
                                 XT_CSTORE:
00388c 388d                          .dw PFA_CSTORE
                                 PFA_CSTORE:
00388d 01fc                          movw zl, tosl
00388e 9189
00388f 9199                          loadtos
003890 8380                          st Z, tosl
003891 9189
003892 9199                          loadtos
003893 cf70                          jmp_ DO_NEXT
                                 .include "words/cfetch.asm"
                                 
                                 ; Memory
                                 ; fetch a single byte from memory mapped locations
                                 VE_CFETCH:
003894 ff02                          .dw $ff02
003895 4063                          .db "c@"
003896 3889                          .dw VE_HEAD
                                     .set VE_HEAD  = VE_CFETCH
                                 XT_CFETCH:
003897 3898                          .dw PFA_CFETCH
                                 PFA_CFETCH:
003898 01fc                          movw zl, tosl
003899 2799                          clr tosh
00389a 8180                          ld tosl, Z
00389b cf68                          jmp_ DO_NEXT
                                 .include "words/fetch-u.asm"
                                 
                                 ; Memory
                                 ; read 1 cell from USER area
                                 VE_FETCHU:
00389c ff02                          .dw $ff02
00389d 7540                          .db "@u"
00389e 3894                          .dw VE_HEAD
                                     .set VE_HEAD = VE_FETCHU
                                 XT_FETCHU:
00389f 3800                          .dw DO_COLON
                                 PFA_FETCHU:
0038a0 3b01                          .dw XT_UP_FETCH
0038a1 399c                          .dw XT_PLUS
0038a2 3878                          .dw XT_FETCH
0038a3 381f                          .dw XT_EXIT
                                 .include "words/store-u.asm"
                                 
                                 ; Memory
                                 ; write n to USER area at offset
                                 VE_STOREU:
0038a4 ff02                          .dw $ff02
0038a5 7521                          .db "!u"
0038a6 389c                          .dw VE_HEAD
                                     .set VE_HEAD = VE_STOREU
                                 XT_STOREU:
0038a7 3800                          .dw DO_COLON
                                 PFA_STOREU:
0038a8 3b01                          .dw XT_UP_FETCH
0038a9 399c                          .dw XT_PLUS
0038aa 3880                          .dw XT_STORE
0038ab 381f                          .dw XT_EXIT
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                                 .include "words/dup.asm"
                                 
                                 ; Stack
                                 ; duplicate TOS
                                 VE_DUP:
0038ac ff03                          .dw $ff03
0038ad 7564
0038ae 0070                          .db "dup",0
0038af 38a4                          .dw VE_HEAD
                                     .set VE_HEAD = VE_DUP
                                 XT_DUP:
0038b0 38b1                          .dw PFA_DUP
                                 PFA_DUP:
0038b1 939a
0038b2 938a                          savetos
0038b3 cf50                          jmp_ DO_NEXT
                                 .include "words/qdup.asm"
                                 
                                 ; Stack
                                 ; duplicate TOS if non-zero
                                 VE_QDUP:
0038b4 ff04                          .dw $ff04
0038b5 643f
0038b6 7075                          .db "?dup"
0038b7 38ac                          .dw VE_HEAD
                                     .set VE_HEAD = VE_QDUP
                                 XT_QDUP:
0038b8 38b9                          .dw PFA_QDUP
                                 PFA_QDUP:
0038b9 2f08                          mov temp0, tosl
0038ba 2b09                          or temp0, tosh
0038bb f011                          breq PFA_QDUP1
0038bc 939a
0038bd 938a                          savetos
                                 PFA_QDUP1:
0038be cf45                          jmp_ DO_NEXT
                                 .include "words/swap.asm"
                                 
                                 ; Stack
                                 ; swaps the two top level stack cells
                                 VE_SWAP:
0038bf ff04                          .dw $ff04
0038c0 7773
0038c1 7061                          .db "swap"
0038c2 38b4                          .dw VE_HEAD
                                     .set VE_HEAD = VE_SWAP
                                 XT_SWAP:
0038c3 38c4                          .dw PFA_SWAP
                                 PFA_SWAP:
0038c4 018c                          movw temp0, tosl
0038c5 9189
0038c6 9199                          loadtos
0038c7 931a                          st -Y, temp1
0038c8 930a                          st -Y, temp0
0038c9 cf3a                          jmp_ DO_NEXT
                                 .include "words/over.asm"
                                 
                                 ; Stack
                                 ; Place a copy of x1 on top of the stack
                                 VE_OVER:
0038ca ff04                          .dw $ff04
0038cb 766f
0038cc 7265                          .db "over"
0038cd 38bf                          .dw VE_HEAD
                                     .set VE_HEAD = VE_OVER
                                 XT_OVER:
0038ce 38cf                          .dw PFA_OVER
                                 PFA_OVER:
0038cf 939a
0038d0 938a                          savetos
0038d1 818a                          ldd tosl, Y+2
0038d2 819b                          ldd tosh, Y+3
                                 
0038d3 cf30                          jmp_ DO_NEXT
                                 .include "words/drop.asm"
                                 
                                 ; Stack
                                 ; drop TOS
                                 VE_DROP:
0038d4 ff04                          .dw $ff04
0038d5 7264
0038d6 706f                          .db "drop"
0038d7 38ca                          .dw VE_HEAD
                                     .set VE_HEAD = VE_DROP
                                 XT_DROP:
0038d8 38d9                          .dw PFA_DROP
                                 PFA_DROP:
0038d9 9189
0038da 9199                          loadtos
0038db cf28                          jmp_ DO_NEXT
                                 .include "words/rot.asm"
                                 
                                 ; Stack
                                 ; rotate the three top level cells
                                 VE_ROT:
0038dc ff03                          .dw $ff03
0038dd 6f72
0038de 0074                          .db "rot",0
0038df 38d4                          .dw VE_HEAD
                                     .set VE_HEAD = VE_ROT
                                 XT_ROT:
0038e0 38e1                          .dw PFA_ROT
                                 PFA_ROT:
0038e1 018c                          movw temp0, tosl
0038e2 9129                          ld temp2, Y+
0038e3 9139                          ld temp3, Y+ 
0038e4 9189
0038e5 9199                          loadtos
                                         
0038e6 933a                          st -Y, temp3
0038e7 932a                          st -Y, temp2
0038e8 931a                          st -Y, temp1
0038e9 930a                          st -Y, temp0
                                 
0038ea cf19                          jmp_ DO_NEXT
                                 .include "words/nip.asm"
                                 
                                 ; Stack
                                 ; Remove Second of Stack
                                 VE_NIP:
0038eb ff03                          .dw $ff03
0038ec 696e
0038ed 0070                          .db "nip",0
0038ee 38dc                          .dw VE_HEAD
                                     .set VE_HEAD = VE_NIP
                                 XT_NIP:
0038ef 38f0                          .dw PFA_NIP
                                 PFA_NIP:
0038f0 9622                          adiw yl, 2
0038f1 cf12                          jmp_ DO_NEXT
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                                 .include "words/r_from.asm"
                                 
                                 ; Stack
                                 ; move TOR to TOS
                                 VE_R_FROM:
0038f2 ff02                          .dw $ff02
0038f3 3e72                          .db "r>"
0038f4 38eb                          .dw VE_HEAD
                                     .set VE_HEAD = VE_R_FROM
                                 XT_R_FROM:
0038f5 38f6                          .dw PFA_R_FROM
                                 PFA_R_FROM:
0038f6 939a
0038f7 938a                          savetos
0038f8 918f                          pop tosl
0038f9 919f                          pop tosh
0038fa cf09                          jmp_ DO_NEXT
                                 .include "words/to_r.asm"
                                 
                                 ; Stack
                                 ; move TOS to TOR
                                 VE_TO_R:
0038fb ff02                          .dw $ff02
0038fc 723e                          .db ">r"
0038fd 38f2                          .dw VE_HEAD
                                     .set VE_HEAD = VE_TO_R
                                 XT_TO_R:
0038fe 38ff                          .dw PFA_TO_R
                                 PFA_TO_R:
0038ff 939f                          push tosh
003900 938f                          push tosl
003901 9189
003902 9199                          loadtos
003903 cf00                          jmp_ DO_NEXT
                                 .include "words/r_fetch.asm"
                                 
                                 ; Stack
                                 ; fetch content of TOR
                                 VE_R_FETCH:
003904 ff02                          .dw $ff02
003905 4072                          .db "r@"
003906 38fb                          .dw VE_HEAD
                                     .set VE_HEAD = VE_R_FETCH
                                 XT_R_FETCH:
003907 3908                          .dw PFA_R_FETCH
                                 PFA_R_FETCH:
003908 939a
003909 938a                          savetos
00390a 918f                          pop tosl
00390b 919f                          pop tosh
00390c 939f                          push tosh
00390d 938f                          push tosl
00390e cef5                          jmp_ DO_NEXT
                                 
                                 
                                 .include "words/not-equal.asm"
                                 
                                 ; Compare
                                 ; true if n1 is not equal to n2
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_NOTEQUAL:
00390f ff02                          .dw $ff02
003910 3e3c                          .db "<>"
003911 3904                          .dw VE_HEAD
                                     .set VE_HEAD = VE_NOTEQUAL
                                 XT_NOTEQUAL:
003912 3800                          .dw DO_COLON
                                 PFA_NOTEQUAL:
                                 .endif
                                 
003913 3fde
003914 3919
003915 381f                          .DW XT_EQUAL,XT_ZEROEQUAL,XT_EXIT
                                 .include "words/equalzero.asm"
                                 
                                 ; Compare
                                 ; compare with 0 (zero)
                                 VE_ZEROEQUAL:
003916 ff02                          .dw $ff02
003917 3d30                          .db "0="
003918 390f                          .dw VE_HEAD
                                     .set VE_HEAD = VE_ZEROEQUAL
                                 XT_ZEROEQUAL:
003919 391a                          .dw PFA_ZEROEQUAL
                                 PFA_ZEROEQUAL:
00391a 2b98                          or tosh, tosl
00391b f5d1                          brne PFA_ZERO1
00391c c030                          rjmp PFA_TRUE1
                                 .include "words/lesszero.asm"
                                 
                                 ; Compare
                                 ; compare with zero
                                 VE_ZEROLESS:
00391d ff02                          .dw $ff02
00391e 3c30                          .db "0<"
00391f 3916                          .dw VE_HEAD
                                     .set VE_HEAD = VE_ZEROLESS
                                 XT_ZEROLESS:
003920 3921                          .dw PFA_ZEROLESS
                                 PFA_ZEROLESS:
003921 fd97                          sbrc tosh,7
003922 c02a                          rjmp PFA_TRUE1
003923 c032                          rjmp PFA_ZERO1
                                 .include "words/greaterzero.asm"
                                 
                                 ; Compare
                                 ; true if n1 is greater than 0
                                 VE_GREATERZERO:
003924 ff02                          .dw $ff02
003925 3e30                          .db "0>"
003926 391d                          .dw VE_HEAD
                                     .set VE_HEAD = VE_GREATERZERO
                                 XT_GREATERZERO:
003927 3928                          .dw PFA_GREATERZERO
                                 PFA_GREATERZERO:
003928 1582                          cp tosl, zerol
003929 0593                          cpc tosh, zeroh
00392a f15c                          brlt PFA_ZERO1
00392b f151                          brbs 1, PFA_ZERO1
00392c c020                          rjmp PFA_TRUE1
                                 .include "words/d-greaterzero.asm"
                                 
                                 ; Compare
                                 ; compares if a double double cell number is greater 0
                                 VE_DGREATERZERO:
00392d ff03                          .dw $ff03
00392e 3064
00392f 003e                          .db "d0>",0
003930 3924                          .dw VE_HEAD
                                     .set VE_HEAD = VE_DGREATERZERO
                                 XT_DGREATERZERO:
003931 3932                          .dw PFA_DGREATERZERO
                                 PFA_DGREATERZERO:
003932 1582                          cp tosl, zerol
003933 0593                          cpc tosh, zeroh
003934 9189
003935 9199                          loadtos
003936 0582                          cpc tosl, zerol
003937 0593                          cpc tosh, zeroh
003938 f0ec                          brlt PFA_ZERO1
003939 f0e1                          brbs 1, PFA_ZERO1
00393a c012                          rjmp PFA_TRUE1
                                 .include "words/d-lesszero.asm"
                                 
                                 ; Compare
                                 ; compares if a double double cell number is less than 0
                                 VE_DXT_ZEROLESS:
00393b ff03                          .dw $ff03
00393c 3064
00393d 003c                          .db "d0<",0
00393e 392d                          .dw VE_HEAD
                                     .set VE_HEAD = VE_DXT_ZEROLESS
                                 XT_DXT_ZEROLESS:
00393f 3940                          .dw PFA_DXT_ZEROLESS
                                 PFA_DXT_ZEROLESS:
003940 9622                          adiw Y,2
003941 fd97                          sbrc tosh,7
003942 940c 394d                     jmp PFA_TRUE1
003944 940c 3956                     jmp PFA_ZERO1
                                 
                                 .include "words/true.asm"
                                 
                                 ; Arithmetics
                                 ; leaves the value -1 (true) on TOS
                                 VE_TRUE:
003946 ff04                          .dw $ff04
003947 7274
003948 6575                          .db "true"
003949 393b                          .dw VE_HEAD
                                     .set VE_HEAD = VE_TRUE
                                 XT_TRUE:
00394a 394b                          .dw PFA_TRUE
                                 PFA_TRUE:
00394b 939a
00394c 938a                          savetos
                                 PFA_TRUE1:
00394d ef8f                          ser tosl
00394e ef9f                          ser tosh
00394f ceb4                          jmp_ DO_NEXT
                                 .include "words/zero.asm"
                                 
                                 ; Arithmetics
                                 ; place a value 0 on TOS
                                 VE_ZERO:
003950 ff01                          .dw $ff01
003951 0030                          .db "0",0
003952 3946                          .dw VE_HEAD
                                     .set VE_HEAD = VE_ZERO
                                 XT_ZERO:
003953 3954                          .dw PFA_ZERO
                                 PFA_ZERO:
003954 939a
003955 938a                          savetos
                                 PFA_ZERO1:
003956 01c1                          movw tosl, zerol
003957 ceac                          jmp_ DO_NEXT
                                 .include "words/uless.asm"
                                 
                                 ; Compare
                                 ; true if u1 < u2 (unsigned)
                                 VE_ULESS:
003958 ff02                          .dw $ff02
003959 3c75                          .db "u<"
00395a 3950                          .dw VE_HEAD
                                     .set VE_HEAD = VE_ULESS
                                 XT_ULESS:
00395b 395c                          .dw PFA_ULESS
                                 PFA_ULESS:
00395c 9129                          ld temp2, Y+
00395d 9139                          ld temp3, Y+
00395e 1782                          cp tosl, temp2
00395f 0793                          cpc tosh, temp3
003960 f3a8                          brlo PFA_ZERO1
003961 f3a1                          brbs 1, PFA_ZERO1
003962 cfea                          jmp_ PFA_TRUE1
                                 .include "words/u-greater.asm"
                                 
                                 ; Compare
                                 ; true if u1 > u2 (unsigned)
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_UGREATER:
003963 ff02                          .dw $ff02
003964 3e75                          .db "u>"
003965 3958                          .dw VE_HEAD
                                     .set VE_HEAD = VE_UGREATER
                                 XT_UGREATER:
003966 3800                          .dw DO_COLON
                                 PFA_UGREATER:
                                 .endif
003967 38c3                          .DW XT_SWAP
003968 395b                          .dw XT_ULESS
003969 381f                          .dw XT_EXIT
                                 .include "words/less.asm"
                                 
                                 ; Compare
                                 ; true if n1 is less than n2
                                     VE_LESS:
00396a ff01                          .dw $ff01
00396b 003c                          .db "<",0
00396c 3963                          .dw VE_HEAD
                                     .set VE_HEAD = VE_LESS
                                 XT_LESS:
00396d 396e                          .dw PFA_LESS
                                 PFA_LESS:
00396e 9129                          ld temp2, Y+
00396f 9139                          ld temp3, Y+
003970 1728                          cp temp2, tosl
003971 0739                          cpc temp3, tosh
                                 PFA_LESSDONE:
003972 f71c                          brge PFA_ZERO1
003973 cfd9                          rjmp PFA_TRUE1
                                 .include "words/greater.asm"
                                 
                                 ; Compare
                                 ; flag is true if n1 is greater than n2
                                 VE_GREATER:
003974 ff01                          .dw $ff01
003975 003e                          .db ">",0
003976 396a                          .dw VE_HEAD
                                     .set VE_HEAD = VE_GREATER
                                 XT_GREATER:
003977 3978                          .dw PFA_GREATER
                                 PFA_GREATER:
003978 9129                          ld temp2, Y+
003979 9139                          ld temp3, Y+
00397a 1728                          cp temp2, tosl
00397b 0739                          cpc temp3, tosh
                                 PFA_GREATERDONE:
00397c f2cc                          brlt PFA_ZERO1
00397d f2c1                          brbs 1, PFA_ZERO1
00397e cfce                          rjmp PFA_TRUE1
                                 
                                 .include "words/log2.asm"
                                 
                                 ; Arithmetics
                                 ; logarithm to base 2 or highest set bitnumber
                                 VE_LOG2:
00397f ff04                          .dw $ff04
003980 6f6c
003981 3267                          .db "log2"
003982 3974                          .dw VE_HEAD
                                     .set VE_HEAD = VE_LOG2
                                 XT_LOG2:
003983 3984                          .dw PFA_LOG2
                                 PFA_LOG2:
003984 01fc                          movw zl, tosl
003985 2799                          clr tosh
003986 e180                          ldi tosl, 16
                                 PFA_LOG2_1:
003987 958a                          dec tosl
003988 f022                          brmi PFA_LOG2_2 ; wrong data
003989 0fee                          lsl  zl
00398a 1fff                          rol  zh
00398b f7d8                          brcc PFA_LOG2_1
00398c ce77                          jmp_ DO_NEXT
                                 
                                 PFA_LOG2_2:
00398d 959a                          dec tosh
00398e ce75                          jmp_ DO_NEXT
                                 .include "words/minus.asm"
                                 
                                 ; Arithmetics
                                 ; subtract n2 from n1
                                 VE_MINUS:
00398f ff01                          .dw $ff01
003990 002d                          .db "-",0
003991 397f                          .dw VE_HEAD
                                     .set VE_HEAD = VE_MINUS
                                 XT_MINUS:
003992 3993                          .dw PFA_MINUS
                                 PFA_MINUS:
003993 9109                          ld temp0, Y+
003994 9119                          ld temp1, Y+
003995 1b08                          sub temp0, tosl
003996 0b19                          sbc temp1, tosh
003997 01c8                          movw tosl, temp0
003998 ce6b                          jmp_ DO_NEXT
                                 .include "words/plus.asm"
                                 
                                 ; Arithmetics
                                 ; add n1 and n2
                                 VE_PLUS:
003999 ff01                          .dw $ff01
00399a 002b                          .db "+",0
00399b 398f                          .dw VE_HEAD
                                     .set VE_HEAD = VE_PLUS
                                 XT_PLUS:
00399c 399d                          .dw PFA_PLUS
                                 PFA_PLUS:
00399d 9109                          ld temp0, Y+
00399e 9119                          ld temp1, Y+
00399f 0f80                          add tosl, temp0
0039a0 1f91                          adc tosh, temp1
0039a1 ce62                          jmp_ DO_NEXT
                                 .include "words/mstar.asm"
                                 
                                 ; Arithmetics
                                 ; multiply 2 cells to a double cell
                                 VE_MSTAR:
0039a2 ff02                          .dw $ff02
0039a3 2a6d                          .db "m*"
0039a4 3999                          .dw VE_HEAD
                                     .set VE_HEAD = VE_MSTAR
                                 XT_MSTAR:
0039a5 39a6                          .dw PFA_MSTAR
                                 PFA_MSTAR:
0039a6 018c                          movw temp0, tosl
0039a7 9189
0039a8 9199                          loadtos
0039a9 019c                          movw temp2, tosl
                                     ; high cell ah*bh
0039aa 0231                          muls temp3, temp1
0039ab 0170                          movw temp4, r0
                                     ; low cell  al*bl
0039ac 9f20                          mul  temp2, temp0
0039ad 01c0                          movw tosl, r0
                                     ; signed ah*bl
0039ae 0330                          mulsu temp3, temp0
0039af 08f3                          sbc   temp5, zeroh
0039b0 0d90                          add   tosh,  r0
0039b1 1ce1                          adc   temp4, r1
0039b2 1cf3                          adc   temp5, zeroh
                                     
                                     ; signed al*bh
0039b3 0312                          mulsu temp1, temp2
0039b4 08f3                          sbc   temp5, zeroh
0039b5 0d90                          add   tosh,  r0
0039b6 1ce1                          adc   temp4, r1
0039b7 1cf3                          adc   temp5, zeroh
                                 
0039b8 939a
0039b9 938a                          savetos
0039ba 01c7                          movw tosl, temp4
0039bb ce48                          jmp_ DO_NEXT
                                 .include "words/umslashmod.asm"
                                 
                                 ; Arithmetics
                                 ; unsigned division ud / u2 with remainder
                                 VE_UMSLASHMOD:
0039bc ff06                          .dw $ff06
0039bd 6d75
0039be 6d2f
0039bf 646f                          .db "um/mod"
0039c0 39a2                          .dw VE_HEAD
                                     .set VE_HEAD = VE_UMSLASHMOD
                                 XT_UMSLASHMOD:
0039c1 39c2                          .dw PFA_UMSLASHMOD
                                 PFA_UMSLASHMOD:
0039c2 017c                          movw temp4, tosl
                                 
0039c3 9129                          ld temp2, Y+
0039c4 9139                          ld temp3, Y+
                                   
0039c5 9109                          ld temp0, Y+
0039c6 9119                          ld temp1, Y+
                                 
                                 ;; unsigned 32/16 -> 16r16 divide
                                 
                                 PFA_UMSLASHMODmod:
                                 
                                   ; set loop counter
0039c7 e140                          ldi temp6,$10
                                 
                                 PFA_UMSLASHMODmod_loop:
                                     ; shift left, saving high bit
0039c8 2755                          clr temp7
0039c9 0f00                          lsl temp0
0039ca 1f11                          rol temp1
0039cb 1f22                          rol temp2
0039cc 1f33                          rol temp3
0039cd 1f55                          rol temp7
                                 
                                   ; try subtracting divisor
0039ce 152e                          cp temp2, temp4
0039cf 053f                          cpc temp3, temp5
0039d0 0552                          cpc temp7,zerol
                                 
0039d1 f018                          brcs PFA_UMSLASHMODmod_loop_control
                                 
                                 PFA_UMSLASHMODmod_subtract:
                                     ; dividend is large enough
                                     ; do the subtraction for real
                                     ; and set lowest bit
0039d2 9503                          inc temp0
0039d3 192e                          sub temp2, temp4
0039d4 093f                          sbc temp3, temp5
                                 
                                 PFA_UMSLASHMODmod_loop_control:
0039d5 954a                          dec  temp6
0039d6 f789                          brne PFA_UMSLASHMODmod_loop
                                 
                                 PFA_UMSLASHMODmod_done:
                                     ; put remainder on stack
0039d7 933a                          st -Y,temp3
0039d8 932a                          st -Y,temp2
                                 
                                     ; put quotient on stack
0039d9 01c8                          movw tosl, temp0
0039da ce29                          jmp_ DO_NEXT
                                 .include "words/umstar.asm"
                                 
                                 ; Arithmetics
                                 ; multiply 2 unsigned cells to a double cell
                                 VE_UMSTAR:
0039db ff03                          .dw $ff03
0039dc 6d75
0039dd 002a                          .db "um*",0
0039de 39bc                          .dw VE_HEAD
                                     .set VE_HEAD = VE_UMSTAR
                                 XT_UMSTAR:
0039df 39e0                          .dw PFA_UMSTAR
                                 PFA_UMSTAR:
0039e0 018c                          movw temp0, tosl
0039e1 9189
0039e2 9199                          loadtos
                                     ; result: (temp3*temp1)* 65536 + (temp3*temp0 + temp1*temp2) * 256 + (temp0 * temp2)
                                     ; low bytes
0039e3 9f80                          mul tosl,temp0
0039e4 01f0                          movw zl, r0
0039e5 2722                          clr temp2
0039e6 2733                          clr temp3
                                     ; middle bytes
0039e7 9f90                          mul tosh, temp0
0039e8 0df0                          add zh, r0
0039e9 1d21                          adc temp2, r1
0039ea 1d33                          adc temp3, zeroh
                                         
0039eb 9f81                          mul tosl, temp1
0039ec 0df0                          add zh, r0
0039ed 1d21                          adc temp2, r1
0039ee 1d33                          adc temp3, zeroh
                                     
0039ef 9f91                          mul tosh, temp1
0039f0 0d20                          add temp2, r0
0039f1 1d31                          adc temp3, r1
0039f2 01cf                          movw tosl, zl
0039f3 939a
0039f4 938a                          savetos
0039f5 01c9                          movw tosl, temp2
0039f6 ce0d                          jmp_ DO_NEXT
                                 
                                 .include "words/invert.asm"
                                 
                                 ; Arithmetics
                                 ; 1-complement of TOS
                                 VE_INVERT:
0039f7 ff06                          .dw $ff06
0039f8 6e69
0039f9 6576
0039fa 7472                          .db "invert"
0039fb 39db                          .dw VE_HEAD
                                     .set VE_HEAD = VE_INVERT
                                 XT_INVERT:
0039fc 39fd                          .dw PFA_INVERT
                                 PFA_INVERT:
0039fd 9580                          com tosl
0039fe 9590                          com tosh
0039ff ce04                          jmp_ DO_NEXT
                                 .include "words/2slash.asm"
                                 
                                 ; Arithmetics
                                 ; arithmetic shift right
                                 VE_2SLASH:
003a00 ff02                          .dw $ff02
003a01 2f32                          .db "2/"
003a02 39f7                          .dw VE_HEAD
                                     .set VE_HEAD = VE_2SLASH
                                 XT_2SLASH:
003a03 3a04                          .dw PFA_2SLASH
                                 PFA_2SLASH:
003a04 9595                          asr tosh
003a05 9587                          ror tosl
003a06 cdfd                          jmp_ DO_NEXT
                                 .include "words/2star.asm"
                                 
                                 ; Arithmetics
                                 ; arithmetic shift left, filling with zero
                                 VE_2STAR:
003a07 ff02                          .dw $ff02
003a08 2a32                          .db "2*"
003a09 3a00                          .dw VE_HEAD
                                     .set VE_HEAD = VE_2STAR
                                 XT_2STAR:
003a0a 3a0b                          .dw PFA_2STAR
                                 PFA_2STAR:
003a0b 0f88                          lsl tosl
003a0c 1f99                          rol tosh
003a0d cdf6                          jmp_ DO_NEXT
                                 .include "words/and.asm"
                                 
                                 ; Logic
                                 ; bitwise and
                                 VE_AND:
003a0e ff03                          .dw $ff03
003a0f 6e61
003a10 0064                          .db "and",0
003a11 3a07                          .dw VE_HEAD
                                     .set VE_HEAD = VE_AND
                                 XT_AND:
003a12 3a13                          .dw PFA_AND
                                 PFA_AND:
003a13 9109                          ld temp0, Y+
003a14 9119                          ld temp1, Y+
003a15 2380                          and tosl, temp0
003a16 2391                          and tosh, temp1
003a17 cdec                          jmp_ DO_NEXT
                                 .include "words/or.asm"
                                 
                                 ; Logic
                                 ; logical or
                                 VE_OR:
003a18 ff02                          .dw $ff02
003a19 726f                          .db "or"
003a1a 3a0e                          .dw VE_HEAD
                                     .set VE_HEAD = VE_OR
                                 XT_OR:
003a1b 3a1c                          .dw PFA_OR
                                 PFA_OR:
003a1c 9109                          ld temp0, Y+
003a1d 9119                          ld temp1, Y+
003a1e 2b80                          or tosl, temp0
003a1f 2b91                          or tosh, temp1
003a20 cde3                          jmp_ DO_NEXT
                                 
                                 .include "words/xor.asm"
                                 
                                 ; Logic
                                 ; exclusive or
                                 VE_XOR:
003a21 ff03                          .dw $ff03
003a22 6f78
003a23 0072                          .db "xor",0
003a24 3a18                          .dw VE_HEAD
                                     .set VE_HEAD = VE_XOR
                                 XT_XOR:
003a25 3a26                          .dw PFA_XOR
                                 PFA_XOR:
003a26 9109                          ld temp0, Y+
003a27 9119                          ld temp1, Y+
003a28 2780                          eor tosl, temp0
003a29 2791                          eor tosh, temp1
003a2a cdd9                          jmp_ DO_NEXT
                                 
                                 .include "words/1plus.asm"
                                 
                                 ; Arithmetics
                                 ; optimized increment
                                 VE_1PLUS:
003a2b ff02                          .dw $ff02
003a2c 2b31                          .db "1+"
003a2d 3a21                          .dw VE_HEAD
                                     .set VE_HEAD = VE_1PLUS
                                 XT_1PLUS:
003a2e 3a2f                          .dw PFA_1PLUS
                                 PFA_1PLUS:
003a2f 9601                          adiw tosl,1
003a30 cdd3                          jmp_ DO_NEXT
                                 .include "words/1minus.asm"
                                 
                                 ; Arithmetics
                                 ; optimized decrement
                                 VE_1MINUS:
003a31 ff02                          .dw $ff02 
003a32 2d31                          .db "1-"
003a33 3a2b                          .dw VE_HEAD
                                     .set VE_HEAD = VE_1MINUS
                                 XT_1MINUS:
003a34 3a35                          .dw PFA_1MINUS
                                 PFA_1MINUS:
003a35 9701                          sbiw tosl, 1
003a36 cdcd                          jmp_ DO_NEXT
                                 .include "words/q-negate.asm"
                                 
                                 ;   0< IF NEGATE THEN ;        ...a common factor
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_QNEGATE:
003a37 ff07                          .dw $ff07
003a38 6e3f
003a39 6765
003a3a 7461
amforth-6.5\common\words/q-negate.asm(11): warning: .cseg .db misalignment - padding zero byte
003a3b 0065                          .db "?negate"
003a3c 3a31                          .dw VE_HEAD
                                     .set VE_HEAD = VE_QNEGATE
                                 XT_QNEGATE:
003a3d 3800                          .dw DO_COLON
                                 PFA_QNEGATE:
                                 
                                 .endif
003a3e 3920
003a3f 3835                              .DW XT_ZEROLESS,XT_DOCONDBRANCH
003a40 3a42                              DEST(QNEG1)
003a41 3e26                              .DW XT_NEGATE
003a42 381f                      QNEG1:  .DW XT_EXIT
                                 .include "words/lshift.asm"
                                 
                                 ; Arithmetics
                                 ; logically shift n1 left n2 times
                                 VE_LSHIFT:
003a43 ff06                          .dw $ff06
003a44 736c
003a45 6968
003a46 7466                          .db "lshift"
003a47 3a37                          .dw VE_HEAD
                                     .set VE_HEAD = VE_LSHIFT
                                 XT_LSHIFT:
003a48 3a49                          .dw PFA_LSHIFT
                                 PFA_LSHIFT:
003a49 01fc                          movw zl, tosl
003a4a 9189
003a4b 9199                          loadtos
                                 PFA_LSHIFT1:
003a4c 9731                          sbiw zl, 1
003a4d f01a                          brmi PFA_LSHIFT2
003a4e 0f88                          lsl tosl
003a4f 1f99                          rol tosh
003a50 cffb                          rjmp PFA_LSHIFT1
                                 PFA_LSHIFT2:
003a51 cdb2                          jmp_ DO_NEXT
                                 
                                 .include "words/rshift.asm"
                                 
                                 ; Arithmetics
                                 ; shift n1 n2-times logically right
                                 VE_RSHIFT:
003a52 ff06                          .dw $ff06
003a53 7372
003a54 6968
003a55 7466                          .db "rshift"
003a56 3a43                          .dw VE_HEAD
                                     .set VE_HEAD = VE_RSHIFT
                                 XT_RSHIFT:
003a57 3a58                          .dw PFA_RSHIFT
                                 PFA_RSHIFT:
003a58 01fc                          movw zl, tosl
003a59 9189
003a5a 9199                          loadtos
                                 PFA_RSHIFT1:
003a5b 9731                          sbiw zl, 1
003a5c f01a                          brmi PFA_RSHIFT2
003a5d 9596                          lsr tosh
003a5e 9587                          ror tosl
003a5f cffb                          rjmp PFA_RSHIFT1
                                 PFA_RSHIFT2:
003a60 cda3                          jmp_ DO_NEXT
                                 
                                 .include "words/plusstore.asm"
                                 
                                 ; Arithmetics
                                 ; add n to content of RAM address a-addr
                                 VE_PLUSSTORE:
003a61 ff02                          .dw $ff02
003a62 212b                          .db "+!"
003a63 3a52                          .dw VE_HEAD
                                     .set VE_HEAD = VE_PLUSSTORE
                                 XT_PLUSSTORE:
003a64 3a65                          .dw PFA_PLUSSTORE
                                 PFA_PLUSSTORE:
003a65 01fc                          movw zl, tosl
003a66 9189
003a67 9199                          loadtos
003a68 8120                          ldd temp2, Z+0
003a69 8131                          ldd temp3, Z+1
003a6a 0f82                          add tosl, temp2
003a6b 1f93                          adc tosh, temp3
003a6c 8380                          std Z+0, tosl
003a6d 8391                          std Z+1, tosh
003a6e 9189
003a6f 9199                          loadtos
003a70 cd93                          jmp_ DO_NEXT
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 .include "words/rpfetch.asm"
                                 
                                 ; Stack
                                 ; current return stack pointer address
                                 VE_RP_FETCH:
003a71 ff03                          .dw $ff03
003a72 7072
003a73 0040                          .db "rp@",0
003a74 3a61                          .dw VE_HEAD
                                     .set VE_HEAD = VE_RP_FETCH
                                 XT_RP_FETCH:
003a75 3a76                          .dw PFA_RP_FETCH
                                 PFA_RP_FETCH:
003a76 939a
003a77 938a                          savetos
003a78 b78d                          in tosl, SPL
003a79 b79e                          in tosh, SPH
003a7a cd89                          jmp_ DO_NEXT
                                 .include "words/rpstore.asm"
                                 
                                 ; Stack
                                 ; set return stack pointer
                                 VE_RP_STORE:
003a7b ff03                          .dw $ff03
003a7c 7072
003a7d 0021                          .db "rp!",0
003a7e 3a71                          .dw VE_HEAD
                                     .set VE_HEAD = VE_RP_STORE
                                 XT_RP_STORE:
003a7f 3a80                          .dw PFA_RP_STORE
                                 PFA_RP_STORE:
003a80 b72f                          in temp2, SREG
003a81 94f8                          cli
003a82 bf8d                          out SPL, tosl
003a83 bf9e                          out SPH, tosh
003a84 bf2f                          out SREG, temp2
003a85 9189
003a86 9199                          loadtos
003a87 cd7c                          jmp_ DO_NEXT
                                 .include "words/spfetch.asm"
                                 
                                 ; Stack
                                 ; current data stack pointer
                                 VE_SP_FETCH:
003a88 ff03                          .dw $ff03
003a89 7073
003a8a 0040                          .db "sp@",0
003a8b 3a7b                          .dw VE_HEAD
                                     .set VE_HEAD = VE_SP_FETCH
                                 XT_SP_FETCH:
003a8c 3a8d                          .dw PFA_SP_FETCH
                                 PFA_SP_FETCH:
003a8d 939a
003a8e 938a                          savetos
003a8f 01ce                          movw tosl, yl
003a90 cd73                          jmp_ DO_NEXT
                                 .include "words/spstore.asm"
                                 
                                 ; Stack
                                 ; set data stack pointer to addr
                                 VE_SP_STORE:
003a91 ff03                          .dw $ff03
003a92 7073
003a93 0021                          .db "sp!",0
003a94 3a88                          .dw VE_HEAD
                                     .set VE_HEAD = VE_SP_STORE
                                 XT_SP_STORE:
003a95 3a96                          .dw PFA_SP_STORE
                                 PFA_SP_STORE:
003a96 01ec                          movw yl, tosl
003a97 9189
003a98 9199                          loadtos
003a99 cd6a                          jmp_ DO_NEXT
                                 
                                 .include "words/dodo.asm"
                                 
                                 ; System
                                 ; runtime of do
                                 ;VE_DODO:
                                 ;    .dw $ff04
                                 ;    .db "(do)"
                                 ;    .dw VE_HEAD
                                 ;    .set VE_HEAD = VE_DODO
                                 XT_DODO:
003a9a 3a9b                          .dw PFA_DODO
                                 PFA_DODO:
003a9b 9129                          ld temp2, Y+
003a9c 9139                          ld temp3, Y+  ; limit
                                 PFA_DODO1:
003a9d e8e0                          ldi zl, $80
003a9e 0f3e                          add temp3, zl
003a9f 1b82                          sub  tosl, temp2
003aa0 0b93                          sbc  tosh, temp3
                                 
003aa1 933f                          push temp3
003aa2 932f                          push temp2    ; limit  ( --> limit + $8000)
003aa3 939f                          push tosh
003aa4 938f                          push tosl     ; start -> index ( --> index - (limit - $8000)
003aa5 9189
003aa6 9199                          loadtos
003aa7 cd5c                          jmp_ DO_NEXT
                                 .include "words/i.asm"
                                 
                                 ; Compiler
                                 ; current loop counter
                                 VE_I:
003aa8 ff01                          .dw $FF01
003aa9 0069                          .db "i",0
003aaa 3a91                          .dw VE_HEAD
                                     .set VE_HEAD = VE_I
                                 XT_I:
003aab 3aac                          .dw PFA_I
                                 PFA_I:
003aac 939a
003aad 938a                          savetos
003aae 918f                          pop tosl
003aaf 919f                          pop tosh  ; index
003ab0 91ef                          pop zl
003ab1 91ff                          pop zh    ; limit
003ab2 93ff                          push zh
003ab3 93ef                          push zl
003ab4 939f                          push tosh
003ab5 938f                          push tosl
003ab6 0f8e                          add tosl, zl
003ab7 1f9f                          adc tosh, zh
003ab8 cd4b                          jmp_ DO_NEXT
                                 .include "words/doplusloop.asm"
                                 
                                 ; System
                                 ; runtime of +loop
                                 ;VE_DOPLUSLOOP:
                                 ;    .dw $ff07
                                 ;    .db "(+loop)"
                                 ;    .dw VE_HEAD
                                 ;    .set VE_HEAD = VE_DOPLUSLOOP
                                 XT_DOPLUSLOOP:
003ab9 3aba                          .dw PFA_DOPLUSLOOP
                                 PFA_DOPLUSLOOP:
003aba 91ef                          pop zl
003abb 91ff                          pop zh
003abc 0fe8                          add zl, tosl
003abd 1ff9                          adc zh, tosh
003abe 9189
003abf 9199                          loadtos
003ac0 f01b                          brvs PFA_DOPLUSLOOP_LEAVE
                                     ; next cycle
                                 PFA_DOPLUSLOOP_NEXT:
                                     ; next iteration
003ac1 93ff                          push zh
003ac2 93ef                          push zl
003ac3 cd6b                          rjmp PFA_DOBRANCH ; read next cell from dictionary and jump to its destination
                                 PFA_DOPLUSLOOP_LEAVE:
003ac4 910f                          pop  temp0
003ac5 911f                          pop  temp1  ; remove limit
003ac6 9611                          adiw xl, 1  ; skip branch-back address
003ac7 cd3c                          jmp_ DO_NEXT
                                 .include "words/doloop.asm"
                                 
                                 ; System
                                 ; runtime of loop
                                 ;VE_DOLOOP:
                                 ;    .dw $ff06
                                 ;    .db "(loop)"
                                 ;    .dw VE_HEAD
                                 ;    .set VE_HEAD = VE_DOLOOP
                                 XT_DOLOOP:
003ac8 3ac9                          .dw PFA_DOLOOP
                                 PFA_DOLOOP:
003ac9 91ef                          pop zl
003aca 91ff                          pop zh
003acb 9631                          adiw zl,1
003acc f3bb                          brvs PFA_DOPLUSLOOP_LEAVE
003acd cff3                          jmp_ PFA_DOPLUSLOOP_NEXT
                                 .include "words/unloop.asm"
                                 
                                 ; Compiler
                                 ; remove loop-sys, exit the loop and continue execution after it
                                 VE_UNLOOP:
003ace ff06                          .dw $ff06
003acf 6e75
003ad0 6f6c
003ad1 706f                          .db "unloop"
003ad2 3aa8                          .dw VE_HEAD
                                     .set VE_HEAD = VE_UNLOOP
                                 XT_UNLOOP:
003ad3 3ad4                          .dw PFA_UNLOOP
                                 PFA_UNLOOP:
003ad4 911f                          pop temp1
003ad5 910f                          pop temp0
003ad6 911f                          pop temp1
003ad7 910f                          pop temp0
003ad8 cd2b                          jmp_ DO_NEXT
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 
                                 .include "words/cmove_g.asm"
                                 
                                 ; Memory
                                 ; copy data in RAM from higher to lower addresses.
                                 VE_CMOVE_G:
003ad9 ff06                          .dw $ff06
003ada 6d63
003adb 766f
003adc 3e65                          .db "cmove>"
003add 3ace                          .dw VE_HEAD
                                     .set VE_HEAD  = VE_CMOVE_G
                                 XT_CMOVE_G:
003ade 3adf                          .dw PFA_CMOVE_G
                                 PFA_CMOVE_G:
003adf 93bf                          push xh
003ae0 93af                          push xl
003ae1 91e9                          ld zl, Y+
003ae2 91f9                          ld zh, Y+ ; addr-to
003ae3 91a9                          ld xl, Y+
003ae4 91b9                          ld xh, Y+ ; addr-from
003ae5 2f09                          mov temp0, tosh
003ae6 2b08                          or temp0, tosl
003ae7 f041                          brbs 1, PFA_CMOVE_G1
003ae8 0fe8                          add zl, tosl
003ae9 1ff9                          adc zh, tosh
003aea 0fa8                          add xl, tosl
003aeb 1fb9                          adc xh, tosh
                                 PFA_CMOVE_G2:
003aec 911e                          ld temp1, -X
003aed 9312                          st -Z, temp1
003aee 9701                          sbiw tosl, 1
003aef f7e1                          brbc 1, PFA_CMOVE_G2
                                 PFA_CMOVE_G1:
003af0 91af                          pop xl
003af1 91bf                          pop xh
003af2 9189
003af3 9199                          loadtos
003af4 cd0f                          jmp_ DO_NEXT
                                 .include "words/byteswap.asm"
                                 
                                 ; Arithmetics
                                 ; exchange the bytes of the TOS
                                 VE_BYTESWAP:
003af5 ff02                          .dw $ff02
003af6 3c3e                          .db "><"
003af7 3ad9                          .dw VE_HEAD
                                     .set VE_HEAD = VE_BYTESWAP
                                 XT_BYTESWAP:
003af8 3af9                          .dw PFA_BYTESWAP
                                 PFA_BYTESWAP:
003af9 2f09                          mov temp0, tosh
003afa 2f98                          mov tosh, tosl
003afb 2f80                          mov tosl, temp0
003afc cd07                          jmp_ DO_NEXT
                                 .include "words/up.asm"
                                 
                                 ; System Variable
                                 ; get user area pointer
                                 VE_UP_FETCH:
003afd ff03                          .dw $ff03
003afe 7075
003aff 0040                          .db "up@",0
003b00 3af5                          .dw VE_HEAD
                                     .set VE_HEAD = VE_UP_FETCH
                                 XT_UP_FETCH:
003b01 3b02                          .dw PFA_UP_FETCH
                                 PFA_UP_FETCH:
003b02 939a
003b03 938a                          savetos
003b04 01c2                          movw tosl, upl
003b05 ccfe                          jmp_ DO_NEXT
                                 
                                 ; ( addr -- ) 
                                 ; System Variable
                                 ; set user area pointer
                                 VE_UP_STORE:
003b06 ff03                          .dw $ff03
003b07 7075
003b08 0021                          .db "up!",0
003b09 3afd                          .dw VE_HEAD
                                     .set VE_HEAD = VE_UP_STORE
                                 XT_UP_STORE:
003b0a 3b0b                          .dw PFA_UP_STORE
                                 PFA_UP_STORE:
003b0b 012c                          movw upl, tosl
003b0c 9189
003b0d 9199                          loadtos
003b0e ccf5                          jmp_ DO_NEXT
                                 .include "words/1ms.asm"
                                 
                                 ; Time
                                 ; busy waits (almost) exactly 1 millisecond
                                 VE_1MS:
003b0f ff03                          .dw $ff03
003b10 6d31
003b11 0073                          .db "1ms",0
003b12 3b06                          .dw VE_HEAD
                                     .set VE_HEAD = VE_1MS
                                 XT_1MS:
003b13 3b14                          .dw PFA_1MS
                                 PFA_1MS:
003b14 eae0
003b15 e0ff
003b16 9731
003b17 f7f1                          delay 1000
003b18 cceb                          jmp_ DO_NEXT
                                 .include "words/2to_r.asm"
                                 
                                 ; Stack
                                 ; move DTOS to TOR
                                 VE_2TO_R:
003b19 ff03                          .dw $ff03
003b1a 3e32
003b1b 0072                          .db "2>r",0
003b1c 3b0f                          .dw VE_HEAD
                                     .set VE_HEAD = VE_2TO_R
                                 XT_2TO_R:
003b1d 3b1e                          .dw PFA_2TO_R
                                 PFA_2TO_R:
003b1e 01fc                          movw zl, tosl
003b1f 9189
003b20 9199                          loadtos
003b21 939f                          push tosh
003b22 938f                          push tosl
003b23 93ff                          push zh
003b24 93ef                          push zl
003b25 9189
003b26 9199                          loadtos
003b27 ccdc                          jmp_ DO_NEXT
                                 .include "words/2r_from.asm"
                                 
                                 ; Stack
                                 ; move DTOR to TOS
                                 VE_2R_FROM:
003b28 ff03                          .dw $ff03
003b29 7232
003b2a 003e                          .db "2r>",0
003b2b 3b19                          .dw VE_HEAD
                                     .set VE_HEAD = VE_2R_FROM
                                 XT_2R_FROM:
003b2c 3b2d                          .dw PFA_2R_FROM
                                 PFA_2R_FROM:
003b2d 939a
003b2e 938a                          savetos
003b2f 91ef                          pop zl
003b30 91ff                          pop zh
003b31 918f                          pop tosl
003b32 919f                          pop tosh
003b33 939a
003b34 938a                          savetos
003b35 01cf                          movw tosl, zl
003b36 cccd                          jmp_ DO_NEXT
                                 
                                 .include "words/store-e.asm"
                                 
                                 ; Memory
                                 ; write n (2bytes) to eeprom address
                                 VE_STOREE:
003b37 ff02                          .dw $ff02
003b38 6521                          .db "!e"
003b39 3b28                          .dw VE_HEAD
                                     .set VE_HEAD = VE_STOREE
                                 XT_STOREE:
003b3a 3b3b                          .dw PFA_STOREE
                                 PFA_STOREE:
                                 .if WANT_UNIFIED == 1
                                 .endif
                                 PFA_STOREE0:
003b3b 01fc                          movw zl, tosl
003b3c 9189
003b3d 9199                          loadtos
003b3e b72f                          in_ temp2, SREG
003b3f 94f8                          cli
003b40 d028                          rcall PFA_FETCHE2
003b41 b500                          in_  temp0, EEDR
003b42 1708                          cp temp0,tosl
003b43 f009                          breq PFA_STOREE3
003b44 d00b                          rcall PFA_STOREE1
                                 PFA_STOREE3:
003b45 9631                          adiw zl,1
003b46 d022                          rcall PFA_FETCHE2
003b47 b500                          in_  temp0, EEDR
003b48 1709                          cp temp0,tosh
003b49 f011                          breq PFA_STOREE4
003b4a 2f89                          mov tosl, tosh
003b4b d004                          rcall PFA_STOREE1
                                 PFA_STOREE4:
003b4c bf2f                          out_ SREG, temp2
003b4d 9189
003b4e 9199                          loadtos
003b4f ccb4                          jmp_ DO_NEXT
                                     
                                 PFA_STOREE1:
003b50 99f9                          sbic EECR, EEPE
003b51 cffe                          rjmp PFA_STOREE1
                                 
                                 PFA_STOREE2: ; estore_wait_low_spm:
003b52 b707                          in_ temp0, SPMCSR
003b53 fd00                          sbrc temp0,SPMEN
003b54 cffd                          rjmp PFA_STOREE2
                                 
003b55 bdf2                          out_ EEARH,zh
003b56 bde1                          out_ EEARL,zl
003b57 bd80                          out_ EEDR, tosl
003b58 9afa                          sbi EECR,EEMPE
003b59 9af9                          sbi EECR,EEPE
                                 
003b5a 9508                          ret
                                 .if WANT_UNIFIED == 1
                                 .endif
                                 .include "words/fetch-e.asm"
                                 
                                 ; Memory
                                 ; read 1 cell from eeprom
                                 VE_FETCHE:
003b5b ff02                          .dw $ff02
003b5c 6540                          .db "@e"
003b5d 3b37                          .dw VE_HEAD
                                     .set VE_HEAD = VE_FETCHE
                                 XT_FETCHE:
003b5e 3b5f                          .dw PFA_FETCHE
                                 PFA_FETCHE:
                                 .if WANT_UNIFIED == 1
                                 .endif
                                 PFA_FETCHE1:
003b5f b72f                          in_ temp2, SREG
003b60 94f8                          cli
003b61 01fc                          movw zl, tosl
003b62 d006                          rcall PFA_FETCHE2
003b63 b580                          in_ tosl, EEDR
                                 
003b64 9631                          adiw zl,1
                                 
003b65 d003                          rcall PFA_FETCHE2
003b66 b590                          in_  tosh, EEDR
003b67 bf2f                          out_ SREG, temp2
003b68 cc9b                          jmp_ DO_NEXT
                                 
                                 PFA_FETCHE2:
003b69 99f9                          sbic EECR, EEPE
003b6a cffe                          rjmp PFA_FETCHE2
                                 
003b6b bdf2                          out_ EEARH,zh
003b6c bde1                          out_ EEARL,zl
                                 
003b6d 9af8                          sbi EECR,EERE
003b6e 9508                          ret
                                 
                                 .if WANT_UNIFIED == 1
                                 .endif
                                 .include "words/store-i.asm"
                                 
                                 ; System Value
                                 ; Deferred action to write a single 16bit cell to flash
                                 VE_STOREI:
003b6f ff02                          .dw $ff02
003b70 6921                          .db "!i"
003b71 3b5b                          .dw VE_HEAD
                                     .set VE_HEAD = VE_STOREI
                                 XT_STOREI:
003b72 3dfe                          .dw PFA_DODEFER1
                                 PFA_STOREI:
003b73 0066                          .dw EE_STOREI
003b74 3d9f                          .dw XT_EDEFERFETCH
003b75 3da9                          .dw XT_EDEFERSTORE
                                 .if FLASHEND > $10000
                                 .else
                                   .include "words/store-i_nrww.asm"
                                 
                                 ; Memory
                                 ; writes n to flash memory using assembly code (code to be placed in boot loader section)
                                 VE_DO_STOREI_NRWW:
003b76 ff09                          .dw $ff09
003b77 2128
003b78 2d69
003b79 726e
003b7a 7777
003b7b 0029                          .db "(!i-nrww)",0
003b7c 3b6f                          .dw VE_HEAD
                                     .set VE_HEAD = VE_DO_STOREI_NRWW
                                 XT_DO_STOREI:
003b7d 3b7e                          .dw PFA_DO_STOREI_NRWW
                                 PFA_DO_STOREI_NRWW:
                                   ; store status register
003b7e b71f                        in temp1,SREG
003b7f 931f                        push temp1
003b80 94f8                        cli
                                 
003b81 019c                        movw temp2, tosl ; save the (word) address
003b82 9189
003b83 9199                        loadtos          ; get the new value for the flash cell
003b84 93af                        push xl
003b85 93bf                        push xh
003b86 93cf                        push yl
003b87 93df                        push yh
003b88 d009                        rcall DO_STOREI_atmega
003b89 91df                        pop yh
003b8a 91cf                        pop yl
003b8b 91bf                        pop xh
003b8c 91af                        pop xl
                                   ; finally clear the stack
003b8d 9189
003b8e 9199                        loadtos
003b8f 911f                        pop temp1
                                   ; restore status register (and interrupt enable flag)
003b90 bf1f                        out SREG,temp1
                                 
003b91 cc72                        jmp_ DO_NEXT
                                 
                                 ; 
                                 DO_STOREI_atmega:
                                   ; write data to temp page buffer
                                   ; use the values in tosl/tosh at the
                                   ; appropiate place
003b92 d010                        rcall pageload
                                 
                                   ; erase page if needed
                                   ; it is needed if a bit goes from 0 to 1
003b93 94e0                        com temp4
003b94 94f0                        com temp5
003b95 218e                        and tosl, temp4
003b96 219f                        and tosh, temp5
003b97 2b98                        or tosh, tosl
003b98 f019                        breq DO_STOREI_writepage 
003b99 01f9                          movw zl, temp2
003b9a e002                          ldi temp0,(1<<PGERS)
003b9b d020                          rcall dospm
                                 
                                 DO_STOREI_writepage:
                                   ; write page
003b9c 01f9                        movw zl, temp2
003b9d e004                        ldi temp0,(1<<PGWRT)
003b9e d01d                        rcall dospm
                                 
                                   ; reenable RWW section
003b9f 01f9                        movw zl, temp2
003ba0 e100                        ldi temp0,(1<<RWWSRE)
003ba1 d01a                        rcall dospm
003ba2 9508                        ret
                                 
                                 ; load the desired page
                                 .equ pagemask = ~ ( PAGESIZE - 1 )
                                 pageload:
003ba3 01f9                        movw zl, temp2
                                   ; get the beginning of page
003ba4 7ce0                        andi zl,low(pagemask)
003ba5 7fff                        andi zh,high(pagemask)
003ba6 01ef                        movw y, z
                                   ; loop counter (in words)
003ba7 e4a0                        ldi xl,low(pagesize)
003ba8 e0b0                        ldi xh,high(pagesize)
                                 pageload_loop:
                                   ; we need the current flash value anyways
003ba9 01fe                        movw z, y
003baa 0fee
003bab 1fff
003bac 9145
003bad 9155                        readflashcell temp6, temp7 ; destroys Z
                                   ; now check: if Z points to the same cell as temp2/3, we want the new data
003bae 01fe                        movw z, y
003baf 17e2                        cp zl, temp2
003bb0 07f3                        cpc zh, temp3
003bb1 f011                        breq pageload_newdata
003bb2 010a                          movw r0, temp6
003bb3 c002                          rjmp pageload_cont
                                 pageload_newdata:
003bb4 017a                          movw temp4, temp6
003bb5 010c                          movw r0, tosl
                                 pageload_cont:
003bb6 2700                        clr temp0
003bb7 d004                        rcall dospm
003bb8 9621                        adiw y, 1
003bb9 9711                        sbiw x, 1
003bba f771                        brne pageload_loop
                                 
                                 pageload_done:
003bbb 9508                        ret
                                 
                                 
                                 ;; dospm
                                 ;;
                                 ;; execute spm instruction
                                 ;;   temp0 holds the value for SPMCR
                                 
                                 dospm:
                                 dospm_wait_ee:
003bbc 99f9                        sbic EECR, EEPE
003bbd cffe                        rjmp dospm_wait_ee
                                 dospm_wait_spm:
003bbe b717                        in_  temp1, SPMCSR
003bbf fd10                        sbrc temp1, SPMEN
003bc0 cffd                        rjmp dospm_wait_spm
                                 
                                   ; turn the word addres into a byte address
003bc1 0fee
003bc2 1fff                        writeflashcell
                                   ; execute spm
003bc3 6001                        ori temp0, (1<<SPMEN)
003bc4 bf07                        out_ SPMCSR,temp0
003bc5 95e8                        spm
003bc6 9508                        ret
                                 .endif
                                 .include "words/fetch-i.asm"
                                 
                                 ; Memory
                                 ; read 1 cell from flash
                                 VE_FETCHI:
003bc7 ff02                          .dw $ff02
003bc8 6940                          .db "@i"
003bc9 3b76                          .dw VE_HEAD
                                     .set VE_HEAD = VE_FETCHI
                                 XT_FETCHI:
003bca 3bcb                          .dw PFA_FETCHI
                                 PFA_FETCHI:
003bcb 01fc                          movw zl, tosl
003bcc 0fee
003bcd 1fff
003bce 9185
003bcf 9195                          readflashcell tosl,tosh
003bd0 cc33                          jmp_ DO_NEXT
                                 
                                 .if AMFORTH_NRWW_SIZE>8000
                                 .elif AMFORTH_NRWW_SIZE>4000
                                 .include "dict/core_4k.inc"
                                 
                                 ; in a short distance to DO_NEXT
                                 .include "words/n_to_r.asm"
                                 
                                 ; Stack
                                 ; move n items from data stack to return stack
                                 VE_N_TO_R:
003bd1 ff03                          .dw $ff03
003bd2 3e6e
003bd3 0072                          .db "n>r",0
003bd4 3bc7                          .dw VE_HEAD
                                     .set VE_HEAD = VE_N_TO_R
                                 XT_N_TO_R:
003bd5 3bd6                          .dw PFA_N_TO_R
                                 PFA_N_TO_R:
003bd6 01fc                          movw zl, tosl
003bd7 2f08                          mov  temp0, tosl
                                 PFA_N_TO_R1:
003bd8 9189
003bd9 9199                          loadtos
003bda 939f                          push tosh
003bdb 938f                          push tosl
003bdc 950a                          dec temp0
003bdd f7d1                          brne PFA_N_TO_R1
003bde 93ef                          push zl
003bdf 93ff                          push zh
003be0 9189
003be1 9199                          loadtos
003be2 cc21                          jmp_ DO_NEXT
                                 .include "words/n_r_from.asm"
                                 
                                 ; Stack
                                 ; move n items from return stack to data stack
                                 VE_N_R_FROM:
003be3 ff03                          .dw $ff03
003be4 726e
003be5 003e                          .db "nr>",0
003be6 3bd1                          .dw VE_HEAD
                                     .set VE_HEAD = VE_N_R_FROM
                                 XT_N_R_FROM:
003be7 3be8                          .dw PFA_N_R_FROM
                                 PFA_N_R_FROM:
003be8 939a
003be9 938a                          savetos
003bea 91ff                          pop zh
003beb 91ef                          pop zl
003bec 2f0e                          mov  temp0, zl
                                 PFA_N_R_FROM1:
003bed 918f                          pop tosl
003bee 919f                          pop tosh
003bef 939a
003bf0 938a                          savetos
003bf1 950a                          dec temp0
003bf2 f7d1                          brne PFA_N_R_FROM1
003bf3 01cf                          movw tosl, zl
003bf4 cc0f                          jmp_ DO_NEXT
                                 .include "words/d-2star.asm"
                                 
                                 ; Arithmetics
                                 ; shift a double cell left
                                 VE_D2STAR:
003bf5 ff03                          .dw $ff03
003bf6 3264
003bf7 002a                          .db "d2*",0
003bf8 3be3                          .dw VE_HEAD
                                     .set VE_HEAD = VE_D2STAR
                                 XT_D2STAR:
003bf9 3bfa                          .dw PFA_D2STAR
                                 PFA_D2STAR:
003bfa 9109                          ld temp0, Y+
003bfb 9119                          ld temp1, Y+
003bfc 0f00                          lsl temp0
003bfd 1f11                          rol temp1
003bfe 1f88                          rol tosl
003bff 1f99                          rol tosh
003c00 931a                          st -Y, temp1
003c01 930a                          st -Y, temp0
003c02 cc01                          jmp_ DO_NEXT
                                 .include "words/d-2slash.asm"
                                 
                                 ; Arithmetics
                                 ; shift a double cell value right
                                 VE_D2SLASH:
003c03 ff03                          .dw $ff03
003c04 3264
003c05 002f                          .db "d2/",0
003c06 3bf5                          .dw VE_HEAD
                                     .set VE_HEAD = VE_D2SLASH
                                 XT_D2SLASH:
003c07 3c08                          .dw PFA_D2SLASH
                                 PFA_D2SLASH:
003c08 9109                          ld temp0, Y+
003c09 9119                          ld temp1, Y+
003c0a 9595                          asr tosh
003c0b 9587                          ror tosl
003c0c 9517                          ror temp1
003c0d 9507                          ror temp0
003c0e 931a                          st -Y, temp1
003c0f 930a                          st -Y, temp0
003c10 cbf3                          jmp_ DO_NEXT
                                 .include "words/d-plus.asm"
                                 
                                 ; Arithmetics
                                 ; add 2 double cell values
                                 VE_DPLUS:
003c11 ff02                          .dw $ff02
003c12 2b64                          .db "d+"
003c13 3c03                          .dw VE_HEAD
                                     .set VE_HEAD = VE_DPLUS
                                 XT_DPLUS:
003c14 3c15                          .dw PFA_DPLUS
                                 PFA_DPLUS:
003c15 9129                          ld temp2, Y+
003c16 9139                          ld temp3, Y+
                                 
003c17 90e9                          ld temp4, Y+
003c18 90f9                          ld temp5, Y+
003c19 9149                          ld temp6, Y+
003c1a 9159                          ld temp7, Y+
                                 
003c1b 0f24                          add temp2, temp6
003c1c 1f35                          adc temp3, temp7
003c1d 1d8e                          adc tosl, temp4
003c1e 1d9f                          adc tosh, temp5
                                     
003c1f 933a                          st -Y, temp3
003c20 932a                          st -Y, temp2
003c21 cbe2                          jmp_ DO_NEXT
                                 .include "words/d-minus.asm"
                                 
                                 ; Arithmetics
                                 ; subtract d2 from d1 
                                 VE_DMINUS:
003c22 ff02                          .dw $ff02
003c23 2d64                          .db "d-"
003c24 3c11                          .dw VE_HEAD
                                     .set VE_HEAD = VE_DMINUS
                                 XT_DMINUS:
003c25 3c26                          .dw PFA_DMINUS
                                 PFA_DMINUS:
003c26 9129                          ld temp2, Y+
003c27 9139                          ld temp3, Y+
                                 
003c28 90e9                          ld temp4, Y+
003c29 90f9                          ld temp5, Y+
003c2a 9149                          ld temp6, Y+
003c2b 9159                          ld temp7, Y+
                                 
003c2c 1b42                          sub temp6, temp2
003c2d 0b53                          sbc temp7, temp3
003c2e 0ae8                          sbc temp4, tosl
003c2f 0af9                          sbc temp5, tosh
                                 
003c30 935a                          st -Y, temp7
003c31 934a                          st -Y, temp6
003c32 01c7                          movw tosl, temp4
003c33 cbd0                          jmp_ DO_NEXT
                                 .include "words/d-invert.asm"
                                 
                                 ; Arithmetics
                                 ; invert all bits in the double cell value
                                 VE_DINVERT:
003c34 ff07                          .dw $ff07
003c35 6964
003c36 766e
003c37 7265
003c38 0074                          .db "dinvert",0
003c39 3c22                          .dw VE_HEAD
                                     .set VE_HEAD = VE_DINVERT
                                 XT_DINVERT:
003c3a 3c3b                          .dw PFA_DINVERT
                                 PFA_DINVERT:
003c3b 9109                          ld temp0, Y+
003c3c 9119                          ld temp1, Y+
003c3d 9580                          com tosl
003c3e 9590                          com tosh
003c3f 9500                          com temp0
003c40 9510                          com temp1
003c41 931a                          st -Y, temp1
003c42 930a                          st -Y, temp0
003c43 cbc0                          jmp_ DO_NEXT
                                 .include "words/slashmod.asm"
                                 
                                 ; Arithmetics
                                 ; signed division n1/n2 with remainder and quotient
                                 VE_SLASHMOD:
003c44 ff04                          .dw $ff04
003c45 6d2f
003c46 646f                          .db "/mod"
003c47 3c34                          .dw VE_HEAD
                                     .set VE_HEAD = VE_SLASHMOD
                                 XT_SLASHMOD:
003c48 3c49                          .dw PFA_SLASHMOD
                                 PFA_SLASHMOD:
003c49 019c                          movw temp2, tosl
                                     
003c4a 9109                          ld temp0, Y+
003c4b 9119                          ld temp1, Y+
                                 
003c4c 2f41                          mov	temp6,temp1	;move dividend High to sign register
003c4d 2743                          eor	temp6,temp3	;xor divisor High with sign register
003c4e ff17                          sbrs	temp1,7	;if MSB in dividend set
003c4f c004                          rjmp	PFA_SLASHMOD_1
003c50 9510                          com	temp1		;    change sign of dividend
003c51 9500                          com	temp0		
003c52 5f0f                          subi	temp0,low(-1)
003c53 4f1f                          sbci	temp1,high(-1)
                                 PFA_SLASHMOD_1:	
003c54 ff37                          sbrs	temp3,7	;if MSB in divisor set
003c55 c004                          rjmp	PFA_SLASHMOD_2
003c56 9530                          com	temp3		;    change sign of divisor
003c57 9520                          com	temp2		
003c58 5f2f                          subi	temp2,low(-1)
003c59 4f3f                          sbci	temp3,high(-1)
003c5a 24ee                      PFA_SLASHMOD_2:	clr	temp4	;clear remainder Low byte
003c5b 18ff                          sub	temp5,temp5;clear remainder High byte and carry
003c5c e151                          ldi	temp7,17	;init loop counter
                                 
003c5d 1f00                      PFA_SLASHMOD_3:	rol	temp0		;shift left dividend
003c5e 1f11                          rol	temp1
003c5f 955a                          dec	temp7		;decrement counter
003c60 f439                          brne	PFA_SLASHMOD_5		;if done
003c61 ff47                          sbrs	temp6,7		;    if MSB in sign register set
003c62 c004                          rjmp	PFA_SLASHMOD_4
003c63 9510                          com	temp1	;        change sign of result
003c64 9500                          com	temp0
003c65 5f0f                          subi	temp0,low(-1)
003c66 4f1f                          sbci	temp1,high(-1)
003c67 c00b                      PFA_SLASHMOD_4:	rjmp PFA_SLASHMODmod_done			;    return
003c68 1cee                      PFA_SLASHMOD_5:	rol	temp4	;shift dividend into remainder
003c69 1cff                          rol	temp5
003c6a 1ae2                          sub	temp4,temp2	;remainder = remainder - divisor
003c6b 0af3                          sbc	temp5,temp3	;
003c6c f420                          brcc	PFA_SLASHMOD_6		;if result negative
003c6d 0ee2                          add	temp4,temp2	;    restore remainder
003c6e 1ef3                          adc	temp5,temp3
003c6f 9488                          clc			;    clear carry to be shifted into result
003c70 cfec                          rjmp	PFA_SLASHMOD_3		;else
003c71 9408                      PFA_SLASHMOD_6:	sec			;    set carry to be shifted into result
003c72 cfea                          rjmp	PFA_SLASHMOD_3
                                 
                                 PFA_SLASHMODmod_done:
                                     ; put remainder on stack
003c73 92fa                          st -Y,temp5
003c74 92ea                          st -Y,temp4
                                 
                                     ; put quotient on stack
003c75 01c8                          movw tosl, temp0
003c76 cb8d                          jmp_ DO_NEXT
                                 .include "words/abs.asm"
                                 
                                 ;   DUP ?NEGATE ;
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_ABS:
003c77 ff03                          .dw $ff03
003c78 6261
003c79 0073                          .db "abs",0
003c7a 3c44                          .dw VE_HEAD
                                     .set VE_HEAD = VE_ABS
                                 XT_ABS:
003c7b 3800                          .dw DO_COLON
                                 PFA_ABS:
                                 
                                 .endif
                                 
003c7c 38b0
003c7d 3a3d
003c7e 381f                          .DW XT_DUP,XT_QNEGATE,XT_EXIT
                                 .include "words/pick.asm"
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_PICK:
003c7f ff04                          .dw $ff04
003c80 6970
003c81 6b63                          .db "pick"
003c82 3c77                          .dw VE_HEAD
                                     .set VE_HEAD = VE_PICK
                                 XT_PICK:
003c83 3800                          .dw DO_COLON
                                 PFA_PICK:
                                 .endif
003c84 3a2e                          .dw XT_1PLUS
003c85 3ec3                          .dw XT_CELLS
003c86 3a8c                          .dw XT_SP_FETCH
003c87 399c                          .dw XT_PLUS
003c88 3878                          .dw XT_FETCH
003c89 381f                          .dw XT_EXIT
                                 .include "words/cellplus.asm"
                                 
                                 ; Arithmetics
                                 ; add the size of an address-unit to a-addr1
                                 VE_CELLPLUS:
003c8a ff05                          .dw $ff05
003c8b 6563
003c8c 6c6c
003c8d 002b                          .db "cell+",0
003c8e 3c7f                          .dw VE_HEAD
                                     .set VE_HEAD = VE_CELLPLUS
                                 XT_CELLPLUS:
003c8f 3c90                          .dw PFA_CELLPLUS
                                 PFA_CELLPLUS:
003c90 9602                          adiw tosl, CELLSIZE
003c91 cb72                          jmp_ DO_NEXT
                                 .include "dict/interrupt.inc"
                                 
                                 .if WANT_INTERRUPTS == 1
                                 
                                 .if WANT_INTERRUPT_COUNTERS == 1
                                 .endif
                                 
                                 .include "words/int-on.asm"
                                 
                                 ; Interrupt
                                 ; turns on all interrupts
                                 VE_INTON:
003c92 ff04                          .dw $ff04
003c93 692b
003c94 746e                          .db "+int"
003c95 3c8a                          .dw VE_HEAD
                                     .set VE_HEAD = VE_INTON
                                 XT_INTON:
003c96 3c97                          .dw PFA_INTON
                                 PFA_INTON:
003c97 9478                          sei
003c98 cb6b                          jmp_ DO_NEXT
                                 .include "words/int-off.asm"
                                 
                                 ; Interrupt
                                 ; turns off all interrupts 
                                 VE_INTOFF:
003c99 ff04                          .dw $ff04
003c9a 692d
003c9b 746e                          .db "-int"
003c9c 3c92                          .dw VE_HEAD
                                     .set VE_HEAD = VE_INTOFF
                                 XT_INTOFF:
003c9d 3c9e                          .dw PFA_INTOFF
                                 PFA_INTOFF:
003c9e 94f8                          cli
003c9f cb64                          jmp_ DO_NEXT
                                 .include "words/int-store.asm"
                                 
                                 ; Interrupt
                                 ; stores XT as interrupt vector i
                                 VE_INTSTORE:
003ca0 ff04                          .dw $ff04
003ca1 6e69
003ca2 2174                          .db "int!"
003ca3 3c99                          .dw VE_HEAD
                                     .set VE_HEAD = VE_INTSTORE
                                 XT_INTSTORE:
003ca4 3800                          .dw DO_COLON
                                 PFA_INTSTORE:
003ca5 383c                          .dw XT_DOLITERAL
003ca6 0000                          .dw intvec
003ca7 399c                          .dw XT_PLUS
003ca8 3b3a                          .dw XT_STOREE
003ca9 381f                          .dw XT_EXIT
                                 .include "words/int-fetch.asm"
                                 
                                 ; Interrupt
                                 ; fetches XT from interrupt vector i
                                 VE_INTFETCH:
003caa ff04                          .dw $ff04
003cab 6e69
003cac 4074                          .db "int@"
003cad 3ca0                          .dw VE_HEAD
                                     .set VE_HEAD = VE_INTFETCH
                                 XT_INTFETCH:
003cae 3800                          .dw DO_COLON
                                 PFA_INTFETCH:
003caf 383c                          .dw XT_DOLITERAL
003cb0 0000                          .dw intvec
003cb1 399c                          .dw XT_PLUS
003cb2 3b5e                          .dw XT_FETCHE
003cb3 381f                          .dw XT_EXIT
                                 .include "words/int-trap.asm"
                                 
                                 ; Interrupt
                                 ; trigger an interrupt
                                 VE_INTTRAP:
003cb4 ff08                          .dw $ff08
003cb5 6e69
003cb6 2d74
003cb7 7274
003cb8 7061                          .db "int-trap"
003cb9 3caa                          .dw VE_HEAD
                                     .set VE_HEAD = VE_INTTRAP
                                 XT_INTTRAP:
003cba 3cbb                          .dw PFA_INTTRAP
                                 PFA_INTTRAP:
003cbb 2eb8                          mov isrflag, tosl
003cbc 9189
003cbd 9199                          loadtos
003cbe cb45                          jmp_ DO_NEXT
                                 
                                 .include "words/isr-exec.asm"
                                 
                                 ; Interrupt
                                 ; executes an interrupt service routine
                                 ;VE_ISREXEC:
                                 ;    .dw $ff08
                                 ;    .db "isr-exec"
                                 ;    .dw VE_HEAD
                                 ;    .set VE_HEAD = VE_ISREXEC
                                 XT_ISREXEC:
003cbf 3800                          .dw DO_COLON
                                 PFA_ISREXEC:
003cc0 3cae                          .dw XT_INTFETCH
003cc1 3829                          .dw XT_EXECUTE
003cc2 3cc4                          .dw XT_ISREND
003cc3 381f                          .dw XT_EXIT
                                 .include "words/isr-end.asm"
                                 
                                 ; Interrupt
                                 ; re-enables interrupts in an ISR
                                 ;VE_ISREND:
                                 ;    .dw $ff07
                                 ;    .db "isr-end",0
                                 ;    .dw VE_HEAD
                                 ;    .set VE_HEAD = VE_ISREND
                                 XT_ISREND:
003cc4 3cc5                          .dw PFA_ISREND
                                 PFA_ISREND:
003cc5 d001                          rcall PFA_ISREND1 ; clear the interrupt flag for the controller
003cc6 cb3d                          jmp_ DO_NEXT
                                 PFA_ISREND1:
003cc7 9518                          reti
                                 .endif
                                 
                                 ; now the relocatable colon words
                                 .include "words/prompt-ok.asm"
                                 
                                 ; System
                                 ; send the READY prompt to the command line
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 ;VE_PROMPTOK:
                                 ;    .dw $ff02
                                 ;    .db "ok"
                                 ;    .dw VE_HEAD
                                 ;    .set VE_HEAD = VE_PROMPTOK
                                 XT_DEFAULT_PROMPTOK:
003cc8 3800                          .dw DO_COLON
                                 PFA_DEFAULT_PROMPTOK:
003cc9 03d0                          .dw XT_DOSLITERAL
003cca 0003                          .dw 3
003ccb 6f20
003ccc 006b                          .db " ok",0
                                 .endif
003ccd 0403                          .dw XT_ITYPE
003cce 381f                          .dw XT_EXIT
                                 
                                 ; ------------------------
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_PROMPTOK:
003ccf ff03                          .dw $FF03
003cd0 6f2e
amforth-6.5\common\words/prompt-ok.asm(43): warning: .cseg .db misalignment - padding zero byte
003cd1 006b                          .db ".ok"
003cd2 3cb4                          .dw VE_HEAD
                                     .set VE_HEAD = VE_PROMPTOK
                                 XT_PROMPTOK:
003cd3 3dfe                          .dw PFA_DODEFER1
                                 PFA_PROMPTOK:
                                 .endif
003cd4 001c                          .dw USER_P_OK
003cd5 3dc7                          .dw XT_UDEFERFETCH
003cd6 3dd3                          .dw XT_UDEFERSTORE
                                 .include "words/prompt-ready.asm"
                                 
                                 ; System
                                 ; process the error prompt
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 ;VE_PROMPTRDY:
                                 ;    .dw $ff04
                                 ;    .db "p_er"
                                 ;    .dw VE_HEAD
                                 ;    .set VE_HEAD = VE_PROMPTRDY
                                 XT_DEFAULT_PROMPTREADY:
003cd7 3800                          .dw DO_COLON
                                 PFA_DEFAULT_PROMPTREADY:
003cd8 03d0                          .dw XT_DOSLITERAL
003cd9 0002                          .dw 2
003cda 203e                          .db "> "
                                 .endif
003cdb 3fa0                          .dw XT_CR
003cdc 0403                          .dw XT_ITYPE
003cdd 381f                          .dw XT_EXIT
                                 
                                 ; ------------------------
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_PROMPTREADY:
003cde ff06                          .dw $FF06
003cdf 722e
003ce0 6165
003ce1 7964                          .db ".ready"
003ce2 3ccf                          .dw VE_HEAD
                                     .set VE_HEAD = VE_PROMPTREADY
                                 XT_PROMPTREADY:
003ce3 3dfe                          .dw PFA_DODEFER1
                                 PFA_PROMPTREADY:
                                 .endif
003ce4 0020                          .dw USER_P_RDY
003ce5 3dc7                          .dw XT_UDEFERFETCH
003ce6 3dd3                          .dw XT_UDEFERSTORE
                                 .include "words/prompt-error.asm"
                                 
                                 ; System
                                 ; process the error prompt
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 ;VE_PROMPTERROR:
                                 ;    .dw $ff04
                                 ;    .db "p_er"
                                 ;    .dw VE_HEAD
                                 ;    .set VE_HEAD = VE_PROMPTERROR
                                 XT_DEFAULT_PROMPTERROR:
003ce7 3800                          .dw DO_COLON
                                 PFA_DEFAULT_PROMPTERROR:
003ce8 03d0                      	.dw XT_DOSLITERAL
003ce9 0004                          .dw 4
003cea 3f20
003ceb 203f                          .db " ?? "
                                 .endif
003cec 0403                          .dw XT_ITYPE
003ced 3ebc                          .dw XT_BASE
003cee 3878                          .dw XT_FETCH
003cef 38fe                          .dw XT_TO_R
003cf0 3f40                          .dw XT_DECIMAL
003cf1 0385                          .dw XT_DOT
003cf2 3ee1                          .dw XT_TO_IN
003cf3 3878                          .dw XT_FETCH
003cf4 0385                          .dw XT_DOT
003cf5 38f5                          .dw XT_R_FROM
003cf6 3ebc                          .dw XT_BASE
003cf7 3880                          .dw XT_STORE
003cf8 381f                          .dw XT_EXIT
                                 
                                 ; ------------------------
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_PROMPTERROR:
003cf9 ff06                          .dw $FF06
003cfa 652e
003cfb 7272
003cfc 726f                          .db ".error"
003cfd 3cde                          .dw VE_HEAD
                                     .set VE_HEAD = VE_PROMPTERROR
                                 XT_PROMPTERROR:
003cfe 3dfe                          .dw PFA_DODEFER1
                                 PFA_PROMPTERROR:
                                 .endif
003cff 001e                          .dw USER_P_ERR
003d00 3dc7                          .dw XT_UDEFERFETCH
003d01 3dd3                          .dw XT_UDEFERSTORE
                                 
                                 .include "words/quit.asm"
                                 
                                 ; System
                                 ; main loop of amforth. accept - interpret in an endless loop
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_QUIT:
003d02 ff04                          .dw $ff04
003d03 7571
003d04 7469                          .db "quit"
003d05 3cf9                          .dw VE_HEAD
                                     .set VE_HEAD = VE_QUIT
                                 XT_QUIT:
003d06 3800                          .dw DO_COLON
                                 .endif
                                 PFA_QUIT:
003d07 085c
003d08 0863
003d09 3880                          .dw XT_LP0,XT_LP,XT_STORE
003d0a 05d5                          .dw XT_SP0
003d0b 3a95                          .dw XT_SP_STORE
003d0c 05e2                          .dw XT_RP0
003d0d 3a7f                          .dw XT_RP_STORE
003d0e 08f1                          .dw XT_LBRACKET
                                 
                                 PFA_QUIT2:
003d0f 3eb6                          .dw XT_STATE
003d10 3878                          .dw XT_FETCH
003d11 3919                          .dw XT_ZEROEQUAL
003d12 3835                          .dw XT_DOCONDBRANCH
003d13 3d15                          DEST(PFA_QUIT4)
003d14 3ce3                          .dw XT_PROMPTREADY
                                 PFA_QUIT4:
003d15 04e9                          .dw XT_REFILL
003d16 3835                          .dw XT_DOCONDBRANCH
003d17 3d27                          DEST(PFA_QUIT3)
003d18 383c                          .dw XT_DOLITERAL
003d19 0630                          .dw XT_INTERPRET
003d1a 3d6f                          .dw XT_CATCH
003d1b 38b8                          .dw XT_QDUP
003d1c 3835                          .dw XT_DOCONDBRANCH
003d1d 3d27                          DEST(PFA_QUIT3)
003d1e 38b0                      	.dw XT_DUP
003d1f 383c                      	.dw XT_DOLITERAL
003d20 fffe                      	.dw -2
003d21 396d                      	.dw XT_LESS
003d22 3835                      	.dw XT_DOCONDBRANCH
003d23 3d25                      	DEST(PFA_QUIT5)
003d24 3cfe                      	.dw XT_PROMPTERROR
                                 PFA_QUIT5:
003d25 382e                      	.dw XT_DOBRANCH
003d26 3d07                      	DEST(PFA_QUIT)
                                 PFA_QUIT3:
003d27 3cd3                          .dw XT_PROMPTOK
003d28 382e                          .dw XT_DOBRANCH
003d29 3d0f                          DEST(PFA_QUIT2)
                                 ;    .dw XT_EXIT ; never reached
                                 
                                 .include "words/pause.asm"
                                 
                                 ; Multitasking
                                 ; Fetch pause vector and execute it. may make a context/task switch
                                 VE_PAUSE:
003d2a ff05                          .dw $ff05
003d2b 6170
003d2c 7375
003d2d 0065                          .db "pause",0
003d2e 3d02                          .dw VE_HEAD
                                     .set VE_HEAD = VE_PAUSE
                                 XT_PAUSE:
003d2f 3dfe                          .dw PFA_DODEFER1
                                 PFA_PAUSE:
003d30 0192                          .dw ram_pause
003d31 3db3                          .dw XT_RDEFERFETCH
003d32 3dbd                          .dw XT_RDEFERSTORE
                                 
                                 .dseg
000192                           ram_pause: .byte 2
                                 .cseg
                                 .include "words/cold.asm"
                                 
                                 ; System
                                 ; start up amforth.
                                 VE_COLD:
003d33 ff04                          .dw $ff04
003d34 6f63
003d35 646c                          .db "cold"
003d36 3d2a                          .dw VE_HEAD
                                     .set VE_HEAD = VE_COLD
                                 XT_COLD:
003d37 3d38                          .dw PFA_COLD
                                 PFA_COLD:
003d38 b6a4                          in_ mcu_boot, MCUSR
003d39 2422                          clr zerol
003d3a 2433                          clr zeroh
003d3b 24bb                          clr isrflag
003d3c be24                          out_ MCUSR, zerol
                                     ; clear RAM
003d3d e0e0                          ldi zl, low(ramstart)
003d3e e0f1                          ldi zh, high(ramstart)
                                 clearloop:
003d3f 9221                          st Z+, zerol
003d40 30e0                          cpi zl, low(sram_size+ramstart)
003d41 f7e9                          brne clearloop
003d42 30f9                          cpi zh, high(sram_size+ramstart)
003d43 f7d9                          brne clearloop
                                     ; init first user data area
                                     ; allocate space for User Area
                                 .dseg
000194                           ram_user1: .byte SYSUSERSIZE + APPUSERSIZE
                                 .cseg
003d44 e9e4                          ldi zl, low(ram_user1)
003d45 e0f1                          ldi zh, high(ram_user1)
003d46 012f                          movw upl, zl
                                     ; init return stack pointer
003d47 ef0f                          ldi temp0,low(rstackstart)
003d48 bf0d                          out_ SPL,temp0
003d49 8304                          std Z+4, temp0
003d4a e018                          ldi temp1,high(rstackstart)
003d4b bf1e                          out_ SPH,temp1
003d4c 8315                          std Z+5, temp1
                                 
                                     ; init parameter stack pointer
003d4d eacf                          ldi yl,low(stackstart)
003d4e 83c6                          std Z+6, yl
003d4f e0d8                          ldi yh,high(stackstart)
003d50 83d7                          std Z+7, yh
                                 
                                     ; load Forth IP with starting word
003d51 e5a9                          ldi XL, low(PFA_WARM)
003d52 e3bd                          ldi XH, high(PFA_WARM)
                                     ; its a far jump...
003d53 cab0                          jmp_ DO_NEXT
                                 .include "words/warm.asm"
                                 
                                 ; System
                                 ; initialize amforth further. executes turnkey operation and go to quit
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_WARM:
003d54 ff04                          .dw $ff04
003d55 6177
003d56 6d72                          .db "warm"
003d57 3d33                          .dw VE_HEAD
                                     .set VE_HEAD = VE_WARM
                                 XT_WARM:
003d58 3800                          .dw DO_COLON
                                 PFA_WARM:
                                 .endif
003d59 02a2                          .dw XT_INIT_RAM
003d5a 383c                          .dw XT_DOLITERAL
003d5b 01a5                          .dw XT_NOOP
003d5c 383c                          .dw XT_DOLITERAL
003d5d 3d2f                          .dw XT_PAUSE
003d5e 3dde                          .dw XT_DEFERSTORE
003d5f 08f1                          .dw XT_LBRACKET
003d60 3f5b                          .dw XT_TURNKEY
003d61 3d06                          .dw XT_QUIT     ; never returns
                                 
                                 .include "words/handler.asm"
                                 
                                 ; Exceptions
                                 ; USER variable used by catch/throw
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_HANDLER:
003d62 ff07                          .dw $ff07
003d63 6168
003d64 646e
003d65 656c
003d66 0072                          .db "handler",0
003d67 3d54                          .dw VE_HEAD
                                     .set VE_HEAD = VE_HANDLER
                                 XT_HANDLER:
003d68 3857                          .dw PFA_DOUSER
                                 PFA_HANDLER:
                                 .endif
003d69 000a                          .dw USER_HANDLER
                                 .include "words/catch.asm"
                                 
                                 ; Exceptions
                                 ; execute XT and check for exceptions.
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_CATCH:
003d6a ff05                          .dw $ff05
003d6b 6163
003d6c 6374
003d6d 0068                          .db "catch",0
003d6e 3d62                          .dw VE_HEAD
                                     .set VE_HEAD = VE_CATCH
                                 XT_CATCH:
003d6f 3800                          .dw DO_COLON
                                 PFA_CATCH:
                                 .endif
                                 
                                     ; sp@ >r
003d70 3a8c                          .dw XT_SP_FETCH
003d71 38fe                          .dw XT_TO_R
                                     ; handler @ >r
003d72 3d68                          .dw XT_HANDLER
003d73 3878                          .dw XT_FETCH
003d74 38fe                          .dw XT_TO_R
                                     ; rp@ handler !
003d75 3a75                          .dw XT_RP_FETCH
003d76 3d68                          .dw XT_HANDLER
003d77 3880                          .dw XT_STORE
003d78 3829                          .dw XT_EXECUTE
                                     ; r> handler !
003d79 38f5                          .dw XT_R_FROM
003d7a 3d68                          .dw XT_HANDLER
003d7b 3880                          .dw XT_STORE
003d7c 38f5                          .dw XT_R_FROM
003d7d 38d8                          .dw XT_DROP
003d7e 3953                          .dw XT_ZERO
003d7f 381f                          .dw XT_EXIT
                                 .include "words/throw.asm"
                                 
                                 ; Exceptions
                                 ; throw an exception
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_THROW:
003d80 ff05                          .dw $ff05
003d81 6874
003d82 6f72
003d83 0077                          .db "throw",0
003d84 3d6a                          .dw VE_HEAD
                                     .set VE_HEAD = VE_THROW
                                 XT_THROW:
003d85 3800                          .dw DO_COLON
                                 PFA_THROW:
                                 .endif
003d86 38b0                          .dw XT_DUP
003d87 3919                          .dw XT_ZEROEQUAL
003d88 3835                          .dw XT_DOCONDBRANCH
003d89 3d8c                          DEST(PFA_THROW1)
003d8a 38d8                      	.dw XT_DROP
003d8b 381f                      	.dw XT_EXIT
                                 PFA_THROW1:
003d8c 3d68                          .dw XT_HANDLER
003d8d 3878                          .dw XT_FETCH
003d8e 3a7f                          .dw XT_RP_STORE
003d8f 38f5                          .dw XT_R_FROM
003d90 3d68                          .dw XT_HANDLER
003d91 3880                          .dw XT_STORE
003d92 38f5                          .dw XT_R_FROM
003d93 38c3                          .dw XT_SWAP
003d94 38fe                          .dw XT_TO_R
003d95 3a95                          .dw XT_SP_STORE
003d96 38d8                          .dw XT_DROP
003d97 38f5                          .dw XT_R_FROM    
003d98 381f                          .dw XT_EXIT
                                 
                                 
                                 
                                 .include "words/edefer-fetch.asm"
                                 
                                 ; System
                                 ; does the real defer@ for eeprom defers
                                 VE_EDEFERFETCH:
003d99 ff07                          .dw $ff07
003d9a 6445
003d9b 6665
003d9c 7265
003d9d 0040                          .db "Edefer@",0
003d9e 3d80                          .dw VE_HEAD
                                     .set VE_HEAD = VE_EDEFERFETCH
                                 XT_EDEFERFETCH:
003d9f 3800                          .dw DO_COLON
                                 PFA_EDEFERFETCH:
003da0 3bca                          .dw XT_FETCHI
003da1 3b5e                          .dw XT_FETCHE
003da2 381f                          .dw XT_EXIT
                                 .include "words/edefer-store.asm"
                                 
                                 ; System
                                 ; does the real defer! for eeprom defers
                                 VE_EDEFERSTORE:
003da3 ff07                          .dw $ff07
003da4 6445
003da5 6665
003da6 7265
003da7 0021                          .db "Edefer!",0
003da8 3d99                          .dw VE_HEAD
                                     .set VE_HEAD = VE_EDEFERSTORE
                                 XT_EDEFERSTORE:
003da9 3800                          .dw DO_COLON
                                 PFA_EDEFERSTORE:
003daa 3bca                          .dw XT_FETCHI
003dab 3b3a                          .dw XT_STOREE
003dac 381f                          .dw XT_EXIT
                                 .include "words/rdefer-fetch.asm"
                                 
                                 ; System
                                 ; The defer@ for ram defers
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_RDEFERFETCH:
003dad ff07                          .dw $ff07
003dae 6452
003daf 6665
003db0 7265
003db1 0040                          .db "Rdefer@",0
003db2 3da3                          .dw VE_HEAD
                                     .set VE_HEAD = VE_RDEFERFETCH
                                 XT_RDEFERFETCH:
003db3 3800                          .dw DO_COLON
                                 PFA_RDEFERFETCH:
                                 .endif
003db4 3bca                          .dw XT_FETCHI
003db5 3878                          .dw XT_FETCH
003db6 381f                          .dw XT_EXIT
                                 .include "words/rdefer-store.asm"
                                 
                                 ; System
                                 ; The defer! for ram defers
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_RDEFERSTORE:
003db7 ff07                          .dw $ff07
003db8 6452
003db9 6665
003dba 7265
003dbb 0021                          .db "Rdefer!",0
003dbc 3dad                          .dw VE_HEAD
                                     .set VE_HEAD = VE_RDEFERSTORE
                                 XT_RDEFERSTORE:
003dbd 3800                          .dw DO_COLON
                                 PFA_RDEFERSTORE:
                                 .endif
003dbe 3bca                          .dw XT_FETCHI
003dbf 3880                          .dw XT_STORE
003dc0 381f                          .dw XT_EXIT
                                 
                                 .include "words/udefer-fetch.asm"
                                 
                                 ; System
                                 ; does the real defer@ for user based defers
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_UDEFERFETCH:
003dc1 ff07                          .dw $ff07
003dc2 6455
003dc3 6665
003dc4 7265
003dc5 0040                          .db "Udefer@",0
003dc6 3db7                          .dw VE_HEAD
                                     .set VE_HEAD = VE_UDEFERFETCH
                                 XT_UDEFERFETCH:
003dc7 3800                          .dw DO_COLON
                                 PFA_UDEFERFETCH:
                                 .endif
003dc8 3bca                          .dw XT_FETCHI
003dc9 3b01                          .dw XT_UP_FETCH
003dca 399c                          .dw XT_PLUS
003dcb 3878                          .dw XT_FETCH
003dcc 381f                          .dw XT_EXIT
                                 .include "words/udefer-store.asm"
                                 
                                 ; System
                                 ; does the real defer! for user based defers
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_UDEFERSTORE:
003dcd ff07                          .dw $ff07
003dce 6455
003dcf 6665
003dd0 7265
003dd1 0021                          .db "Udefer!",0
003dd2 3dc1                          .dw VE_HEAD
                                     .set VE_HEAD = VE_UDEFERSTORE
                                 XT_UDEFERSTORE:
003dd3 3800                          .dw DO_COLON
                                 PFA_UDEFERSTORE:
                                 .endif
                                 
003dd4 3bca                          .dw XT_FETCHI
003dd5 3b01                          .dw XT_UP_FETCH
003dd6 399c                          .dw XT_PLUS
003dd7 3880                          .dw XT_STORE
003dd8 381f                          .dw XT_EXIT
                                 
                                 .include "words/defer-store.asm"
                                 
                                 ; System
                                 ; stores xt1 as the xt to be executed when xt2 is called
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_DEFERSTORE:
003dd9 ff06                          .dw $ff06
003dda 6564
003ddb 6566
003ddc 2172                          .db "defer!"
003ddd 3dcd                          .dw VE_HEAD
                                     .set VE_HEAD = VE_DEFERSTORE
                                 XT_DEFERSTORE:
003dde 3800                          .dw DO_COLON
                                 PFA_DEFERSTORE:
                                 .endif
003ddf 3fcf                          .dw XT_TO_BODY
003de0 38b0                          .dw XT_DUP
003de1 01d1                          .dw XT_ICELLPLUS
003de2 01d1                          .dw XT_ICELLPLUS
003de3 3bca                          .dw XT_FETCHI
003de4 3829                          .dw XT_EXECUTE
003de5 381f                          .dw XT_EXIT
                                 
                                 .include "words/defer-fetch.asm"
                                 
                                 ; System
                                 ; returns the XT associated with the given XT
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_DEFERFETCH:
003de6 ff06                          .dw $ff06
003de7 6564
003de8 6566
003de9 4072                          .db "defer@"
003dea 3dd9                          .dw VE_HEAD
                                     .set VE_HEAD = VE_DEFERFETCH
                                 XT_DEFERFETCH:
003deb 3800                          .dw DO_COLON
                                 PFA_DEFERFETCH:
                                 .endif
003dec 3fcf                          .dw XT_TO_BODY 
003ded 38b0                          .dw XT_DUP
003dee 01d1                          .dw XT_ICELLPLUS
003def 3bca                          .dw XT_FETCHI
003df0 3829                          .dw XT_EXECUTE
003df1 381f                          .dw XT_EXIT
                                 .include "words/do-defer.asm"
                                 
                                 ; System
                                 ; runtime of defer
                                 VE_DODEFER:
003df2 ff07                          .dw $ff07
003df3 6428
003df4 6665
003df5 7265
003df6 0029                          .db "(defer)", 0
003df7 3de6                          .dw VE_HEAD
                                     .set VE_HEAD = VE_DODEFER
                                 XT_DODEFER:
003df8 3800                          .dw DO_COLON
                                 PFA_DODEFER:
003df9 0739                          .dw XT_DOCREATE
003dfa 0899                          .dw XT_REVEAL
003dfb 075c                          .dw XT_COMPILE
003dfc 3dfe                          .dw PFA_DODEFER1
003dfd 381f                          .dw XT_EXIT
                                 PFA_DODEFER1:
003dfe 940e 08b2                     call_ DO_DODOES
003e00 38b0                          .dw XT_DUP
003e01 01d1                          .dw XT_ICELLPLUS
003e02 3bca                          .dw XT_FETCHI
003e03 3829                          .dw XT_EXECUTE 
003e04 3829                          .dw XT_EXECUTE
003e05 381f                          .dw XT_EXIT
                                 
                                 ; : (defer) <builds does> dup i-cell+ @i execute execute ;
                                 
                                 
                                 .include "words/u-dot.asm"
                                 
                                 ; Numeric IO
                                 ; unsigned PNO with single cell numbers
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_UDOT:
003e06 ff02                          .dw $ff02
003e07 2e75                          .db "u."
003e08 3df2                          .dw VE_HEAD
                                     .set VE_HEAD = VE_UDOT
                                 XT_UDOT:
003e09 3800                          .dw DO_COLON
                                 PFA_UDOT:
                                 .endif
003e0a 3953                          .dw XT_ZERO
003e0b 038d                          .dw XT_UDDOT
003e0c 381f                          .dw XT_EXIT
                                 ; : u.        ( us -- )    0 ud. ;
                                 .include "words/u-dot-r.asm"
                                 
                                 ; Numeric IO
                                 ; unsigned PNO with single cells numbers, right aligned in width w
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 
                                 
                                 VE_UDOTR:
003e0d ff03                          .dw $ff03
003e0e 2e75
003e0f 0072                          .db "u.r",0
003e10 3e06                          .dw VE_HEAD
                                     .set VE_HEAD = VE_UDOTR
                                 XT_UDOTR:
003e11 3800                          .dw DO_COLON
                                 PFA_UDOTR:
                                 .endif
003e12 3953                          .dw XT_ZERO
003e13 38c3                          .dw XT_SWAP
003e14 0396                          .dw XT_UDDOTR
003e15 381f                          .dw XT_EXIT
                                 ; : u.r       ( s n -- )   0 swap ud.r ;
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 .include "words/uslashmod.asm"
                                 
                                 ; Arithmetics
                                 ; unsigned division with remainder
                                 VE_USLASHMOD:
003e16 ff05                          .dw $ff05
003e17 2f75
003e18 6f6d
003e19 0064                          .db "u/mod",0
003e1a 3e0d                          .dw VE_HEAD
                                     .set VE_HEAD = VE_USLASHMOD
                                 XT_USLASHMOD:
003e1b 3800                          .dw DO_COLON
                                 PFA_USLASHMOD:
003e1c 38fe                          .dw XT_TO_R
003e1d 3953                          .dw XT_ZERO
003e1e 38f5                          .dw XT_R_FROM
003e1f 39c1                          .dw XT_UMSLASHMOD
003e20 381f                          .dw XT_EXIT
                                 .include "words/negate.asm"
                                 
                                 ; Logic
                                 ; 2-complement
                                 VE_NEGATE:
003e21 ff06                          .dw $ff06
003e22 656e
003e23 6167
003e24 6574                          .db "negate"
003e25 3e16                          .dw VE_HEAD
                                     .set VE_HEAD = VE_NEGATE
                                 XT_NEGATE:
003e26 3800                          .dw DO_COLON
                                 PFA_NEGATE:
003e27 39fc                          .dw XT_INVERT
003e28 3a2e                          .dw XT_1PLUS
003e29 381f                          .dw XT_EXIT
                                 .include "words/slash.asm"
                                 
                                 ; Arithmetics
                                 ; divide n1 by n2. giving the quotient
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 
                                 
                                 VE_SLASH:
003e2a ff01                          .dw $ff01
003e2b 002f                          .db "/",0
003e2c 3e21                          .dw VE_HEAD
                                     .set VE_HEAD = VE_SLASH
                                 XT_SLASH:
003e2d 3800                          .dw DO_COLON
                                 PFA_SLASH:
                                 .endif
003e2e 3c48                          .dw XT_SLASHMOD
003e2f 38ef                          .dw XT_NIP
003e30 381f                          .dw XT_EXIT
                                 
                                 .include "words/mod.asm"
                                 
                                 ; Arithmetics
                                 ; divide n1 by n2 giving the remainder n3
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 
                                 
                                 VE_MOD:
003e31 ff03                          .dw $ff03
003e32 6f6d
003e33 0064                          .db "mod",0
003e34 3e2a                          .dw VE_HEAD
                                     .set VE_HEAD = VE_MOD
                                 XT_MOD:
003e35 3800                          .dw DO_COLON
                                 PFA_MOD:
                                 .endif
003e36 3c48                          .dw XT_SLASHMOD
003e37 38d8                          .dw XT_DROP
003e38 381f                          .dw XT_EXIT
                                 
                                 .include "words/min.asm"
                                 
                                 ; Compare
                                 ; compare two values leave the smaller one
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 
                                 
                                 VE_MIN:
003e39 ff03                          .dw $ff03
003e3a 696d
003e3b 006e                          .db "min",0
003e3c 3e31                          .dw VE_HEAD
                                     .set VE_HEAD = VE_MIN
                                 XT_MIN:
003e3d 3800                          .dw DO_COLON
                                 PFA_MIN:
                                 .endif
003e3e 3ec8                          .dw XT_2DUP
003e3f 3977                          .dw XT_GREATER
003e40 3835                          .dw XT_DOCONDBRANCH
003e41 3e43                          DEST(PFA_MIN1)
003e42 38c3                          .dw XT_SWAP
                                 PFA_MIN1:
003e43 38d8                          .dw XT_DROP
003e44 381f                          .dw XT_EXIT
                                 .include "words/max.asm"
                                 
                                 ; Compare
                                 ; compare two values, leave the bigger one
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_MAX:
003e45 ff03                          .dw $ff03
003e46 616d
003e47 0078                          .db "max",0
003e48 3e39                          .dw VE_HEAD
                                     .set VE_HEAD = VE_MAX
                                 XT_MAX:
003e49 3800                          .dw DO_COLON
                                 PFA_MAX:
                                 
                                 .endif
003e4a 3ec8                          .dw XT_2DUP
003e4b 396d                          .dw XT_LESS
003e4c 3835                          .dw XT_DOCONDBRANCH
003e4d 3e4f                          DEST(PFA_MAX1)
003e4e 38c3                          .dw XT_SWAP
                                 PFA_MAX1:
003e4f 38d8                          .dw XT_DROP
003e50 381f                          .dw XT_EXIT
                                 .include "words/within.asm"
                                 
                                 ; Compare
                                 ; check if n is within min..max
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_WITHIN:
003e51 ff06                          .dw $ff06
003e52 6977
003e53 6874
003e54 6e69                          .db "within"
003e55 3e45                          .dw VE_HEAD
                                     .set VE_HEAD = VE_WITHIN
                                 XT_WITHIN:
003e56 3800                          .dw DO_COLON
                                 PFA_WITHIN:
                                 .endif
003e57 38ce                          .dw XT_OVER
003e58 3992                          .dw XT_MINUS
003e59 38fe                          .dw XT_TO_R
003e5a 3992                          .dw XT_MINUS
003e5b 38f5                          .dw XT_R_FROM
003e5c 395b                          .dw XT_ULESS
003e5d 381f                          .dw XT_EXIT
                                 
                                 .include "words/show-wordlist.asm"
                                 
                                 ; Tools
                                 ; prints the name of the words in a wordlist
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_SHOWWORDLIST:
003e5e ff0d                          .dw $ff0d
003e5f 6873
003e60 776f
003e61 772d
003e62 726f
003e63 6c64
003e64 7369
003e65 0074                          .db "show-wordlist",0
003e66 3e51                          .dw VE_HEAD
                                     .set VE_HEAD = VE_SHOWWORDLIST
                                 XT_SHOWWORDLIST:
003e67 3800                          .dw DO_COLON
                                 PFA_SHOWWORDLIST:
                                 .endif
003e68 383c                          .dw XT_DOLITERAL
003e69 3e6d                          .dw XT_SHOWWORD
003e6a 38c3                          .dw XT_SWAP
003e6b 06da                          .dw XT_TRAVERSEWORDLIST
003e6c 381f                          .dw XT_EXIT
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 XT_SHOWWORD:
003e6d 3800                          .dw DO_COLON
                                 PFA_SHOWWORD:
                                 .endif
003e6e 06f5                          .dw XT_NAME2STRING
003e6f 0403                          .dw XT_ITYPE
003e70 3fad                          .dw XT_SPACE         ; ( -- addr n)
003e71 394a                          .dw XT_TRUE
003e72 381f                          .dw XT_EXIT
                                 .include "words/words.asm"
                                 
                                 ; Tools
                                 ; prints a list of all (visible) words in the dictionary
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 
                                 
                                 VE_WORDS:
003e73 ff05                          .dw $ff05
003e74 6f77
003e75 6472
003e76 0073                          .db "words",0
003e77 3e5e                          .dw VE_HEAD
                                     .set VE_HEAD = VE_WORDS
                                 XT_WORDS:
003e78 3800                          .dw DO_COLON
                                 PFA_WORDS:
                                 .endif
003e79 383c                          .dw XT_DOLITERAL
003e7a 004c                          .dw CFG_ORDERLISTLEN+2
003e7b 3b5e                          .dw XT_FETCHE
003e7c 3e67                          .dw XT_SHOWWORDLIST
003e7d 381f                          .dw XT_EXIT
                                 
                                 .include "words/dot-quote.asm"
                                 
                                 ; Compiler
                                 ; compiles string into dictionary to be printed at runtime
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 
                                 
                                 VE_DOTSTRING:
003e7e 0002                          .dw $0002
003e7f 222e                          .db ".",$22
003e80 3e73                          .dw VE_HEAD
                                     .set VE_HEAD = VE_DOTSTRING
                                 XT_DOTSTRING:
003e81 3800                          .dw DO_COLON
                                 PFA_DOTSTRING:
                                 .endif
003e82 3e89                          .dw XT_SQUOTE
003e83 075c                          .dw XT_COMPILE
003e84 0403                          .dw XT_ITYPE
003e85 381f                          .dw XT_EXIT
                                 .include "words/squote.asm"
                                 
                                 ; Compiler
                                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_SQUOTE:
003e86 0002                        .dw $0002
003e87 2273                        .db "s",$22
003e88 3e7e                        .dw VE_HEAD
                                   .set VE_HEAD = VE_SQUOTE
                                 XT_SQUOTE:
003e89 3800                          .dw DO_COLON
                                 PFA_SQUOTE:
                                 .endif
003e8a 383c                          .dw XT_DOLITERAL
003e8b 0022                          .dw 34   ; 0x22 
003e8c 058e                          .dw XT_PARSE       ; ( -- addr n)
003e8d 3eb6                          .dw XT_STATE
003e8e 3878                          .dw XT_FETCH
003e8f 3835                          .dw XT_DOCONDBRANCH
003e90 3e92                          DEST(PFA_SQUOTE1)
003e91 0788                            .dw XT_SLITERAL
                                 PFA_SQUOTE1:
003e92 381f                          .dw XT_EXIT
                                 .include "words/fill.asm"
                                 
                                 ; Memory
                                 ; fill u bytes memory beginning at a-addr with character c
                                 VE_FILL:
003e93 ff04                          .dw $ff04
003e94 6966
003e95 6c6c                          .db "fill"
003e96 3e86                          .dw VE_HEAD
                                     .set VE_HEAD = VE_FILL
                                 XT_FILL:
003e97 3800                          .dw DO_COLON
                                 PFA_FILL:
003e98 38e0                          .dw XT_ROT
003e99 38e0                          .dw XT_ROT
003e9a 38b8
003e9b 3835                          .dw XT_QDUP,XT_DOCONDBRANCH
003e9c 3ea4                          DEST(PFA_FILL2)
003e9d 3f98                          .dw XT_BOUNDS
003e9e 3a9a                          .dw XT_DODO
                                 PFA_FILL1:
003e9f 38b0                          .dw XT_DUP
003ea0 3aab                          .dw XT_I
003ea1 388c                          .dw XT_CSTORE  ; ( -- c c-addr)
003ea2 3ac8                          .dw XT_DOLOOP
003ea3 3e9f                          .dw PFA_FILL1
                                 PFA_FILL2:
003ea4 38d8                          .dw XT_DROP
003ea5 381f                          .dw XT_EXIT
                                 
                                 .include "words/f_cpu.asm"
                                 
                                 ; System
                                 ; put the cpu frequency in Hz on stack
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_F_CPU:
003ea6 ff05                          .dw $ff05
003ea7 5f66
003ea8 7063
003ea9 0075                          .db "f_cpu",0
003eaa 3e93                          .dw VE_HEAD
                                     .set VE_HEAD = VE_F_CPU
                                 XT_F_CPU:
003eab 3800                          .dw DO_COLON
                                 PFA_F_CPU:
                                 .endif
003eac 383c                          .dw XT_DOLITERAL
003ead 2400                          .dw (F_CPU % 65536)
003eae 383c                          .dw XT_DOLITERAL
003eaf 00f4                          .dw (F_CPU / 65536)
003eb0 381f                          .dw XT_EXIT
                                 .include "words/state.asm"
                                 
                                 ; System Variable
                                 ; system state
                                 VE_STATE:
003eb1 ff05                          .dw $ff05
003eb2 7473
003eb3 7461
003eb4 0065                          .db "state",0
003eb5 3ea6                          .dw VE_HEAD
                                     .set VE_HEAD = VE_STATE
                                 XT_STATE:
003eb6 3847                          .dw PFA_DOVARIABLE
                                 PFA_STATE:
003eb7 01c0                          .dw ram_state
                                 
                                 .dseg
0001c0                           ram_state: .byte 2
                                 .include "words/base.asm"
                                 
                                 ; Numeric IO
                                 ; location of the cell containing the number conversion radix
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_BASE:
003eb8 ff04                          .dw $ff04
003eb9 6162
003eba 6573                          .db "base"
003ebb 3eb1                          .dw VE_HEAD
                                     .set VE_HEAD = VE_BASE
                                 XT_BASE:
003ebc 3857                          .dw PFA_DOUSER
                                 PFA_BASE:
                                 .endif
003ebd 000c                          .dw USER_BASE
                                 
                                 .include "words/cells.asm"
                                 
                                 ; Arithmetics
                                 ; n2 is the size in address units of n1 cells
                                 VE_CELLS:
003ebe ff05                          .dw $ff05
003ebf 6563
003ec0 6c6c
003ec1 0073                          .db "cells",0
003ec2 3eb8                          .dw VE_HEAD
                                     .set VE_HEAD = VE_CELLS
                                 XT_CELLS:
003ec3 3a0b                          .dw PFA_2STAR
                                 
                                 .include "words/2dup.asm"
                                 
                                 ; Stack
                                 ; Duplicate the 2 top elements
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_2DUP:
003ec4 ff04                          .dw $ff04
003ec5 6432
003ec6 7075                          .db "2dup"
003ec7 3ebe                          .dw VE_HEAD
                                     .set VE_HEAD = VE_2DUP
                                 XT_2DUP:
003ec8 3800                          .dw DO_COLON
                                 PFA_2DUP:
                                 .endif
                                 
003ec9 38ce                          .dw XT_OVER
003eca 38ce                          .dw XT_OVER
003ecb 381f                          .dw XT_EXIT
                                 .include "words/2drop.asm"
                                 
                                 ; Stack
                                 ; Remove the 2 top elements
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_2DROP:
003ecc ff05                          .dw $ff05
003ecd 6432
003ece 6f72
003ecf 0070                          .db "2drop",0
003ed0 3ec4                          .dw VE_HEAD
                                     .set VE_HEAD = VE_2DROP
                                 XT_2DROP:
003ed1 3800                          .dw DO_COLON
                                 PFA_2DROP:
                                 .endif
003ed2 38d8                          .dw XT_DROP
003ed3 38d8                          .dw XT_DROP
003ed4 381f                          .dw XT_EXIT
                                 .include "words/tuck.asm"
                                 
                                 ; Stack
                                 ; Copy the first (top) stack item below the second stack item. 
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_TUCK:
003ed5 ff04                          .dw $ff04
003ed6 7574
003ed7 6b63                          .db "tuck"
003ed8 3ecc                          .dw VE_HEAD
                                     .set VE_HEAD = VE_TUCK
                                 XT_TUCK:
003ed9 3800                          .dw DO_COLON
                                 PFA_TUCK:
                                 .endif
003eda 38c3                          .dw XT_SWAP
003edb 38ce                          .dw XT_OVER
003edc 381f                          .dw XT_EXIT
                                 
                                 .include "words/to-in.asm"
                                 
                                 ; System Variable
                                 ; pointer to current read position in input buffer
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_TO_IN:
003edd ff03                          .dw $ff03
003ede 693e
003edf 006e                          .db ">in",0
003ee0 3ed5                          .dw VE_HEAD
                                     .set VE_HEAD = VE_TO_IN
                                 XT_TO_IN:
003ee1 3857                          .dw PFA_DOUSER
                                 PFA_TO_IN:
                                 .endif
003ee2 0018                          .dw USER_TO_IN
                                 .include "words/pad.asm"
                                 
                                 ; System Variable
                                 ; Address of the temporary scratch buffer.
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_PAD:
003ee3 ff03                          .dw $ff03
003ee4 6170
003ee5 0064                          .db "pad",0
003ee6 3edd                          .dw VE_HEAD
                                     .set VE_HEAD = VE_PAD
                                 XT_PAD:
003ee7 3800                          .dw DO_COLON
                                 PFA_PAD:
                                 .endif
003ee8 3f22                          .dw XT_HERE
003ee9 383c                          .dw XT_DOLITERAL
003eea 0028                          .dw 40
003eeb 399c                          .dw XT_PLUS
003eec 381f                          .dw XT_EXIT
                                 .include "words/emit.asm"
                                 
                                 ; Character IO
                                 ; fetch the emit vector and execute it. should emit a character from TOS
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_EMIT:
003eed ff04                          .dw $ff04
003eee 6d65
003eef 7469                          .db "emit"
003ef0 3ee3                          .dw VE_HEAD
                                     .set VE_HEAD = VE_EMIT
                                 XT_EMIT:
003ef1 3dfe                          .dw PFA_DODEFER1
                                 PFA_EMIT:
                                 .endif
003ef2 000e                          .dw USER_EMIT
003ef3 3dc7                          .dw XT_UDEFERFETCH
003ef4 3dd3                          .dw XT_UDEFERSTORE
                                 .include "words/emitq.asm"
                                 
                                 ; Character IO
                                 ; fetch emit? vector and execute it. should return the ready-to-send condition
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_EMITQ:
003ef5 ff05                          .dw $ff05
003ef6 6d65
003ef7 7469
003ef8 003f                          .db "emit?",0
003ef9 3eed                          .dw VE_HEAD
                                     .set VE_HEAD = VE_EMITQ
                                 XT_EMITQ:
003efa 3dfe                          .dw PFA_DODEFER1
                                 PFA_EMITQ:
                                 .endif
003efb 0010                          .dw USER_EMITQ
003efc 3dc7                          .dw XT_UDEFERFETCH
003efd 3dd3                          .dw XT_UDEFERSTORE
                                 .include "words/key.asm"
                                 
                                 ; Character IO
                                 ; fetch key vector and execute it, should leave a single character on TOS
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_KEY:
003efe ff03                          .dw $ff03
003eff 656b
003f00 0079                          .db "key",0
003f01 3ef5                          .dw VE_HEAD
                                     .set VE_HEAD = VE_KEY
                                 XT_KEY:
003f02 3dfe                          .dw PFA_DODEFER1
                                 PFA_KEY:
                                 .endif
003f03 0012                          .dw USER_KEY
003f04 3dc7                          .dw XT_UDEFERFETCH
003f05 3dd3                          .dw XT_UDEFERSTORE
                                 .include "words/keyq.asm"
                                 
                                 ; Character IO
                                 ; fetch key? vector and execute it. should turn on key sender, if it is disabled/stopped
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_KEYQ:
003f06 ff04                          .dw $ff04
003f07 656b
003f08 3f79                          .db "key?"
003f09 3efe                          .dw VE_HEAD
                                     .set VE_HEAD = VE_KEYQ
                                 XT_KEYQ:
003f0a 3dfe                          .dw PFA_DODEFER1
                                 PFA_KEYQ:
                                 .endif
003f0b 0014                          .dw USER_KEYQ
003f0c 3dc7                          .dw XT_UDEFERFETCH
003f0d 3dd3                          .dw XT_UDEFERSTORE
                                 
                                 .include "words/dp.asm"
                                 
                                 ; System Value
                                 ; address of the next free dictionary cell
                                 VE_DP:
003f0e ff02                          .dw $ff02
003f0f 7064                          .db "dp"
003f10 3f06                          .dw VE_HEAD
                                     .set VE_HEAD = VE_DP
                                 XT_DP:
003f11 386e                          .dw PFA_DOVALUE1
                                 PFA_DP:
003f12 0036                          .dw CFG_DP
003f13 3d9f                          .dw XT_EDEFERFETCH
003f14 3da9                          .dw XT_EDEFERSTORE
                                 .include "words/ehere.asm"
                                 
                                 ; System Value
                                 ; address of the next free address in eeprom
                                 VE_EHERE:
003f15 ff05                          .dw $ff05
003f16 6865
003f17 7265
003f18 0065                          .db "ehere",0
003f19 3f0e                          .dw VE_HEAD
                                     .set VE_HEAD = VE_EHERE
                                 XT_EHERE:
003f1a 386e                          .dw PFA_DOVALUE1
                                 PFA_EHERE:
003f1b 003a                          .dw EE_EHERE
003f1c 3d9f                          .dw XT_EDEFERFETCH
003f1d 3da9                          .dw XT_EDEFERSTORE
                                 .include "words/here.asm"
                                 
                                 ; System Value
                                 ; address of the next free data space (RAM) cell
                                 VE_HERE:
003f1e ff04                          .dw $ff04
003f1f 6568
003f20 6572                          .db "here"
003f21 3f15                          .dw VE_HEAD
                                     .set VE_HEAD = VE_HERE
                                 XT_HERE:
003f22 386e                          .dw PFA_DOVALUE1
                                 PFA_HERE:
003f23 0038                          .dw EE_HERE
003f24 3d9f                          .dw XT_EDEFERFETCH
003f25 3da9                          .dw XT_EDEFERSTORE
                                 .include "words/allot.asm"
                                 
                                 ; System
                                 ; allocate or release memory in RAM
                                 VE_ALLOT:
003f26 ff05                          .dw $ff05
003f27 6c61
003f28 6f6c
003f29 0074                          .db "allot",0
003f2a 3f1e                          .dw VE_HEAD
                                     .set VE_HEAD = VE_ALLOT
                                 XT_ALLOT:
003f2b 3800                          .dw DO_COLON
                                 PFA_ALLOT:
003f2c 3f22                          .dw XT_HERE
003f2d 399c                          .dw XT_PLUS
003f2e 01bf                          .dw XT_DOTO
003f2f 3f23                          .dw PFA_HERE
003f30 381f                          .dw XT_EXIT
                                 
                                 .include "words/bin.asm"
                                 
                                 ; Numeric IO
                                 ; set base for numeric conversion to 10
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_BIN:
003f31 ff03                          .dw $ff03
003f32 6962
003f33 006e                          .db "bin",0
003f34 3f26                          .dw VE_HEAD
                                     .set VE_HEAD = VE_BIN
                                 XT_BIN:
003f35 3800                          .dw DO_COLON
                                 PFA_BIN:
                                 .endif
003f36 3fea                          .dw XT_TWO
003f37 3ebc                          .dw XT_BASE
003f38 3880                          .dw XT_STORE
003f39 381f                          .dw XT_EXIT
                                 .include "words/decimal.asm"
                                 
                                 ; Numeric IO
                                 ; set base for numeric conversion to 10
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_DECIMAL:
003f3a ff07                          .dw $ff07
003f3b 6564
003f3c 6963
003f3d 616d
003f3e 006c                          .db "decimal",0
003f3f 3f31                          .dw VE_HEAD
                                     .set VE_HEAD = VE_DECIMAL
                                 XT_DECIMAL:
003f40 3800                          .dw DO_COLON
                                 PFA_DECIMAL:
                                 .endif
003f41 383c                          .dw XT_DOLITERAL
003f42 000a                          .dw 10
003f43 3ebc                          .dw XT_BASE
003f44 3880                          .dw XT_STORE
003f45 381f                          .dw XT_EXIT
                                 .include "words/hex.asm"
                                 
                                 ; Numeric IO
                                 ; set base for numeric conversion to 10
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_HEX:
003f46 ff03                          .dw $ff03
003f47 6568
003f48 0078                          .db "hex",0
003f49 3f3a                          .dw VE_HEAD
                                     .set VE_HEAD = VE_HEX
                                 XT_HEX:
003f4a 3800                          .dw DO_COLON
                                 PFA_HEX:
                                 .endif
003f4b 383c                          .dw XT_DOLITERAL
003f4c 0010                          .dw 16
003f4d 3ebc                          .dw XT_BASE
003f4e 3880                          .dw XT_STORE
003f4f 381f                          .dw XT_EXIT
                                 .include "words/bl.asm"
                                 
                                 ; Character IO
                                 ; put ascii code of the blank to the stack
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_BL:
003f50 ff02                          .dw $ff02
003f51 6c62                          .db "bl"
003f52 3f46                          .dw VE_HEAD
                                     .set VE_HEAD = VE_BL
                                 XT_BL:
003f53 3847                          .dw PFA_DOVARIABLE
                                 PFA_BL:
                                 .endif
003f54 0020                          .dw 32
                                 
                                 .include "words/turnkey.asm"
                                 
                                 ; System Value
                                 ; Deferred action during startup/reset
                                 VE_TURNKEY:
003f55 ff07                          .dw $ff07
003f56 7574
003f57 6e72
003f58 656b
003f59 0079                          .db "turnkey",0
003f5a 3f50                          .dw VE_HEAD
                                     .set VE_HEAD = VE_TURNKEY
                                 XT_TURNKEY:
003f5b 3dfe                          .dw PFA_DODEFER1
                                 PFA_TURNKEY:
003f5c 0042                          .dw CFG_TURNKEY
003f5d 3d9f                          .dw XT_EDEFERFETCH
003f5e 3da9                          .dw XT_EDEFERSTORE
                                 .include "words/to-upper.asm"
                                 
                                 ; String
                                 ; if c is a lowercase letter convert it to uppercase
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_TOUPPER:
003f5f ff07                          .dw $ff07 
003f60 6f74
003f61 7075
003f62 6570
003f63 0072                          .db "toupper",0
003f64 3f55                          .dw VE_HEAD
                                     .set VE_HEAD = VE_TOUPPER
                                 XT_TOUPPER:
003f65 3800                          .dw DO_COLON 
                                 PFA_TOUPPER:
                                 .endif
003f66 38b0                          .dw XT_DUP 
003f67 383c                          .dw XT_DOLITERAL 
003f68 0061                          .dw 'a' 
003f69 383c                          .dw XT_DOLITERAL 
003f6a 007b                          .dw 'z'+1
003f6b 3e56                          .dw XT_WITHIN 
003f6c 3835                          .dw XT_DOCONDBRANCH
003f6d 3f71                          DEST(PFA_TOUPPER0)
003f6e 383c                          .dw XT_DOLITERAL
003f6f 00df                          .dw 223 ; inverse of 0x20: 0xdf
003f70 3a12                          .dw XT_AND 
                                 PFA_TOUPPER0:
003f71 381f                          .dw XT_EXIT 
                                 .include "words/to-lower.asm"
                                 
                                 ; String
                                 ; if C is an uppercase letter convert it to lowercase
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 
                                 
                                 VE_TOLOWER:
003f72 ff07                          .dw $ff07
003f73 6f74
003f74 6f6c
003f75 6577
003f76 0072                          .db "tolower",0
003f77 3f5f                          .dw VE_HEAD
                                     .set VE_HEAD = VE_TOLOWER
                                 XT_TOLOWER:
003f78 3800                          .dw DO_COLON
                                 PFA_TOLOWER:
                                 .endif
003f79 38b0                          .dw XT_DUP
003f7a 383c                          .dw XT_DOLITERAL
003f7b 0041                          .dw 'A'
003f7c 383c                          .dw XT_DOLITERAL
003f7d 005b                          .dw 'Z'+1
003f7e 3e56                          .dw XT_WITHIN
003f7f 3835                          .dw XT_DOCONDBRANCH
003f80 3f84                          DEST(PFA_TOLOWER0)
003f81 383c                          .dw XT_DOLITERAL
003f82 0020                          .dw 32
003f83 3a1b                          .dw XT_OR 
                                 PFA_TOLOWER0:
003f84 381f                          .dw XT_EXIT 
                                 
                                 .include "words/q-stack.asm"
                                 
                                 ; Tools
                                 ; check data stack depth and exit to quit if underrun
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_QSTACK:
003f85 ff06                          .dw $ff06
003f86 733f
003f87 6174
003f88 6b63                          .db "?stack"
003f89 3f72                          .dw VE_HEAD
                                     .set VE_HEAD = VE_QSTACK
                                 XT_QSTACK:
003f8a 3800                          .dw DO_COLON
                                 PFA_QSTACK:
                                 .endif
003f8b 05ed                          .dw XT_DEPTH
003f8c 3920                          .dw XT_ZEROLESS
003f8d 3835                          .dw XT_DOCONDBRANCH
003f8e 3f92                          DEST(PFA_QSTACK1)
003f8f 383c                            .dw XT_DOLITERAL
003f90 fffc                            .dw -4
003f91 3d85                            .dw XT_THROW
                                 PFA_QSTACK1:
003f92 381f                          .dw XT_EXIT
                                 .include "words/bounds.asm"
                                 
                                 ; Tools
                                 ; convert a string to an address range
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_BOUNDS:
003f93 ff06                          .dw $ff06
003f94 6f62
003f95 6e75
003f96 7364                          .db "bounds"
003f97 3f85                          .dw VE_HEAD
                                     .set VE_HEAD = VE_BOUNDS
                                 XT_BOUNDS:
003f98 3800                          .dw DO_COLON
                                 PFA_BOUNDS:
                                 .endif
003f99 38ce                          .dw XT_OVER
003f9a 399c                          .dw XT_PLUS
003f9b 38c3                          .dw XT_SWAP
003f9c 381f                          .dw XT_EXIT
                                 .include "words/cr.asm"
                                 
                                 ; Character IO
                                 ; cause subsequent output appear at the beginning of the next line
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_CR:
003f9d ff02                          .dw 0xff02
003f9e 7263                          .db "cr"
003f9f 3f93                          .dw VE_HEAD
                                     .set VE_HEAD = VE_CR
                                 XT_CR:
003fa0 3800                          .dw DO_COLON
                                 PFA_CR:
                                 .endif
                                 
003fa1 383c                          .dw XT_DOLITERAL
003fa2 000d                          .dw 13
003fa3 3ef1                          .dw XT_EMIT
003fa4 383c                          .dw XT_DOLITERAL
003fa5 000a                          .dw 10
003fa6 3ef1                          .dw XT_EMIT
003fa7 381f                          .dw XT_EXIT
                                 .include "words/space.asm"
                                 
                                 ; Character IO
                                 ; emits a space (bl)
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_SPACE:
003fa8 ff05                          .dw $ff05
003fa9 7073
003faa 6361
003fab 0065                          .db "space",0
003fac 3f9d                          .dw VE_HEAD
                                     .set VE_HEAD = VE_SPACE
                                 XT_SPACE:
003fad 3800                          .dw DO_COLON
                                 PFA_SPACE:
                                 .endif
003fae 3f53                          .dw XT_BL
003faf 3ef1                          .dw XT_EMIT
003fb0 381f                          .dw XT_EXIT
                                 .include "words/spaces.asm"
                                 
                                 ; Character IO
                                 ; emits n space(s) (bl)
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_SPACES:
003fb1 ff06                          .dw $ff06
003fb2 7073
003fb3 6361
003fb4 7365                          .db "spaces"
003fb5 3fa8                          .dw VE_HEAD
                                     .set VE_HEAD = VE_SPACES
                                 XT_SPACES:
003fb6 3800                          .dw DO_COLON
                                 PFA_SPACES:
                                 
                                 .endif
                                 ;C SPACES   n --            output n spaces
                                 ;   BEGIN DUP 0> WHILE SPACE 1- REPEAT DROP ;
003fb7 3953
003fb8 3e49                      	.DW XT_ZERO, XT_MAX
003fb9 38b0
003fba 3835                      SPCS1:  .DW XT_DUP,XT_DOCONDBRANCH
003fbb 3fc0                              DEST(SPCS2)
003fbc 3fad
003fbd 3a34
003fbe 382e                              .DW XT_SPACE,XT_1MINUS,XT_DOBRANCH
003fbf 3fb9                              DEST(SPCS1)
003fc0 38d8
003fc1 381f                      SPCS2:  .DW XT_DROP,XT_EXIT
                                 .include "words/s-to-d.asm"
                                 
                                 ; Conversion
                                 ; extend (signed) single cell value to double cell
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_S2D:
003fc2 ff03                          .dw $ff03
003fc3 3e73
003fc4 0064                          .db "s>d",0
003fc5 3fb1                          .dw VE_HEAD
                                     .set VE_HEAD = VE_S2D
                                 XT_S2D:
003fc6 3800                          .dw DO_COLON
                                 PFA_S2D:
                                 .endif
003fc7 38b0                          .dw XT_DUP
003fc8 3920                          .dw XT_ZEROLESS
003fc9 381f                          .dw XT_EXIT
                                 .include "words/to-body.asm"
                                 
                                 ; Core
                                 ; get body from XT
                                 VE_TO_BODY:
003fca ff05                          .dw $ff05
003fcb 623e
003fcc 646f
003fcd 0079                          .db ">body",0
003fce 3fc2                          .dw VE_HEAD
                                     .set VE_HEAD = VE_TO_BODY
                                 XT_TO_BODY:
003fcf 3a2f                          .dw PFA_1PLUS
                                 .elif AMFORTH_NRWW_SIZE>2000
                                 .else
                                 .endif
                                 ; now colon words
                                 ;;;;;;;;;;;;;;;;;;;;;;;;
                                 .include "words/2literal.asm"
                                 
                                 ; Compiler
                                 ; compile a cell pair literal in colon definitions
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_2LITERAL:
003fd0 0008                          .dw $0008
003fd1 6c32
003fd2 7469
003fd3 7265
003fd4 6c61                          .db "2literal"
003fd5 3fca                          .dw VE_HEAD
                                     .set VE_HEAD = VE_2LITERAL
                                 XT_2LITERAL:
003fd6 3800                          .dw DO_COLON
                                 PFA_2LITERAL:
                                 .endif
003fd7 38c3                          .dw XT_SWAP
003fd8 077d                          .dw XT_LITERAL
003fd9 077d                          .dw XT_LITERAL
003fda 381f                          .dw XT_EXIT
                                 .include "words/equal.asm"
                                 
                                 ; Compare
                                 ; compares two values for equality
                                 VE_EQUAL:
003fdb ff01                          .dw $ff01
003fdc 003d                          .db "=",0
003fdd 3fd0                          .dw VE_HEAD
                                     .set VE_HEAD = VE_EQUAL
                                 XT_EQUAL:
003fde 3800                          .dw DO_COLON
                                 PFA_EQUAL:
003fdf 3992                          .dw XT_MINUS
003fe0 3919                          .dw XT_ZEROEQUAL
003fe1 381f                          .dw XT_EXIT
                                 .include "words/num-constants.asm"
                                 
                                 .endif
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_ONE:
003fe2 ff01                          .dw $ff01
003fe3 0031                          .db "1",0
003fe4 3fdb                          .dw VE_HEAD
                                     .set VE_HEAD = VE_ONE
                                 XT_ONE:
003fe5 3847                          .dw PFA_DOVARIABLE
                                 PFA_ONE:
                                 .endif
003fe6 0001                              .DW 1
                                 
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_TWO:
003fe7 ff01                          .dw $ff01
003fe8 0032                          .db "2",0
003fe9 3fe2                          .dw VE_HEAD
                                     .set VE_HEAD = VE_TWO
                                 XT_TWO:
003fea 3847                          .dw PFA_DOVARIABLE
                                 PFA_TWO:
                                 .endif
003feb 0002                              .DW 2
                                 .if cpu_msp430==1
                                 .endif
                                 
                                 .if cpu_avr8==1
                                 VE_MINUSONE:
003fec ff02                          .dw $ff02
003fed 312d                          .db "-1"
003fee 3fe7                          .dw VE_HEAD
                                     .set VE_HEAD = VE_MINUSONE
                                 XT_MINUSONE:
003fef 3847                          .dw PFA_DOVARIABLE
                                 PFA_MINUSONE:
                                 .endif
003ff0 ffff                              .DW -1
                                 .include "dict_appl_core.inc"
                                 
                                 ; do not delete it!
                                 
                                 .set flashlast = pc
                                 .if (pc>FLASHEND)
                                 .endif
                                 
                                 .dseg
                                 ; define a label for the 1st free ram address
                                 HERESTART:
                                 .eseg
                                 .include "amforth-eeprom.inc"
000034 ff ff                     
                                 ; some configs
000036 ba 0a                     CFG_DP:      .dw DPSTART         ; Dictionary Pointer
000038 c2 01                     EE_HERE:     .dw HERESTART       ; Memory Allocation
00003a 8e 00                     EE_EHERE:    .dw EHERESTART      ; EEProm Memory Allocation
00003c ce 09                     CFG_WLSCOPE: .dw XT_GET_CURRENT  ; default wordlist scope
00003e 5c 00                     CFG_FORTHRECOGNIZER: .dw CFG_RECOGNIZERLISTLEN ; Recognizer word set
                                 ; LEAVE stack is between data stack and return stack.
000040 b0 08                     CFG_LP0:     .dw stackstart+1
000042 ac 0a                     CFG_TURNKEY: .dw XT_APPLTURNKEY    ; TURNKEY
000044 ff 02                     CFG_ENVIRONMENT:.dw VE_ENVHEAD     ; environmental queries
000046 48 00                     CFG_CURRENT: .dw CFG_FORTHWORDLIST ; forth-wordlist
000048 ec 3f                     CFG_FORTHWORDLIST:.dw VE_HEAD      ; pre-defined (compiled in) wordlist
                                 CFG_ORDERLISTLEN:
00004a 01 00                         .dw 1
                                 CFG_ORDERLIST: ; list of wordlist id, exactly numwordlist entries
00004c 48 00                         .dw CFG_FORTHWORDLIST      ; get/set-order
00004e                               .byte  (NUMWORDLISTS-1)*CELLSIZE ; one slot is already used
                                 CFG_RECOGNIZERLISTLEN:
00005c 02 00                         .dw 2
                                 CFG_RECOGNIZERLIST:
00005e 70 06                         .dw XT_REC_FIND
000060 5c 06                         .dw XT_REC_NUM
000062                               .byte  (NUMRECOGNIZERS-2)*CELLSIZE ; two slots are already used
                                 
                                 EE_STOREI:
000066 7d 3b                         .dw XT_DO_STOREI  ; Store a cell into flash
                                 
                                 ; MARKER saves everything up to here. Nothing beyond gets saved
                                 EE_MARKER:
000068 68 00                         .dw EE_MARKER
                                 
                                 ; default user area
                                 EE_INITUSER:
00006a 00 00                         .dw 0  ; USER_STATE
00006c 00 00                         .dw 0  ; USER_FOLLOWER
00006e ff 08                         .dw rstackstart  ; USER_RP
000070 af 08                         .dw stackstart   ; USER_SP0
000072 af 08                         .dw stackstart   ; USER_SP
                                     
000074 00 00                         .dw 0  ; USER_HANDLER
000076 0a 00                         .dw 10 ; USER_BASE
                                     
000078 a3 00                         .dw XT_TX  ; USER_EMIT
00007a b1 00                         .dw XT_TXQ ; USER_EMITQ
00007c 78 00                         .dw XT_RX  ; USER_KEY
00007e 93 00                         .dw XT_RXQ ; USER_KEYQ
000080 77 02                         .dw XT_SOURCETIB ; USER_SOURCE
000082 00 00                         .dw 0            ; USER_G_IN
000084 64 02                         .dw XT_REFILLTIB ; USER_REFILL  
000086 c8 3c                         .dw XT_DEFAULT_PROMPTOK
000088 e7 3c                         .dw XT_DEFAULT_PROMPTERROR
00008a d7 3c                         .dw XT_DEFAULT_PROMPTREADY
                                 
                                 ; calculate baud rate error
                                 .equ UBRR_VAL   = ((F_CPU+BAUD*8)/(BAUD*16)-1)  ; smart round
                                 .equ BAUD_REAL  = (F_CPU/(16*(UBRR_VAL+1)))     ; effective baud rate
                                 .equ BAUD_ERROR = ((BAUD_REAL*1000)/BAUD-1000)  ; error in pro mille
                                 
                                 .if ((BAUD_ERROR>BAUD_MAXERROR) || (BAUD_ERROR<-BAUD_MAXERROR))       
                                 .endif
                                 EE_UBRRVAL:
00008c 19 00                         .dw UBRR_VAL     ; BAUDRATE
                                 ; 1st free address in EEPROM.
                                 EHERESTART:
                                 .cseg


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega328P" register use summary:
x  :   4 y  : 205 z  :  48 r0 :  25 r1 :   5 r2 :   9 r3 :  12 r4 :   4 
r5 :   1 r6 :   0 r7 :   0 r8 :   0 r9 :   0 r10:   1 r11:   6 r12:   0 
r13:   0 r14:  22 r15:  20 r16:  80 r17:  61 r18:  52 r19:  37 r20:  13 
r21:  11 r22:  11 r23:   3 r24: 193 r25: 136 r26:  28 r27:  17 r28:   7 
r29:   4 r30:  85 r31:  47 
Registers used: 29 out of 35 (82.9%)

"ATmega328P" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  22 add   :  17 adiw  :  17 and   :   4 
andi  :   3 asr   :   2 bclr  :   0 bld   :   0 brbc  :   2 brbs  :   7 
brcc  :   3 brcs  :   1 break :   0 breq  :   6 brge  :   1 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   1 brlt  :   3 brmi  :   3 
brne  :  20 brpl  :   0 brsh  :   0 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   2 bset  :   0 bst   :   0 call  :   2 cbi   :   7 cbr   :   0 
clc   :   2 clh   :   0 cli   :   7 cln   :   0 clr   :  13 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :  14 cp    :  11 cpc   :  10 
cpi   :   2 cpse  :   0 dec   :  10 eor   :   3 fmul  :   0 fmuls :   0 
fmulsu:   0 icall :   0 ijmp  :   1 in    :  18 inc   :   3 jmp   :   9 
ld    : 136 ldd   :   4 ldi   :  41 lds   :   1 lpm   :  16 lsl   :  14 
lsr   :   2 mov   :  16 movw  :  65 mul   :   5 muls  :   1 mulsu :   2 
neg   :   0 nop   :   0 or    :   9 ori   :   2 out   :  18 pop   :  45 
push  :  39 rcall :  38 ret   :   6 reti  :   1 rjmp  : 103 rol   :  23 
ror   :   6 sbc   :   9 sbci  :   3 sbi   :   8 sbic  :   3 sbis  :   0 
sbiw  :  14 sbr   :   0 sbrc  :   5 sbrs  :   4 sec   :   1 seh   :   0 
sei   :   1 sen   :   0 ser   :   4 ses   :   0 set   :   0 sev   :   0 
sez   :   0 sleep :   0 spm   :   2 st    :  76 std   :   8 sts   :   1 
sub   :   6 subi  :   3 swap  :   0 tst   :   0 wdr   :   0 
Instructions used: 71 out of 113 (62.8%)

"ATmega328P" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x007fe2   1958  11618  13576   32768  41.4%
[.dseg] 0x000100 0x0001c2      0    194    194    2048   9.5%
[.eseg] 0x000000 0x00008e      0    142    142    1024  13.9%

Assembly complete, 0 errors, 8 warnings
